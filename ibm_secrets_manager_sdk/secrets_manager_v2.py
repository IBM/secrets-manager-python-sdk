# coding: utf-8

# (C) Copyright IBM Corp. 2023.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.82.1-2082d402-20231115-195014

"""
With IBM CloudÂ® Secrets Manager, you can create, lease, and centrally manage secrets that
are used in IBM Cloud services or your custom-built applications.

API Version: 2.0.0
See: https://cloud.ibm.com/docs/secrets-manager
"""

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
import json
import sys

from ibm_cloud_sdk_core import BaseService, DetailedResponse, get_query_param
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_list, convert_model, datetime_to_string, string_to_datetime

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################


class SecretsManagerV2(BaseService):
    """The secrets-manager V2 service."""

    DEFAULT_SERVICE_URL = 'https://provide-here-your-smgr-instanceuuid.us-south.secrets-manager.appdomain.cloud'
    DEFAULT_SERVICE_NAME = 'secrets_manager'

    PARAMETERIZED_SERVICE_URL = 'https://{instance_id}.{region}.secrets-manager.appdomain.cloud'

    @classmethod
    def new_instance(
        cls,
        service_name: str = DEFAULT_SERVICE_NAME,
    ) -> 'SecretsManagerV2':
        """
        Return a new client for the secrets-manager service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            authenticator
            )
        service.configure_service(service_name)
        return service

    @classmethod
    def construct_service_url(
        cls,
        instance_id: str = 'provide-here-your-smgr-instanceuuid',
        region: str = 'us-south',
    ) -> str:
        """
        Construct a service URL by formatting the parameterized service URL.

        The parameterized service URL is:
        'https://{instance_id}.{region}.secrets-manager.appdomain.cloud'

        :param str instance_id: (optional) The Secrets Manager Instance ID assigned by the service provider
            (default 'provide-here-your-smgr-instanceuuid')
        :param str region: (optional) The region where you provisioned your Secrets Manager Instance. Available values: us-south, us-east, au-syd, jp-osa, jp-tok, eu-de, eu-gb, ca-tor, br-sao
            (default 'us-south')
        :return: The formatted URL with all variable placeholders replaced by values.
        :rtype: str
        """
        return cls.PARAMETERIZED_SERVICE_URL.format(
            instance_id=instance_id,
            region=region,
        )

    def __init__(
        self,
        authenticator: Authenticator = None,
    ) -> None:
        """
        Construct a new client for the secrets-manager service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/main/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self, service_url=self.DEFAULT_SERVICE_URL, authenticator=authenticator)

    #########################
    # Secret groups
    #########################

    def create_secret_group(
        self,
        name: str,
        *,
        description: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new secret group.

        Create a secret group that you can use to organize secrets and control who can
        access them.
        A successful request returns the ID value of the secret group, along with other
        properties. To learn more about secret groups, check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-secret-groups).

        :param str name: The name of your secret group.
        :param str description: (optional) An extended description of your secret
               group.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroup` object
        """

        if name is None:
            raise ValueError('name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_group',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secret_groups'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_groups(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secret groups.

        List the secret groups that are available in your Secrets Manager instance.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroupCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_groups',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secret_groups'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_group(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a secret group.

        Get the properties of an existing secret group by specifying the ID of the group.

        :param str id: The v4 UUID that uniquely identifies your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroup` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_group',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_secret_group(
        self,
        id: str,
        secret_group_patch: 'SecretGroupPatch',
        **kwargs,
    ) -> DetailedResponse:
        """
        Update a secret group.

        Update the properties of an existing secret group, such as its name or
        description.

        :param str id: The v4 UUID that uniquely identifies your secret group.
        :param SecretGroupPatch secret_group_patch: The request body to update a
               secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroup` object
        """

        if not id:
            raise ValueError('id must be provided')
        if secret_group_patch is None:
            raise ValueError('secret_group_patch must be provided')
        if isinstance(secret_group_patch, SecretGroupPatch):
            secret_group_patch = convert_model(secret_group_patch)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_secret_group',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_group_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_group(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a secret group.

        Delete a secret group by specifying the ID of the secret group.
        **Note:** To delete a secret group, it must be empty. If you need to remove a
        secret group that contains secrets, you must first [delete the
        secrets](#delete-secret) that are associated with the group.

        :param str id: The v4 UUID that uniquely identifies your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_group',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Secrets
    #########################

    def create_secret(
        self,
        secret_prototype: 'SecretPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new secret.

        Create a secret or import an existing value that you can use to access or
        authenticate to a protected resource.
        Use this operation to either generate or import an existing secret, such as a TLS
        certificate, that you can manage in your Secrets Manager service instance. A
        successful request stores the secret in your dedicated instance, based on the
        secret type and data that you specify. The response returns the ID value of the
        secret, along with other metadata.
        To learn more about the types of secrets that you can create with Secrets Manager,
        check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-what-is-secret).

        :param SecretPrototype secret_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Secret` object
        """

        if secret_prototype is None:
            raise ValueError('secret_prototype must be provided')
        if isinstance(secret_prototype, SecretPrototype):
            secret_prototype = convert_model(secret_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secrets'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secrets(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        search: Optional[str] = None,
        groups: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secrets.

        List the secrets that are available in your Secrets Manager instance.

        :param int offset: (optional) The number of secrets to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 secrets in your instance, and you want to
               retrieve secrets 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of secrets by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** id | created_at | updated_at | expiration_date |
               secret_type | name
               **Usage:** To sort a list of secrets by their creation date, use
               `../secrets?sort=created_at`.
        :param str search: (optional) Obtain a collection of secrets that contain
               the specified string in one or more of the fields: `id`, `name`,
               `description`,
               `labels`, `secret_type`.
               **Usage:** If you want to list only the secrets that contain the string
               `text`, use
               `../secrets?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretMetadataPaginatedCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secrets',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
            'groups': convert_list(groups),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secrets'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a secret.

        Get a secret and its details by specifying the ID of the secret.
        A successful request returns the secret data that is associated with your secret,
        along with other metadata. To view only the details of a specified secret without
        retrieving its value, use the [Get secret metadata](#get-secret-metadata)
        operation.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Secret` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a secret.

        Delete a secret by specifying the ID of the secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_metadata(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get the metadata of a secret.

        Get the metadata of a secret by specifying the ID of the secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretMetadata` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_metadata',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_secret_metadata(
        self,
        id: str,
        secret_metadata_patch: 'SecretMetadataPatch',
        **kwargs,
    ) -> DetailedResponse:
        """
        Update the metadata of a secret.

        Update the metadata of a secret, such as its name or description.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param SecretMetadataPatch secret_metadata_patch:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretMetadata` object
        """

        if not id:
            raise ValueError('id must be provided')
        if secret_metadata_patch is None:
            raise ValueError('secret_metadata_patch must be provided')
        if isinstance(secret_metadata_patch, SecretMetadataPatch):
            secret_metadata_patch = convert_model(secret_metadata_patch)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_secret_metadata',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_metadata_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_action(
        self,
        id: str,
        secret_action_prototype: 'SecretActionPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a secret action.

        Create a secret action. This operation supports the following actions:.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param SecretActionPrototype secret_action_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretAction` object
        """

        if not id:
            raise ValueError('id must be provided')
        if secret_action_prototype is None:
            raise ValueError('secret_action_prototype must be provided')
        if isinstance(secret_action_prototype, SecretActionPrototype):
            secret_action_prototype = convert_model(secret_action_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_action',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_action_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_by_name_type(
        self,
        secret_type: str,
        name: str,
        secret_group_name: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a secret by name.

        Get a secret and its details by specifying the Name and Type of the secret.
        A successful request returns the secret data that is associated with your secret,
        along with other metadata. To view only the details of a specified secret without
        retrieving its value, use the [Get secret metadata](#get-secret-metadata)
        operation.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret. To protect
               your privacy, do not use personal data, such as your name or location, as a
               name for your secret.
        :param str secret_group_name: The name of your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Secret` object
        """

        if not secret_type:
            raise ValueError('secret_type must be provided')
        if not name:
            raise ValueError('name must be provided')
        if not secret_group_name:
            raise ValueError('secret_group_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_by_name_type',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_type', 'name', 'secret_group_name']
        path_param_values = self.encode_path_vars(secret_type, name, secret_group_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{secret_group_name}/secret_types/{secret_type}/secrets/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Secret versions
    #########################

    def create_secret_version(
        self,
        secret_id: str,
        secret_version_prototype: 'SecretVersionPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new secret version.

        Create a new secret version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param SecretVersionPrototype secret_version_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersion` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if secret_version_prototype is None:
            raise ValueError('secret_version_prototype must be provided')
        if isinstance(secret_version_prototype, SecretVersionPrototype):
            secret_version_prototype = convert_model(secret_version_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_version',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_version_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id']
        path_param_values = self.encode_path_vars(secret_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_versions(
        self,
        secret_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        List versions of a secret.

        List the versions of a secret.
        A successful request returns the list of versions of a secret, along with the
        metadata of each version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionMetadataCollection` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_versions',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id']
        path_param_values = self.encode_path_vars(secret_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_version(
        self,
        secret_id: str,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a version of a secret.

        Get a version of a secret by specifying the ID of the version. You can use the
        `current` or `previous` aliases to refer to the current or previous secret
        version.
        A successful request returns the secret data that is associated with the specified
        version of your secret, along with other metadata.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersion` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_version',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_version_data(
        self,
        secret_id: str,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete the data of a secret version.

        Delete the data of a secret version by specifying the ID of the version.
        This operation is available for secret type: iam_credentials current version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_version_data',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/secret_data'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_version_metadata(
        self,
        secret_id: str,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get the metadata of a secret version.

        Get the metadata of a secret version by specifying the ID of the version. You can
        use the `current` or `previous` aliases to refer to the current or previous secret
        version.
        A successful request returns the metadata that is associated with the specified
        version of your secret.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionMetadata` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_version_metadata',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_secret_version_metadata(
        self,
        secret_id: str,
        id: str,
        secret_version_metadata_patch: 'SecretVersionMetadataPatch',
        **kwargs,
    ) -> DetailedResponse:
        """
        Update the metadata of a secret version.

        Update the custom metadata of a secret version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param SecretVersionMetadataPatch secret_version_metadata_patch:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionMetadata` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        if secret_version_metadata_patch is None:
            raise ValueError('secret_version_metadata_patch must be provided')
        if isinstance(secret_version_metadata_patch, SecretVersionMetadataPatch):
            secret_version_metadata_patch = convert_model(secret_version_metadata_patch)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_secret_version_metadata',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_version_metadata_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_version_action(
        self,
        secret_id: str,
        id: str,
        secret_version_action_prototype: 'SecretVersionActionPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a version action.

        Create a secret version action. This operation supports the following actions:
        - `private_cert_action_revoke_certificate`: Revoke a version of a private
        certificate.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param SecretVersionActionPrototype secret_version_action_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VersionAction` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        if secret_version_action_prototype is None:
            raise ValueError('secret_version_action_prototype must be provided')
        if isinstance(secret_version_action_prototype, SecretVersionActionPrototype):
            secret_version_action_prototype = convert_model(secret_version_action_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_version_action',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_version_action_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Secret locks
    #########################

    def list_secrets_locks(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        search: Optional[str] = None,
        groups: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secrets and their locks.

        List the secrets and their locks in your Secrets Manager instance.

        :param int offset: (optional) The number of secrets to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 secrets in your instance, and you want to
               retrieve secrets 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretsLocksPaginatedCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secrets_locks',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'search': search,
            'groups': convert_list(groups),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secrets_locks'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_locks(
        self,
        id: str,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        search: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secret locks.

        List the locks that are associated with a specified secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param int offset: (optional) The number of locks to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 locks on your secret, and you want to retrieve
               locks 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocksPaginatedCollection` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_locks',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/locks'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_locks_bulk(
        self,
        id: str,
        locks: List['SecretLockPrototype'],
        *,
        mode: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create secret locks.

        Create a lock on the current version of a secret.
        A lock can be used to prevent a secret from being deleted or modified while it's
        in use by your applications. A successful request attaches a new lock to your
        secret, or replaces a lock of the same name if it already exists. Additionally,
        you can use this operation to clear any matching locks on a secret by using one of
        the following optional lock modes:
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret.\n
        - `remove_previous_and_delete`: Carries out the same function as
        `remove_previous`, but also permanently deletes the data of the previous secret
        version if it doesn't have any locks.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param List[SecretLockPrototype] locks: The locks data to be attached to a
               secret version.
        :param str mode: (optional) An optional lock mode. When you create a lock,
               you can set one of the following modes to clear any matching locks on a
               secret version.
               - `remove_previous`: Removes any other locks with matching names if they
               are found in the previous version of the secret. -
               `remove_previous_and_delete`: Completes the same action as
               `remove_previous`, but also permanently deletes the data of the previous
               secret version if it doesn't have any locks.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not id:
            raise ValueError('id must be provided')
        if locks is None:
            raise ValueError('locks must be provided')
        locks = [convert_model(x) for x in locks]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'mode': mode,
        }

        data = {
            'locks': locks,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            params=params,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_locks_bulk(
        self,
        id: str,
        *,
        name: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete secret locks.

        Delete all the locks or a subset of the locks that are associated with a version
        of a secret.
        To delete only a subset of the locks, add a query param with a comma to separate
        the list of lock names:
        Example: `?name=lock-example-1,lock-example-2`.
        **Note:** A secret is considered unlocked and able to be deleted only after you
        remove all of its locks. To determine whether a secret contains locks, check the
        `locks_total` field that is returned as part of the metadata of your secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param List[str] name: (optional) Specify the names of the secret locks to
               be deleted.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'name': convert_list(name),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_version_locks(
        self,
        secret_id: str,
        id: str,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        search: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secret version locks.

        List the locks that are associated with a specified secret version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param int offset: (optional) The number of locks to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 locks on your secret, and you want to retrieve
               locks 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionLocksPaginatedCollection` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_version_locks',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/locks'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_version_locks_bulk(
        self,
        secret_id: str,
        id: str,
        locks: List['SecretLockPrototype'],
        *,
        mode: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create secret version locks.

        Create a lock on the specified version of a secret.
        A lock can be used to prevent a secret from being deleted or modified while it's
        in use by your applications. A successful request attaches a new lock to your
        secret, or replaces a lock of the same name if it already exists. Additionally,
        you can use this operation to clear any matching locks on a secret by using one of
        the following optional lock modes:
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret.
        - `remove_previous_and_delete`: Carries out the same function as
        `remove_previous`, but also permanently deletes the data of the previous secret
        version if it doesn't have any locks.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param List[SecretLockPrototype] locks: The locks data to be attached to a
               secret version.
        :param str mode: (optional) An optional lock mode. When you create a lock,
               you can set one of the following modes to clear any matching locks on a
               secret version.
               - `remove_previous`: Removes any other locks with matching names if they
               are found in the previous version of the secret. -
               `remove_previous_and_delete`: Completes the same action as
               `remove_previous`, but also permanently deletes the data of the previous
               secret version if it doesn't have any locks.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        if locks is None:
            raise ValueError('locks must be provided')
        locks = [convert_model(x) for x in locks]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_version_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'mode': mode,
        }

        data = {
            'locks': locks,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            params=params,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_version_locks_bulk(
        self,
        secret_id: str,
        id: str,
        *,
        name: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete locks on a secret version.

        Delete all the locks or a subset of the locks that are associated with the
        specified version of a secret.
        To delete only a subset of the locks, add a query param with a comma to separate
        the list of lock names:
        Example: `?name=lock-example-1,lock-example-2`.
        **Note:** A secret is considered unlocked and able to be deleted only after all of
        its locks are removed. To determine whether a secret contains locks, check the
        `locks_total` field that is returned as part of the metadata of your secret.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param List[str] name: (optional) Specify the names of the secret locks to
               be deleted.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_version_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'name': convert_list(name),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Configurations
    #########################

    def create_configuration(
        self,
        configuration_prototype: 'ConfigurationPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new configuration.

        Add a configuration to the specified secret type.
        Use this operation to define the configurations that are required to create public
        certificates (`public_cert`), private certificates (`private_cert`) and IAM
        Credentials secrets (`iam_credentials`).
        You can add multiple configurations for your instance as follows:
        - A single configuration for IAM Credentials.
        - Up to 10 CA configurations for public certificates.
        - Up to 10 DNS configurations for public certificates.
        - Up to 10 Root CA configurations for private certificates.
        - Up to 10 Intermediate CA configurations for private certificates.
        - Up to 10 Certificate Template configurations for private certificates.

        :param ConfigurationPrototype configuration_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Configuration` object
        """

        if configuration_prototype is None:
            raise ValueError('configuration_prototype must be provided')
        if isinstance(configuration_prototype, ConfigurationPrototype):
            configuration_prototype = convert_model(configuration_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_configuration',
        )
        headers.update(sdk_headers)

        data = json.dumps(configuration_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/configurations'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_configurations(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        search: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List configurations.

        List the configurations that are available in your Secrets Manager instance.

        :param int offset: (optional) The number of configurations to skip. By
               specifying `offset`, you retrieve a subset of items that starts with the
               `offset` value. Use `offset` with `limit` to page through your available
               resources.
               **Usage:** If you have 100 configurations in your instance, and you want to
               retrieve configurations 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of configurations to retrieve. By
               default, list operations return the first 200 items. To retrieve a
               different set of items, use `limit` with `offset` to page through your
               available resources. Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 configurations in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of configurations by the
               specified field in ascending order. To sort in descending order use the `-`
               character
               **Available values:**  config_type | secret_type | name
               **Usage:** To sort a list of configurations by their creation date, use
               `../configurations?sort=config_type`.
        :param str search: (optional) Obtain a collection of configurations that
               contain the specified string in one or more of the fields: `name`,
               `config_type`, `secret_type`.
               **Usage:** If you want to list only the configurations that contain the
               string `text`, use
               `../configurations?search=text`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ConfigurationMetadataPaginatedCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_configurations',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/configurations'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_configuration(
        self,
        name: str,
        *,
        x_sm_accept_configuration_type: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a configuration.

        Get a configuration by specifying its name.
        A successful request returns the details of your configuration.

        :param str name: The name that uniquely identifies a configuration.
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Configuration` object
        """

        if not name:
            raise ValueError('name must be provided')
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_configuration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_configuration(
        self,
        name: str,
        configuration_patch: 'ConfigurationPatch',
        *,
        x_sm_accept_configuration_type: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update configuration.

        Update a configuration.

        :param str name: The name that uniquely identifies a configuration.
        :param ConfigurationPatch configuration_patch:
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Configuration` object
        """

        if not name:
            raise ValueError('name must be provided')
        if configuration_patch is None:
            raise ValueError('configuration_patch must be provided')
        if isinstance(configuration_patch, ConfigurationPatch):
            configuration_patch = convert_model(configuration_patch)
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_configuration',
        )
        headers.update(sdk_headers)

        data = json.dumps(configuration_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_configuration(
        self,
        name: str,
        *,
        x_sm_accept_configuration_type: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a configuration.

        Delete a configuration by specifying its name.

        :param str name: The name that uniquely identifies a configuration.
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not name:
            raise ValueError('name must be provided')
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_configuration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def create_configuration_action(
        self,
        name: str,
        config_action_prototype: 'ConfigurationActionPrototype',
        *,
        x_sm_accept_configuration_type: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a configuration action.

        Create a configuration action. This operation supports the following actions:
        - `private_cert_configuration_action_sign_intermediate`: Sign an intermediate
        certificate authority.
        - `private_cert_configuration_action_sign_csr`: Sign a certificate signing
        request.
        - `private_cert_configuration_action_set_signed`: Set a signed intermediate
        certificate authority.
        - `private_cert_configuration_action_revoke_ca_certificate`: Revoke an internally
        signed intermediate certificate authority certificate.
        - `private_cert_configuration_action_rotate_crl`: Rotate the certificate
        revocation list (CRL) of an intermediate certificate authority.

        :param str name: The name that uniquely identifies a configuration.
        :param ConfigurationActionPrototype config_action_prototype:
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ConfigurationAction` object
        """

        if not name:
            raise ValueError('name must be provided')
        if config_action_prototype is None:
            raise ValueError('config_action_prototype must be provided')
        if isinstance(config_action_prototype, ConfigurationActionPrototype):
            config_action_prototype = convert_model(config_action_prototype)
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_configuration_action',
        )
        headers.update(sdk_headers)

        data = json.dumps(config_action_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Notifications
    #########################

    def create_notifications_registration(
        self,
        event_notifications_instance_crn: str,
        event_notifications_source_name: str,
        *,
        event_notifications_source_description: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Register with Event Notifications instance.

        Create a registration between a Secrets Manager instance and [Event
        Notifications](https://cloud.ibm.com/apidocs/event-notifications).
        A successful request adds Secrets Manager as a source that you can reference from
        your Event Notifications instance. For more information about enabling
        notifications for Secrets Manager, check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).

        :param str event_notifications_instance_crn: A CRN that uniquely identifies
               an IBM Cloud resource.
        :param str event_notifications_source_name: The name that is displayed as a
               source that is in your Event Notifications instance.
        :param str event_notifications_source_description: (optional) An optional
               description for the source that is in your Event Notifications instance.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `NotificationsRegistration` object
        """

        if event_notifications_instance_crn is None:
            raise ValueError('event_notifications_instance_crn must be provided')
        if event_notifications_source_name is None:
            raise ValueError('event_notifications_source_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_notifications_registration',
        )
        headers.update(sdk_headers)

        data = {
            'event_notifications_instance_crn': event_notifications_instance_crn,
            'event_notifications_source_name': event_notifications_source_name,
            'event_notifications_source_description': event_notifications_source_description,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/notifications/registration'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_notifications_registration(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get Event Notifications registration details.

        Get the details of the registration between your Secrets Manager instance and
        Event Notifications.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `NotificationsRegistration` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_notifications_registration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/notifications/registration'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_notifications_registration(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Unregister from Event Notifications instance.

        Delete the registration between your Secrets Manager instance and Event
        Notifications.
        A successful request removes your Secrets Manager instance as a source in Event
        Notifications.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_notifications_registration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        url = '/api/v2/notifications/registration'
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_notifications_registration_test(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Send a test event for Event Notifications registrations.

        Send a test event from a Secrets Manager instance to a configured [Event
        Notifications](https://cloud.ibm.com/apidocs/event-notifications) instance.
        A successful request sends a test event to the Event Notifications instance. For
        more information about enabling notifications for Secrets Manager, check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_notifications_registration_test',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        url = '/api/v2/notifications/registration/test'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response


class GetSecretByNameTypeEnums:
    """
    Enums for get_secret_by_name_type parameters.
    """

    class SecretType(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


class CreateSecretLocksBulkEnums:
    """
    Enums for create_secret_locks_bulk parameters.
    """

    class Mode(str, Enum):
        """
        An optional lock mode. When you create a lock, you can set one of the following
        modes to clear any matching locks on a secret version.
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret. - `remove_previous_and_delete`: Completes
        the same action as `remove_previous`, but also permanently deletes the data of the
        previous secret version if it doesn't have any locks.
        """

        REMOVE_PREVIOUS = 'remove_previous'
        REMOVE_PREVIOUS_AND_DELETE = 'remove_previous_and_delete'


class CreateSecretVersionLocksBulkEnums:
    """
    Enums for create_secret_version_locks_bulk parameters.
    """

    class Mode(str, Enum):
        """
        An optional lock mode. When you create a lock, you can set one of the following
        modes to clear any matching locks on a secret version.
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret. - `remove_previous_and_delete`: Completes
        the same action as `remove_previous`, but also permanently deletes the data of the
        previous secret version if it doesn't have any locks.
        """

        REMOVE_PREVIOUS = 'remove_previous'
        REMOVE_PREVIOUS_AND_DELETE = 'remove_previous_and_delete'


class GetConfigurationEnums:
    """
    Enums for get_configuration parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


class UpdateConfigurationEnums:
    """
    Enums for update_configuration parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


class DeleteConfigurationEnums:
    """
    Enums for delete_configuration parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


class CreateConfigurationActionEnums:
    """
    Enums for create_configuration_action parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


##############################################################################
# Models
##############################################################################


class CertificateIssuanceInfo:
    """
    Issuance information that is associated with your certificate.

    :param bool auto_rotated: (optional) This parameter indicates whether the issued
          certificate is configured with an automatic rotation policy.
    :param List[ChallengeResource] challenges: (optional) The set of challenges. It
          is returned only when ordering public certificates by using manual DNS
          configuration.
    :param datetime dns_challenge_validation_time: (optional) The date that a user
          requests to validate DNS challenges for certificates that are ordered with a
          manual DNS provider. The date format follows `RFC 3339`.
    :param str error_code: (optional) A code that identifies an issuance error.
          This field, along with `error_message`, is returned when Secrets Manager
          successfully processes your request, but the certificate authority is unable to
          issue a certificate.
    :param str error_message: (optional) A human-readable message that provides
          details about the issuance error.
    :param datetime ordered_on: (optional) The date when the certificate is ordered.
          The date format follows `RFC 3339`.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    """

    def __init__(
        self,
        *,
        auto_rotated: Optional[bool] = None,
        challenges: Optional[List['ChallengeResource']] = None,
        dns_challenge_validation_time: Optional[datetime] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        ordered_on: Optional[datetime] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
    ) -> None:
        """
        Initialize a CertificateIssuanceInfo object.

        """
        self.auto_rotated = auto_rotated
        self.challenges = challenges
        self.dns_challenge_validation_time = dns_challenge_validation_time
        self.error_code = error_code
        self.error_message = error_message
        self.ordered_on = ordered_on
        self.state = state
        self.state_description = state_description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CertificateIssuanceInfo':
        """Initialize a CertificateIssuanceInfo object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'challenges' in _dict:
            args['challenges'] = [ChallengeResource.from_dict(v) for v in _dict.get('challenges')]
        if 'dns_challenge_validation_time' in _dict:
            args['dns_challenge_validation_time'] = string_to_datetime(_dict.get('dns_challenge_validation_time'))
        if 'error_code' in _dict:
            args['error_code'] = _dict.get('error_code')
        if 'error_message' in _dict:
            args['error_message'] = _dict.get('error_message')
        if 'ordered_on' in _dict:
            args['ordered_on'] = string_to_datetime(_dict.get('ordered_on'))
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CertificateIssuanceInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and getattr(self, 'auto_rotated') is not None:
            _dict['auto_rotated'] = getattr(self, 'auto_rotated')
        if hasattr(self, 'challenges') and getattr(self, 'challenges') is not None:
            challenges_list = []
            for v in getattr(self, 'challenges'):
                if isinstance(v, dict):
                    challenges_list.append(v)
                else:
                    challenges_list.append(v.to_dict())
            _dict['challenges'] = challenges_list
        if hasattr(self, 'dns_challenge_validation_time') and getattr(self, 'dns_challenge_validation_time') is not None:
            _dict['dns_challenge_validation_time'] = datetime_to_string(getattr(self, 'dns_challenge_validation_time'))
        if hasattr(self, 'error_code') and getattr(self, 'error_code') is not None:
            _dict['error_code'] = getattr(self, 'error_code')
        if hasattr(self, 'error_message') and getattr(self, 'error_message') is not None:
            _dict['error_message'] = getattr(self, 'error_message')
        if hasattr(self, 'ordered_on') and getattr(self, 'ordered_on') is not None:
            _dict['ordered_on'] = datetime_to_string(getattr(self, 'ordered_on'))
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CertificateIssuanceInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CertificateIssuanceInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CertificateIssuanceInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class CertificateValidity:
    """
    The date and time that the certificate validity period begins and ends.

    :param datetime not_before: The date-time format follows `RFC 3339`.
    :param datetime not_after: The date-time format follows `RFC 3339`.
    """

    def __init__(
        self,
        not_before: datetime,
        not_after: datetime,
    ) -> None:
        """
        Initialize a CertificateValidity object.

        :param datetime not_before: The date-time format follows `RFC 3339`.
        :param datetime not_after: The date-time format follows `RFC 3339`.
        """
        self.not_before = not_before
        self.not_after = not_after

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CertificateValidity':
        """Initialize a CertificateValidity object from a json dictionary."""
        args = {}
        if 'not_before' in _dict:
            args['not_before'] = string_to_datetime(_dict.get('not_before'))
        else:
            raise ValueError('Required property \'not_before\' not present in CertificateValidity JSON')
        if 'not_after' in _dict:
            args['not_after'] = string_to_datetime(_dict.get('not_after'))
        else:
            raise ValueError('Required property \'not_after\' not present in CertificateValidity JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CertificateValidity object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'not_before') and self.not_before is not None:
            _dict['not_before'] = datetime_to_string(self.not_before)
        if hasattr(self, 'not_after') and self.not_after is not None:
            _dict['not_after'] = datetime_to_string(self.not_after)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CertificateValidity object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CertificateValidity') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CertificateValidity') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ChallengeResource:
    """
    Properties that describe a challenge.

    :param str domain: (optional) The challenge domain.
    :param datetime expiration: (optional) The challenge expiration date. The date
          format follows `RFC 3339`.
    :param str status: (optional) The challenge status.
    :param str txt_record_name: (optional) The TXT record name.
    :param str txt_record_value: (optional) The TXT record value.
    """

    def __init__(
        self,
        *,
        domain: Optional[str] = None,
        expiration: Optional[datetime] = None,
        status: Optional[str] = None,
        txt_record_name: Optional[str] = None,
        txt_record_value: Optional[str] = None,
    ) -> None:
        """
        Initialize a ChallengeResource object.

        """
        self.domain = domain
        self.expiration = expiration
        self.status = status
        self.txt_record_name = txt_record_name
        self.txt_record_value = txt_record_value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ChallengeResource':
        """Initialize a ChallengeResource object from a json dictionary."""
        args = {}
        if 'domain' in _dict:
            args['domain'] = _dict.get('domain')
        if 'expiration' in _dict:
            args['expiration'] = string_to_datetime(_dict.get('expiration'))
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'txt_record_name' in _dict:
            args['txt_record_name'] = _dict.get('txt_record_name')
        if 'txt_record_value' in _dict:
            args['txt_record_value'] = _dict.get('txt_record_value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ChallengeResource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'domain') and getattr(self, 'domain') is not None:
            _dict['domain'] = getattr(self, 'domain')
        if hasattr(self, 'expiration') and getattr(self, 'expiration') is not None:
            _dict['expiration'] = datetime_to_string(getattr(self, 'expiration'))
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        if hasattr(self, 'txt_record_name') and getattr(self, 'txt_record_name') is not None:
            _dict['txt_record_name'] = getattr(self, 'txt_record_name')
        if hasattr(self, 'txt_record_value') and getattr(self, 'txt_record_value') is not None:
            _dict['txt_record_value'] = getattr(self, 'txt_record_value')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ChallengeResource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ChallengeResource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ChallengeResource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Configuration:
    """
    Your configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a Configuration object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PublicCertificateConfigurationCALetsEncrypt', 'PublicCertificateConfigurationDNSCloudInternetServices', 'PublicCertificateConfigurationDNSClassicInfrastructure', 'IAMCredentialsConfiguration', 'PrivateCertificateConfigurationRootCA', 'PrivateCertificateConfigurationIntermediateCA', 'PrivateCertificateConfigurationTemplate'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Configuration':
        """Initialize a Configuration object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'Configuration'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PublicCertificateConfigurationCALetsEncrypt', 'PublicCertificateConfigurationDNSCloudInternetServices', 'PublicCertificateConfigurationDNSClassicInfrastructure', 'IAMCredentialsConfiguration', 'PrivateCertificateConfigurationRootCA', 'PrivateCertificateConfigurationIntermediateCA', 'PrivateCertificateConfigurationTemplate'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a Configuration object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['public_cert_configuration_ca_lets_encrypt'] = 'PublicCertificateConfigurationCALetsEncrypt'
        mapping['public_cert_configuration_dns_cloud_internet_services'] = 'PublicCertificateConfigurationDNSCloudInternetServices'
        mapping['public_cert_configuration_dns_classic_infrastructure'] = 'PublicCertificateConfigurationDNSClassicInfrastructure'
        mapping['iam_credentials_configuration'] = 'IAMCredentialsConfiguration'
        mapping['private_cert_configuration_root_ca'] = 'PrivateCertificateConfigurationRootCA'
        mapping['private_cert_configuration_intermediate_ca'] = 'PrivateCertificateConfigurationIntermediateCA'
        mapping['private_cert_configuration_template'] = 'PrivateCertificateConfigurationTemplate'
        disc_value = _dict.get('config_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'config_type\' not found in Configuration JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationAction:
    """
    The response body to specify the properties of the action to create a configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationAction object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationActionRevoke', 'PrivateCertificateConfigurationActionSignCSR', 'PrivateCertificateConfigurationActionSignIntermediate', 'PrivateCertificateConfigurationActionSetSigned', 'PrivateCertificateConfigurationActionRotateCRL'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationAction':
        """Initialize a ConfigurationAction object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationAction'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateConfigurationActionRevoke', 'PrivateCertificateConfigurationActionSignCSR', 'PrivateCertificateConfigurationActionSignIntermediate', 'PrivateCertificateConfigurationActionSetSigned', 'PrivateCertificateConfigurationActionRotateCRL'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationAction object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_configuration_action_revoke_ca_certificate'] = 'PrivateCertificateConfigurationActionRevoke'
        mapping['private_cert_configuration_action_sign_csr'] = 'PrivateCertificateConfigurationActionSignCSR'
        mapping['private_cert_configuration_action_sign_intermediate'] = 'PrivateCertificateConfigurationActionSignIntermediate'
        mapping['private_cert_configuration_action_set_signed'] = 'PrivateCertificateConfigurationActionSetSigned'
        mapping['private_cert_configuration_action_rotate_crl'] = 'PrivateCertificateConfigurationActionRotateCRL'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in ConfigurationAction JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationActionPrototype:
    """
    The request body to specify the properties of the action to create a configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationActionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationActionRotateCRLPrototype', 'PrivateCertificateConfigurationActionRevokePrototype', 'PrivateCertificateConfigurationActionSignCSRPrototype', 'PrivateCertificateConfigurationActionSignIntermediatePrototype', 'PrivateCertificateConfigurationActionSetSignedPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationActionPrototype':
        """Initialize a ConfigurationActionPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationActionPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateConfigurationActionRotateCRLPrototype', 'PrivateCertificateConfigurationActionRevokePrototype', 'PrivateCertificateConfigurationActionSignCSRPrototype', 'PrivateCertificateConfigurationActionSignIntermediatePrototype', 'PrivateCertificateConfigurationActionSetSignedPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationActionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_configuration_action_rotate_crl'] = 'PrivateCertificateConfigurationActionRotateCRLPrototype'
        mapping['private_cert_configuration_action_revoke_ca_certificate'] = 'PrivateCertificateConfigurationActionRevokePrototype'
        mapping['private_cert_configuration_action_sign_csr'] = 'PrivateCertificateConfigurationActionSignCSRPrototype'
        mapping['private_cert_configuration_action_sign_intermediate'] = 'PrivateCertificateConfigurationActionSignIntermediatePrototype'
        mapping['private_cert_configuration_action_set_signed'] = 'PrivateCertificateConfigurationActionSetSignedPrototype'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in ConfigurationActionPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationMetadata:
    """
    Your configuration metadata properties.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationMetadata object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['IAMCredentialsConfigurationMetadata', 'PublicCertificateConfigurationCALetsEncryptMetadata', 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata', 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata', 'PrivateCertificateConfigurationRootCAMetadata', 'PrivateCertificateConfigurationIntermediateCAMetadata', 'PrivateCertificateConfigurationTemplateMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationMetadata':
        """Initialize a ConfigurationMetadata object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationMetadata'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['IAMCredentialsConfigurationMetadata', 'PublicCertificateConfigurationCALetsEncryptMetadata', 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata', 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata', 'PrivateCertificateConfigurationRootCAMetadata', 'PrivateCertificateConfigurationIntermediateCAMetadata', 'PrivateCertificateConfigurationTemplateMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['iam_credentials_configuration'] = 'IAMCredentialsConfigurationMetadata'
        mapping['public_cert_configuration_ca_lets_encrypt'] = 'PublicCertificateConfigurationCALetsEncryptMetadata'
        mapping['public_cert_configuration_dns_cloud_internet_services'] = 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata'
        mapping['public_cert_configuration_dns_classic_infrastructure'] = 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata'
        mapping['private_cert_configuration_root_ca'] = 'PrivateCertificateConfigurationRootCAMetadata'
        mapping['private_cert_configuration_intermediate_ca'] = 'PrivateCertificateConfigurationIntermediateCAMetadata'
        mapping['private_cert_configuration_template'] = 'PrivateCertificateConfigurationTemplateMetadata'
        disc_value = _dict.get('config_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'config_type\' not found in ConfigurationMetadata JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationMetadataPaginatedCollection:
    """
    Properties that describe a paginated collection of secret locks.

    :param int total_count: The total number of resources in a collection.
    :param int limit: The number of items that are retrieved in a collection.
    :param int offset: The number of items that are skipped in a collection.
    :param PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :param PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :param PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :param PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :param List[ConfigurationMetadata] configurations: A collection of configuration
          metadata.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        configurations: List['ConfigurationMetadata'],
        *,
        next: Optional['PaginatedCollectionNext'] = None,
        previous: Optional['PaginatedCollectionPrevious'] = None,
    ) -> None:
        """
        Initialize a ConfigurationMetadataPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[ConfigurationMetadata] configurations: A collection of
               configuration metadata.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.configurations = configurations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationMetadataPaginatedCollection':
        """Initialize a ConfigurationMetadataPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'configurations' in _dict:
            args['configurations'] = [ConfigurationMetadata.from_dict(v) for v in _dict.get('configurations')]
        else:
            raise ValueError('Required property \'configurations\' not present in ConfigurationMetadataPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ConfigurationMetadataPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'configurations') and self.configurations is not None:
            configurations_list = []
            for v in self.configurations:
                if isinstance(v, dict):
                    configurations_list.append(v)
                else:
                    configurations_list.append(v.to_dict())
            _dict['configurations'] = configurations_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ConfigurationMetadataPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ConfigurationMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ConfigurationMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ConfigurationPatch:
    """
    Your configuration update data.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationPatch object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['IAMCredentialsConfigurationPatch', 'PrivateCertificateConfigurationRootCAPatch', 'PrivateCertificateConfigurationIntermediateCAPatch', 'PrivateCertificateConfigurationTemplatePatch', 'PublicCertificateConfigurationCALetsEncryptPatch', 'PublicCertificateConfigurationDNSCloudInternetServicesPatch', 'PublicCertificateConfigurationDNSClassicInfrastructurePatch'])
        )
        raise Exception(msg)


class ConfigurationPrototype:
    """
    The details of your configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationRootCAPrototype', 'PrivateCertificateConfigurationIntermediateCAPrototype', 'PrivateCertificateConfigurationTemplatePrototype', 'PublicCertificateConfigurationCALetsEncryptPrototype', 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype', 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype', 'IAMCredentialsConfigurationPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationPrototype':
        """Initialize a ConfigurationPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateConfigurationRootCAPrototype', 'PrivateCertificateConfigurationIntermediateCAPrototype', 'PrivateCertificateConfigurationTemplatePrototype', 'PublicCertificateConfigurationCALetsEncryptPrototype', 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype', 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype', 'IAMCredentialsConfigurationPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_configuration_root_ca'] = 'PrivateCertificateConfigurationRootCAPrototype'
        mapping['private_cert_configuration_intermediate_ca'] = 'PrivateCertificateConfigurationIntermediateCAPrototype'
        mapping['private_cert_configuration_template'] = 'PrivateCertificateConfigurationTemplatePrototype'
        mapping['public_cert_configuration_ca_lets_encrypt'] = 'PublicCertificateConfigurationCALetsEncryptPrototype'
        mapping['public_cert_configuration_dns_cloud_internet_services'] = 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype'
        mapping['public_cert_configuration_dns_classic_infrastructure'] = 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype'
        mapping['iam_credentials_configuration'] = 'IAMCredentialsConfigurationPrototype'
        disc_value = _dict.get('config_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'config_type\' not found in ConfigurationPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class CosHmacKeys:
    """
    The Cloud Object Storage HMAC keys that are returned after you create a service
    credentials secret.

    :param str access_key_id: (optional) The access key ID for Cloud Object Storage
          HMAC credentials.
    :param str secret_access_key: (optional) The secret access key ID for Cloud
          Object Storage HMAC credentials.
    """

    def __init__(
        self,
        *,
        access_key_id: Optional[str] = None,
        secret_access_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a CosHmacKeys object.

        """
        self.access_key_id = access_key_id
        self.secret_access_key = secret_access_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CosHmacKeys':
        """Initialize a CosHmacKeys object from a json dictionary."""
        args = {}
        if 'access_key_id' in _dict:
            args['access_key_id'] = _dict.get('access_key_id')
        if 'secret_access_key' in _dict:
            args['secret_access_key'] = _dict.get('secret_access_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CosHmacKeys object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'access_key_id') and getattr(self, 'access_key_id') is not None:
            _dict['access_key_id'] = getattr(self, 'access_key_id')
        if hasattr(self, 'secret_access_key') and getattr(self, 'secret_access_key') is not None:
            _dict['secret_access_key'] = getattr(self, 'secret_access_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CosHmacKeys object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CosHmacKeys') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CosHmacKeys') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class NotificationsRegistration:
    """
    The details of the Event Notifications registration.

    :param str event_notifications_instance_crn: A CRN that uniquely identifies an
          IBM Cloud resource.
    """

    def __init__(
        self,
        event_notifications_instance_crn: str,
    ) -> None:
        """
        Initialize a NotificationsRegistration object.

        :param str event_notifications_instance_crn: A CRN that uniquely identifies
               an IBM Cloud resource.
        """
        self.event_notifications_instance_crn = event_notifications_instance_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'NotificationsRegistration':
        """Initialize a NotificationsRegistration object from a json dictionary."""
        args = {}
        if 'event_notifications_instance_crn' in _dict:
            args['event_notifications_instance_crn'] = _dict.get('event_notifications_instance_crn')
        else:
            raise ValueError('Required property \'event_notifications_instance_crn\' not present in NotificationsRegistration JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a NotificationsRegistration object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'event_notifications_instance_crn') and self.event_notifications_instance_crn is not None:
            _dict['event_notifications_instance_crn'] = self.event_notifications_instance_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this NotificationsRegistration object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'NotificationsRegistration') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'NotificationsRegistration') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionFirst:
    """
    A URL that points to the first page in a collection.

    :param str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionFirst object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionFirst':
        """Initialize a PaginatedCollectionFirst object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionFirst JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionFirst object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionFirst object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionFirst') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionFirst') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionLast:
    """
    A URL that points to the last page in a collection.

    :param str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionLast object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionLast':
        """Initialize a PaginatedCollectionLast object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionLast JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionLast object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionLast object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionLast') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionLast') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionNext:
    """
    A URL that points to the next page in a collection.

    :param str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionNext object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionNext':
        """Initialize a PaginatedCollectionNext object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionNext JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionNext object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionNext object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionNext') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionNext') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionPrevious:
    """
    A URL that points to the previous page in a collection.

    :param str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionPrevious object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionPrevious':
        """Initialize a PaginatedCollectionPrevious object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionPrevious JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionPrevious object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionPrevious object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionPrevious') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionPrevious') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateCAData:
    """
    The configuration data of your Private Certificate.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a PrivateCertificateCAData object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationIntermediateCACSR', 'PrivateCertificateConfigurationCACertificate'])
        )
        raise Exception(msg)


class PublicCertificateRotationObject:
    """
    Defines the rotation object that is used to manually rotate public certificates.

    :param bool rotate_keys: (optional) This field indicates whether Secrets Manager
          rotates the private key for your public certificate automatically.
          The default is `false`. If it is set to `true`, the service generates and stores
          a new private key for your rotated certificate.
    """

    def __init__(
        self,
        *,
        rotate_keys: Optional[bool] = None,
    ) -> None:
        """
        Initialize a PublicCertificateRotationObject object.

        :param bool rotate_keys: (optional) This field indicates whether Secrets
               Manager rotates the private key for your public certificate automatically.
               The default is `false`. If it is set to `true`, the service generates and
               stores a new private key for your rotated certificate.
        """
        self.rotate_keys = rotate_keys

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateRotationObject':
        """Initialize a PublicCertificateRotationObject object from a json dictionary."""
        args = {}
        if 'rotate_keys' in _dict:
            args['rotate_keys'] = _dict.get('rotate_keys')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateRotationObject object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'rotate_keys') and self.rotate_keys is not None:
            _dict['rotate_keys'] = self.rotate_keys
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateRotationObject object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateRotationObject') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateRotationObject') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class RotationPolicy:
    """
    This field indicates whether Secrets Manager rotates your secrets automatically.
    Supported secret types: username_password, private_cert, public_cert, iam_credentials.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a RotationPolicy object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['CommonRotationPolicy', 'PublicCertificateRotationPolicy'])
        )
        raise Exception(msg)


class Secret:
    """
    Your secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a Secret object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecret', 'IAMCredentialsSecret', 'ImportedCertificate', 'KVSecret', 'PrivateCertificate', 'PublicCertificate', 'ServiceCredentialsSecret', 'UsernamePasswordSecret'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Secret':
        """Initialize a Secret object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'Secret'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecret', 'IAMCredentialsSecret', 'ImportedCertificate', 'KVSecret', 'PrivateCertificate', 'PublicCertificate', 'ServiceCredentialsSecret', 'UsernamePasswordSecret'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a Secret object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecret'
        mapping['iam_credentials'] = 'IAMCredentialsSecret'
        mapping['imported_cert'] = 'ImportedCertificate'
        mapping['kv'] = 'KVSecret'
        mapping['private_cert'] = 'PrivateCertificate'
        mapping['public_cert'] = 'PublicCertificate'
        mapping['service_credentials'] = 'ServiceCredentialsSecret'
        mapping['username_password'] = 'UsernamePasswordSecret'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in Secret JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretAction:
    """
    The response body to specify the properties of the action to create a secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretAction object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PublicCertificateActionValidateManualDNS', 'PrivateCertificateActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretAction':
        """Initialize a SecretAction object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretAction'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PublicCertificateActionValidateManualDNS', 'PrivateCertificateActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretAction object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateActionRevoke'
        mapping['public_cert_action_validate_dns_challenge'] = 'PublicCertificateActionValidateManualDNS'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in SecretAction JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretActionPrototype:
    """
    The request body to specify the properties for your secret action.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretActionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateActionRevokePrototype', 'PublicCertificateActionValidateManualDNSPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretActionPrototype':
        """Initialize a SecretActionPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretActionPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateActionRevokePrototype', 'PublicCertificateActionValidateManualDNSPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretActionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['public_cert_action_validate_dns_challenge'] = 'PublicCertificateActionValidateManualDNSPrototype'
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateActionRevokePrototype'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in SecretActionPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretGroup:
    """
    Properties that describe a secret group.

    :param str id: A v4 UUID identifier, or `default` secret group.
    :param str name: (optional) The name of your existing secret group.
    :param str description: An extended description of your secret group.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        id: str,
        description: str,
        created_at: datetime,
        created_by: str,
        updated_at: datetime,
        *,
        name: Optional[str] = None,
    ) -> None:
        """
        Initialize a SecretGroup object.

        :param str id: A v4 UUID identifier, or `default` secret group.
        :param str description: An extended description of your secret group.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        self.id = id
        self.name = name
        self.description = description
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretGroup':
        """Initialize a SecretGroup object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in SecretGroup JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in SecretGroup JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in SecretGroup JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in SecretGroup JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in SecretGroup JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretGroup object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretGroup object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretGroup') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretGroup') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretGroupCollection:
    """
    Properties that describe a collection of secret groups.

    :param List[SecretGroup] secret_groups: A collection of secret groups.
    :param int total_count: The total number of resources in a collection.
    """

    def __init__(
        self,
        secret_groups: List['SecretGroup'],
        total_count: int,
    ) -> None:
        """
        Initialize a SecretGroupCollection object.

        :param List[SecretGroup] secret_groups: A collection of secret groups.
        :param int total_count: The total number of resources in a collection.
        """
        self.secret_groups = secret_groups
        self.total_count = total_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretGroupCollection':
        """Initialize a SecretGroupCollection object from a json dictionary."""
        args = {}
        if 'secret_groups' in _dict:
            args['secret_groups'] = [SecretGroup.from_dict(v) for v in _dict.get('secret_groups')]
        else:
            raise ValueError('Required property \'secret_groups\' not present in SecretGroupCollection JSON')
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretGroupCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretGroupCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_groups') and self.secret_groups is not None:
            secret_groups_list = []
            for v in self.secret_groups:
                if isinstance(v, dict):
                    secret_groups_list.append(v)
                else:
                    secret_groups_list.append(v.to_dict())
            _dict['secret_groups'] = secret_groups_list
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretGroupCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretGroupCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretGroupCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretGroupPatch:
    """
    Update the name or description of your secret group.

    :param str name: (optional) The name of your secret group.
    :param str description: (optional) An extended description of your secret group.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
    ) -> None:
        """
        Initialize a SecretGroupPatch object.

        :param str name: (optional) The name of your secret group.
        :param str description: (optional) An extended description of your secret
               group.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        """
        self.name = name
        self.description = description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretGroupPatch':
        """Initialize a SecretGroupPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretGroupPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretGroupPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretGroupPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretGroupPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretLock:
    """
    SecretLock.

    :param str name: A human-readable name to assign to the lock. The lock name must
          be unique per secret version.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret lock.
    :param str description: (optional) An extended description of the lock.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret lock.
    :param dict attributes: (optional) Optional information to associate with a
          lock, such as resources CRNs to be used by automation.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_id: A v4 UUID identifier.
    :param str secret_version_id: A v4 UUID identifier.
    :param str secret_version_alias: A human-readable alias that describes the
          secret version. 'Current' is used for version `n` and 'previous' is used for
          version `n-1`.
    """

    def __init__(
        self,
        name: str,
        created_at: datetime,
        updated_at: datetime,
        created_by: str,
        secret_group_id: str,
        secret_id: str,
        secret_version_id: str,
        secret_version_alias: str,
        *,
        description: Optional[str] = None,
        attributes: Optional[dict] = None,
    ) -> None:
        """
        Initialize a SecretLock object.

        :param str name: A human-readable name to assign to the lock. The lock name
               must be unique per secret version.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret lock.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_id: A v4 UUID identifier.
        :param str secret_version_id: A v4 UUID identifier.
        :param str secret_version_alias: A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param str description: (optional) An extended description of the lock.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret lock.
        :param dict attributes: (optional) Optional information to associate with a
               lock, such as resources CRNs to be used by automation.
        """
        self.name = name
        self.description = description
        self.attributes = attributes
        self.created_at = created_at
        self.updated_at = updated_at
        self.created_by = created_by
        self.secret_group_id = secret_group_id
        self.secret_id = secret_id
        self.secret_version_id = secret_version_id
        self.secret_version_alias = secret_version_alias

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLock':
        """Initialize a SecretLock object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in SecretLock JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'attributes' in _dict:
            args['attributes'] = _dict.get('attributes')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in SecretLock JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in SecretLock JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in SecretLock JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in SecretLock JSON')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in SecretLock JSON')
        if 'secret_version_id' in _dict:
            args['secret_version_id'] = _dict.get('secret_version_id')
        else:
            raise ValueError('Required property \'secret_version_id\' not present in SecretLock JSON')
        if 'secret_version_alias' in _dict:
            args['secret_version_alias'] = _dict.get('secret_version_alias')
        else:
            raise ValueError('Required property \'secret_version_alias\' not present in SecretLock JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLock object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'attributes') and self.attributes is not None:
            _dict['attributes'] = self.attributes
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'secret_version_id') and self.secret_version_id is not None:
            _dict['secret_version_id'] = self.secret_version_id
        if hasattr(self, 'secret_version_alias') and self.secret_version_alias is not None:
            _dict['secret_version_alias'] = self.secret_version_alias
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLock object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLock') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLock') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretVersionAliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class SecretLockPrototype:
    """
    SecretLockPrototype.

    :param str name: A human-readable name to assign to the lock. The lock name must
          be unique per secret version.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret lock.
    :param str description: (optional) An extended description of the lock.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret lock.
    :param dict attributes: (optional) Optional information to associate with a
          lock, such as resources CRNs to be used by automation.
    """

    def __init__(
        self,
        name: str,
        *,
        description: Optional[str] = None,
        attributes: Optional[dict] = None,
    ) -> None:
        """
        Initialize a SecretLockPrototype object.

        :param str name: A human-readable name to assign to the lock. The lock name
               must be unique per secret version.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret lock.
        :param str description: (optional) An extended description of the lock.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret lock.
        :param dict attributes: (optional) Optional information to associate with a
               lock, such as resources CRNs to be used by automation.
        """
        self.name = name
        self.description = description
        self.attributes = attributes

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLockPrototype':
        """Initialize a SecretLockPrototype object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in SecretLockPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'attributes' in _dict:
            args['attributes'] = _dict.get('attributes')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLockPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'attributes') and self.attributes is not None:
            _dict['attributes'] = self.attributes
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLockPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLockPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLockPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretLocks:
    """
    Create locks response body containing a collection of locks that are attached to a
    secret.

    :param str secret_id: A v4 UUID identifier.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: (optional) The secret type. Supported types are
          arbitrary, imported_cert, public_cert, private_cert, iam_credentials,
          service_credentials, kv, and username_password.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param List[SecretVersionLocks] versions: A collection of locks that are
          attached to a secret.
    """

    def __init__(
        self,
        secret_id: str,
        secret_group_id: str,
        versions: List['SecretVersionLocks'],
        *,
        secret_type: Optional[str] = None,
        secret_name: Optional[str] = None,
    ) -> None:
        """
        Initialize a SecretLocks object.

        :param str secret_id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param List[SecretVersionLocks] versions: A collection of locks that are
               attached to a secret.
        :param str secret_type: (optional) The secret type. Supported types are
               arbitrary, imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        """
        self.secret_id = secret_id
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.secret_name = secret_name
        self.versions = versions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLocks':
        """Initialize a SecretLocks object from a json dictionary."""
        args = {}
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in SecretLocks JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in SecretLocks JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'versions' in _dict:
            args['versions'] = [SecretVersionLocks.from_dict(v) for v in _dict.get('versions')]
        else:
            raise ValueError('Required property \'versions\' not present in SecretLocks JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLocks object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'versions') and self.versions is not None:
            versions_list = []
            for v in self.versions:
                if isinstance(v, dict):
                    versions_list.append(v)
                else:
                    versions_list.append(v.to_dict())
            _dict['versions'] = versions_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLocks object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLocks') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLocks') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class SecretLocksPaginatedCollection:
    """
    Properties that describe a paginated collection of your secret locks.

    :param int total_count: The total number of resources in a collection.
    :param int limit: The number of items that are retrieved in a collection.
    :param int offset: The number of items that are skipped in a collection.
    :param PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :param PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :param PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :param PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :param List[SecretLock] locks: A collection of secret locks.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        locks: List['SecretLock'],
        *,
        next: Optional['PaginatedCollectionNext'] = None,
        previous: Optional['PaginatedCollectionPrevious'] = None,
    ) -> None:
        """
        Initialize a SecretLocksPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretLock] locks: A collection of secret locks.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.locks = locks

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLocksPaginatedCollection':
        """Initialize a SecretLocksPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretLocksPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretLocksPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretLocksPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretLocksPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretLocksPaginatedCollection JSON')
        if 'locks' in _dict:
            args['locks'] = [SecretLock.from_dict(v) for v in _dict.get('locks')]
        else:
            raise ValueError('Required property \'locks\' not present in SecretLocksPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLocksPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'locks') and self.locks is not None:
            locks_list = []
            for v in self.locks:
                if isinstance(v, dict):
                    locks_list.append(v)
                else:
                    locks_list.append(v.to_dict())
            _dict['locks'] = locks_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLocksPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretMetadata:
    """
    Properties of your secret metadata.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretMetadata object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretMetadata', 'IAMCredentialsSecretMetadata', 'ImportedCertificateMetadata', 'KVSecretMetadata', 'PrivateCertificateMetadata', 'PublicCertificateMetadata', 'ServiceCredentialsSecretMetadata', 'UsernamePasswordSecretMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretMetadata':
        """Initialize a SecretMetadata object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretMetadata'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretMetadata', 'IAMCredentialsSecretMetadata', 'ImportedCertificateMetadata', 'KVSecretMetadata', 'PrivateCertificateMetadata', 'PublicCertificateMetadata', 'ServiceCredentialsSecretMetadata', 'UsernamePasswordSecretMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretMetadata'
        mapping['iam_credentials'] = 'IAMCredentialsSecretMetadata'
        mapping['imported_cert'] = 'ImportedCertificateMetadata'
        mapping['kv'] = 'KVSecretMetadata'
        mapping['private_cert'] = 'PrivateCertificateMetadata'
        mapping['public_cert'] = 'PublicCertificateMetadata'
        mapping['service_credentials'] = 'ServiceCredentialsSecretMetadata'
        mapping['username_password'] = 'UsernamePasswordSecretMetadata'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretMetadata JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretMetadataPaginatedCollection:
    """
    Properties that describe a paginated collection of your secret metadata.

    :param int total_count: The total number of resources in a collection.
    :param int limit: The number of items that are retrieved in a collection.
    :param int offset: The number of items that are skipped in a collection.
    :param PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :param PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :param PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :param PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :param List[SecretMetadata] secrets: A collection of secret metadata.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        secrets: List['SecretMetadata'],
        *,
        next: Optional['PaginatedCollectionNext'] = None,
        previous: Optional['PaginatedCollectionPrevious'] = None,
    ) -> None:
        """
        Initialize a SecretMetadataPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretMetadata] secrets: A collection of secret metadata.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.secrets = secrets

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretMetadataPaginatedCollection':
        """Initialize a SecretMetadataPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretMetadataPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretMetadataPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretMetadataPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretMetadataPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretMetadataPaginatedCollection JSON')
        if 'secrets' in _dict:
            args['secrets'] = [SecretMetadata.from_dict(v) for v in _dict.get('secrets')]
        else:
            raise ValueError('Required property \'secrets\' not present in SecretMetadataPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretMetadataPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'secrets') and self.secrets is not None:
            secrets_list = []
            for v in self.secrets:
                if isinstance(v, dict):
                    secrets_list.append(v)
                else:
                    secrets_list.append(v.to_dict())
            _dict['secrets'] = secrets_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretMetadataPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretMetadataPatch:
    """
    Update your secret metadata.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretMetadataPatch object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretMetadataPatch', 'IAMCredentialsSecretMetadataPatch', 'ImportedCertificateMetadataPatch', 'KVSecretMetadataPatch', 'PrivateCertificateMetadataPatch', 'PublicCertificateMetadataPatch', 'ServiceCredentialsSecretMetadataPatch', 'UsernamePasswordSecretMetadataPatch'])
        )
        raise Exception(msg)


class SecretPrototype:
    """
    Specify the properties for your secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretPrototype', 'IAMCredentialsSecretPrototype', 'ImportedCertificatePrototype', 'KVSecretPrototype', 'PrivateCertificatePrototype', 'PublicCertificatePrototype', 'ServiceCredentialsSecretPrototype', 'UsernamePasswordSecretPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretPrototype':
        """Initialize a SecretPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretPrototype', 'IAMCredentialsSecretPrototype', 'ImportedCertificatePrototype', 'KVSecretPrototype', 'PrivateCertificatePrototype', 'PublicCertificatePrototype', 'ServiceCredentialsSecretPrototype', 'UsernamePasswordSecretPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretPrototype'
        mapping['iam_credentials'] = 'IAMCredentialsSecretPrototype'
        mapping['imported_cert'] = 'ImportedCertificatePrototype'
        mapping['kv'] = 'KVSecretPrototype'
        mapping['private_cert'] = 'PrivateCertificatePrototype'
        mapping['public_cert'] = 'PublicCertificatePrototype'
        mapping['service_credentials'] = 'ServiceCredentialsSecretPrototype'
        mapping['username_password'] = 'UsernamePasswordSecretPrototype'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersion:
    """
    Your secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersion object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretVersion', 'IAMCredentialsSecretVersion', 'ImportedCertificateVersion', 'KVSecretVersion', 'PrivateCertificateVersion', 'PublicCertificateVersion', 'ServiceCredentialsSecretVersion', 'UsernamePasswordSecretVersion'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersion':
        """Initialize a SecretVersion object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretVersion'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretVersion', 'IAMCredentialsSecretVersion', 'ImportedCertificateVersion', 'KVSecretVersion', 'PrivateCertificateVersion', 'PublicCertificateVersion', 'ServiceCredentialsSecretVersion', 'UsernamePasswordSecretVersion'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretVersion'
        mapping['iam_credentials'] = 'IAMCredentialsSecretVersion'
        mapping['imported_cert'] = 'ImportedCertificateVersion'
        mapping['kv'] = 'KVSecretVersion'
        mapping['private_cert'] = 'PrivateCertificateVersion'
        mapping['public_cert'] = 'PublicCertificateVersion'
        mapping['service_credentials'] = 'ServiceCredentialsSecretVersion'
        mapping['username_password'] = 'UsernamePasswordSecretVersion'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretVersion JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersionActionPrototype:
    """
    The request body to specify the properties of the action to create a secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersionActionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateVersionActionRevokePrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionActionPrototype':
        """Initialize a SecretVersionActionPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretVersionActionPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateVersionActionRevokePrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretVersionActionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateVersionActionRevokePrototype'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in SecretVersionActionPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersionLocks:
    """
    SecretVersionLocks.

    :param str version_id: A v4 UUID identifier.
    :param str version_alias: A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param List[str] locks: The names of all locks that are associated with this
          secret version.
    :param bool payload_available: (optional) Indicates whether the secret payload
          is available in this secret version.
    """

    def __init__(
        self,
        version_id: str,
        version_alias: str,
        locks: List[str],
        *,
        payload_available: Optional[bool] = None,
    ) -> None:
        """
        Initialize a SecretVersionLocks object.

        :param str version_id: A v4 UUID identifier.
        :param str version_alias: A human-readable alias that describes the secret
               version. 'Current' is used for version `n` and 'previous' is used for
               version `n-1`.
        :param List[str] locks: The names of all locks that are associated with
               this secret version.
        :param bool payload_available: (optional) Indicates whether the secret
               payload is available in this secret version.
        """
        self.version_id = version_id
        self.version_alias = version_alias
        self.locks = locks
        self.payload_available = payload_available

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionLocks':
        """Initialize a SecretVersionLocks object from a json dictionary."""
        args = {}
        if 'version_id' in _dict:
            args['version_id'] = _dict.get('version_id')
        else:
            raise ValueError('Required property \'version_id\' not present in SecretVersionLocks JSON')
        if 'version_alias' in _dict:
            args['version_alias'] = _dict.get('version_alias')
        else:
            raise ValueError('Required property \'version_alias\' not present in SecretVersionLocks JSON')
        if 'locks' in _dict:
            args['locks'] = _dict.get('locks')
        else:
            raise ValueError('Required property \'locks\' not present in SecretVersionLocks JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionLocks object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'version_id') and self.version_id is not None:
            _dict['version_id'] = self.version_id
        if hasattr(self, 'version_alias') and self.version_alias is not None:
            _dict['version_alias'] = self.version_alias
        if hasattr(self, 'locks') and self.locks is not None:
            _dict['locks'] = self.locks
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionLocks object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionLocks') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionLocks') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class VersionAliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class SecretVersionLocksPaginatedCollection:
    """
    Properties that describe a paginated collection of your secret version locks.

    :param int total_count: The total number of resources in a collection.
    :param int limit: The number of items that are retrieved in a collection.
    :param int offset: The number of items that are skipped in a collection.
    :param PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :param PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :param PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :param PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :param List[SecretLock] locks: A collection of secret version locks.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        locks: List['SecretLock'],
        *,
        next: Optional['PaginatedCollectionNext'] = None,
        previous: Optional['PaginatedCollectionPrevious'] = None,
    ) -> None:
        """
        Initialize a SecretVersionLocksPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretLock] locks: A collection of secret version locks.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.locks = locks

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionLocksPaginatedCollection':
        """Initialize a SecretVersionLocksPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'locks' in _dict:
            args['locks'] = [SecretLock.from_dict(v) for v in _dict.get('locks')]
        else:
            raise ValueError('Required property \'locks\' not present in SecretVersionLocksPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionLocksPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'locks') and self.locks is not None:
            locks_list = []
            for v in self.locks:
                if isinstance(v, dict):
                    locks_list.append(v)
                else:
                    locks_list.append(v.to_dict())
            _dict['locks'] = locks_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionLocksPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretVersionMetadata:
    """
    Properties of the version metadata of your secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersionMetadata object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretVersionMetadata', 'IAMCredentialsSecretVersionMetadata', 'ImportedCertificateVersionMetadata', 'KVSecretVersionMetadata', 'PrivateCertificateVersionMetadata', 'PublicCertificateVersionMetadata', 'ServiceCredentialsSecretVersionMetadata', 'UsernamePasswordSecretVersionMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionMetadata':
        """Initialize a SecretVersionMetadata object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretVersionMetadata'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretVersionMetadata', 'IAMCredentialsSecretVersionMetadata', 'ImportedCertificateVersionMetadata', 'KVSecretVersionMetadata', 'PrivateCertificateVersionMetadata', 'PublicCertificateVersionMetadata', 'ServiceCredentialsSecretVersionMetadata', 'UsernamePasswordSecretVersionMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretVersionMetadata'
        mapping['iam_credentials'] = 'IAMCredentialsSecretVersionMetadata'
        mapping['imported_cert'] = 'ImportedCertificateVersionMetadata'
        mapping['kv'] = 'KVSecretVersionMetadata'
        mapping['private_cert'] = 'PrivateCertificateVersionMetadata'
        mapping['public_cert'] = 'PublicCertificateVersionMetadata'
        mapping['service_credentials'] = 'ServiceCredentialsSecretVersionMetadata'
        mapping['username_password'] = 'UsernamePasswordSecretVersionMetadata'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretVersionMetadata JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersionMetadataCollection:
    """
    Properties that describe a collection of your secret version metadata.

    :param List[SecretVersionMetadata] versions: A collection of secret version
          metadata.
    :param int total_count: The total number of resources in a collection.
    """

    def __init__(
        self,
        versions: List['SecretVersionMetadata'],
        total_count: int,
    ) -> None:
        """
        Initialize a SecretVersionMetadataCollection object.

        :param List[SecretVersionMetadata] versions: A collection of secret version
               metadata.
        :param int total_count: The total number of resources in a collection.
        """
        self.versions = versions
        self.total_count = total_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionMetadataCollection':
        """Initialize a SecretVersionMetadataCollection object from a json dictionary."""
        args = {}
        if 'versions' in _dict:
            args['versions'] = [SecretVersionMetadata.from_dict(v) for v in _dict.get('versions')]
        else:
            raise ValueError('Required property \'versions\' not present in SecretVersionMetadataCollection JSON')
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretVersionMetadataCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionMetadataCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'versions') and self.versions is not None:
            versions_list = []
            for v in self.versions:
                if isinstance(v, dict):
                    versions_list.append(v)
                else:
                    versions_list.append(v.to_dict())
            _dict['versions'] = versions_list
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionMetadataCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionMetadataCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionMetadataCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretVersionMetadataPatch:
    """
    Update your secret version metadata.

    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a SecretVersionMetadataPatch object.

        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionMetadataPatch':
        """Initialize a SecretVersionMetadataPatch object from a json dictionary."""
        args = {}
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretVersionPrototype:
    """
    Specify the properties for your new secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretVersionPrototype', 'IAMCredentialsSecretRestoreFromVersionPrototype', 'IAMCredentialsSecretVersionPrototype', 'ImportedCertificateVersionPrototype', 'KVSecretVersionPrototype', 'PrivateCertificateVersionPrototype', 'PublicCertificateVersionPrototype', 'ServiceCredentialsSecretVersionPrototype', 'UsernamePasswordSecretVersionPrototype'])
        )
        raise Exception(msg)


class SecretsLocksPaginatedCollection:
    """
    Properties that describe a paginated collection of your secrets locks.

    :param int total_count: The total number of resources in a collection.
    :param int limit: The number of items that are retrieved in a collection.
    :param int offset: The number of items that are skipped in a collection.
    :param PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :param PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :param PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :param PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :param List[SecretLocks] secrets_locks: A collection of secrets and their locks.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        secrets_locks: List['SecretLocks'],
        *,
        next: Optional['PaginatedCollectionNext'] = None,
        previous: Optional['PaginatedCollectionPrevious'] = None,
    ) -> None:
        """
        Initialize a SecretsLocksPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretLocks] secrets_locks: A collection of secrets and their
               locks.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.secrets_locks = secrets_locks

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretsLocksPaginatedCollection':
        """Initialize a SecretsLocksPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretsLocksPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretsLocksPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretsLocksPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretsLocksPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretsLocksPaginatedCollection JSON')
        if 'secrets_locks' in _dict:
            args['secrets_locks'] = [SecretLocks.from_dict(v) for v in _dict.get('secrets_locks')]
        else:
            raise ValueError('Required property \'secrets_locks\' not present in SecretsLocksPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretsLocksPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'secrets_locks') and self.secrets_locks is not None:
            secrets_locks_list = []
            for v in self.secrets_locks:
                if isinstance(v, dict):
                    secrets_locks_list.append(v)
                else:
                    secrets_locks_list.append(v.to_dict())
            _dict['secrets_locks'] = secrets_locks_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretsLocksPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretsLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretsLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsResourceKey:
    """
    The source service resource key data of the generated service credentials.

    :param str crn: (optional) The resource key CRN of the generated service
          credentials.
    :param str name: (optional) The resource key name of the generated service
          credentials.
    """

    def __init__(
        self,
        *,
        crn: Optional[str] = None,
        name: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsResourceKey object.

        """
        self.crn = crn
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsResourceKey':
        """Initialize a ServiceCredentialsResourceKey object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsResourceKey object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsResourceKey object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsResourceKey') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsResourceKey') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSecretCredentials:
    """
    The properties of the service credentials secret payload.

    :param str apikey: (optional) The API key that is generated for this secret.
          After the secret reaches the end of its lease, the API key is deleted
          automatically. See the `time-to-live` field to understand the duration of the
          lease.
    :param CosHmacKeys cos_hmac_keys: (optional) The Cloud Object Storage HMAC keys
          that are returned after you create a service credentials secret.
    :param str endpoints: (optional) The endpoints that are returned after you
          create a service credentials secret.
    :param str iam_apikey_description: (optional) The IAM API key description for
          the generated service credentials.
    :param str iam_apikey_id: (optional) The IAM API key id for the generated
          service credentials.
    :param str iam_apikey_name: (optional) The IAM API key name for the generated
          service credentials.
    :param str iam_role_crn: (optional) The IAM role CRN assigned to the generated
          service credentials.
    :param str iam_serviceid_crn: (optional) The IAM Service ID CRN.
    :param str resource_instance_id: (optional) The resource instance CRN that is
          returned after you create a service credentials secret.
    """

    def __init__(
        self,
        *,
        apikey: Optional[str] = None,
        cos_hmac_keys: Optional['CosHmacKeys'] = None,
        endpoints: Optional[str] = None,
        iam_apikey_description: Optional[str] = None,
        iam_apikey_id: Optional[str] = None,
        iam_apikey_name: Optional[str] = None,
        iam_role_crn: Optional[str] = None,
        iam_serviceid_crn: Optional[str] = None,
        resource_instance_id: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretCredentials object.

        :param CosHmacKeys cos_hmac_keys: (optional) The Cloud Object Storage HMAC
               keys that are returned after you create a service credentials secret.
        """
        self.apikey = apikey
        self.cos_hmac_keys = cos_hmac_keys
        self.endpoints = endpoints
        self.iam_apikey_description = iam_apikey_description
        self.iam_apikey_id = iam_apikey_id
        self.iam_apikey_name = iam_apikey_name
        self.iam_role_crn = iam_role_crn
        self.iam_serviceid_crn = iam_serviceid_crn
        self.resource_instance_id = resource_instance_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretCredentials':
        """Initialize a ServiceCredentialsSecretCredentials object from a json dictionary."""
        args = {}
        if 'apikey' in _dict:
            args['apikey'] = _dict.get('apikey')
        if 'cos_hmac_keys' in _dict:
            args['cos_hmac_keys'] = CosHmacKeys.from_dict(_dict.get('cos_hmac_keys'))
        if 'endpoints' in _dict:
            args['endpoints'] = _dict.get('endpoints')
        if 'iam_apikey_description' in _dict:
            args['iam_apikey_description'] = _dict.get('iam_apikey_description')
        if 'iam_apikey_id' in _dict:
            args['iam_apikey_id'] = _dict.get('iam_apikey_id')
        if 'iam_apikey_name' in _dict:
            args['iam_apikey_name'] = _dict.get('iam_apikey_name')
        if 'iam_role_crn' in _dict:
            args['iam_role_crn'] = _dict.get('iam_role_crn')
        if 'iam_serviceid_crn' in _dict:
            args['iam_serviceid_crn'] = _dict.get('iam_serviceid_crn')
        if 'resource_instance_id' in _dict:
            args['resource_instance_id'] = _dict.get('resource_instance_id')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretCredentials object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'apikey') and getattr(self, 'apikey') is not None:
            _dict['apikey'] = getattr(self, 'apikey')
        if hasattr(self, 'cos_hmac_keys') and self.cos_hmac_keys is not None:
            if isinstance(self.cos_hmac_keys, dict):
                _dict['cos_hmac_keys'] = self.cos_hmac_keys
            else:
                _dict['cos_hmac_keys'] = self.cos_hmac_keys.to_dict()
        if hasattr(self, 'endpoints') and getattr(self, 'endpoints') is not None:
            _dict['endpoints'] = getattr(self, 'endpoints')
        if hasattr(self, 'iam_apikey_description') and getattr(self, 'iam_apikey_description') is not None:
            _dict['iam_apikey_description'] = getattr(self, 'iam_apikey_description')
        if hasattr(self, 'iam_apikey_id') and getattr(self, 'iam_apikey_id') is not None:
            _dict['iam_apikey_id'] = getattr(self, 'iam_apikey_id')
        if hasattr(self, 'iam_apikey_name') and getattr(self, 'iam_apikey_name') is not None:
            _dict['iam_apikey_name'] = getattr(self, 'iam_apikey_name')
        if hasattr(self, 'iam_role_crn') and getattr(self, 'iam_role_crn') is not None:
            _dict['iam_role_crn'] = getattr(self, 'iam_role_crn')
        if hasattr(self, 'iam_serviceid_crn') and getattr(self, 'iam_serviceid_crn') is not None:
            _dict['iam_serviceid_crn'] = getattr(self, 'iam_serviceid_crn')
        if hasattr(self, 'resource_instance_id') and getattr(self, 'resource_instance_id') is not None:
            _dict['resource_instance_id'] = getattr(self, 'resource_instance_id')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretCredentials object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretCredentials') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretCredentials') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSecretSourceService:
    """
    The properties that are required to create the service credentials for the specified
    source service instance.

    :param ServiceCredentialsSourceServiceInstance instance: The source service
          instance identifier.
    :param ServiceCredentialsSourceServiceParameters parameters: (optional)
          Configuration options represented as key-value pairs. Service-defined options
          are used in the generation of credentials for some services. For example, Cloud
          Object Storage accepts the optional boolean parameter HMAC for creating specific
          kind of credentials.
    :param ServiceCredentialsSourceServiceRole role: (optional) The service-specific
          custom role. CRN is accepted. The role is assigned as part of an access policy
          to any auto-generated IAM service ID.  If you provide an existing service ID, it
          is added to the access policy for that ID.  If a role is not provided, any new
          service IDs that are autogenerated, will not have an assigned access policy and
          provided service IDs are not changed in any way.  Refer to the service
          documentation for supported roles.
    :param ServiceCredentialsSourceServiceIam iam: (optional) The source service IAM
          data is returned in case IAM credentials where created for this secret.
    :param ServiceCredentialsResourceKey resource_key: (optional) The source service
          resource key data of the generated service credentials.
    """

    def __init__(
        self,
        instance: 'ServiceCredentialsSourceServiceInstance',
        *,
        parameters: Optional['ServiceCredentialsSourceServiceParameters'] = None,
        role: Optional['ServiceCredentialsSourceServiceRole'] = None,
        iam: Optional['ServiceCredentialsSourceServiceIam'] = None,
        resource_key: Optional['ServiceCredentialsResourceKey'] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretSourceService object.

        :param ServiceCredentialsSourceServiceInstance instance: The source service
               instance identifier.
        :param ServiceCredentialsSourceServiceParameters parameters: (optional)
               Configuration options represented as key-value pairs. Service-defined
               options are used in the generation of credentials for some services. For
               example, Cloud Object Storage accepts the optional boolean parameter HMAC
               for creating specific kind of credentials.
        :param ServiceCredentialsSourceServiceRole role: (optional) The
               service-specific custom role. CRN is accepted. The role is assigned as part
               of an access policy to any auto-generated IAM service ID.  If you provide
               an existing service ID, it is added to the access policy for that ID.  If a
               role is not provided, any new service IDs that are autogenerated, will not
               have an assigned access policy and provided service IDs are not changed in
               any way.  Refer to the service documentation for supported roles.
        :param ServiceCredentialsSourceServiceIam iam: (optional) The source
               service IAM data is returned in case IAM credentials where created for this
               secret.
        :param ServiceCredentialsResourceKey resource_key: (optional) The source
               service resource key data of the generated service credentials.
        """
        self.instance = instance
        self.parameters = parameters
        self.role = role
        self.iam = iam
        self.resource_key = resource_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretSourceService':
        """Initialize a ServiceCredentialsSecretSourceService object from a json dictionary."""
        args = {}
        if 'instance' in _dict:
            args['instance'] = ServiceCredentialsSourceServiceInstance.from_dict(_dict.get('instance'))
        else:
            raise ValueError('Required property \'instance\' not present in ServiceCredentialsSecretSourceService JSON')
        if 'parameters' in _dict:
            args['parameters'] = ServiceCredentialsSourceServiceParameters.from_dict(_dict.get('parameters'))
        if 'role' in _dict:
            args['role'] = ServiceCredentialsSourceServiceRole.from_dict(_dict.get('role'))
        if 'iam' in _dict:
            args['iam'] = ServiceCredentialsSourceServiceIam.from_dict(_dict.get('iam'))
        if 'resource_key' in _dict:
            args['resource_key'] = ServiceCredentialsResourceKey.from_dict(_dict.get('resource_key'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretSourceService object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'instance') and self.instance is not None:
            if isinstance(self.instance, dict):
                _dict['instance'] = self.instance
            else:
                _dict['instance'] = self.instance.to_dict()
        if hasattr(self, 'parameters') and self.parameters is not None:
            if isinstance(self.parameters, dict):
                _dict['parameters'] = self.parameters
            else:
                _dict['parameters'] = self.parameters.to_dict()
        if hasattr(self, 'role') and self.role is not None:
            if isinstance(self.role, dict):
                _dict['role'] = self.role
            else:
                _dict['role'] = self.role.to_dict()
        if hasattr(self, 'iam') and self.iam is not None:
            if isinstance(self.iam, dict):
                _dict['iam'] = self.iam
            else:
                _dict['iam'] = self.iam.to_dict()
        if hasattr(self, 'resource_key') and self.resource_key is not None:
            if isinstance(self.resource_key, dict):
                _dict['resource_key'] = self.resource_key
            else:
                _dict['resource_key'] = self.resource_key.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretSourceService object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretSourceService') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretSourceService') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceIam:
    """
    The source service IAM data is returned in case IAM credentials where created for this
    secret.

    :param ServiceCredentialsSourceServiceIamApikey apikey: (optional) The IAM
          apikey metadata for the IAM credentials that were generated.
    :param ServiceCredentialsSourceServiceIamRole role: (optional) The IAM role for
          the generate service credentials.
    :param ServiceCredentialsSourceServiceIamServiceid serviceid: (optional) The IAM
          serviceid for the generated service credentials.
    """

    def __init__(
        self,
        *,
        apikey: Optional['ServiceCredentialsSourceServiceIamApikey'] = None,
        role: Optional['ServiceCredentialsSourceServiceIamRole'] = None,
        serviceid: Optional['ServiceCredentialsSourceServiceIamServiceid'] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceIam object.

        :param ServiceCredentialsSourceServiceIamApikey apikey: (optional) The IAM
               apikey metadata for the IAM credentials that were generated.
        :param ServiceCredentialsSourceServiceIamRole role: (optional) The IAM role
               for the generate service credentials.
        :param ServiceCredentialsSourceServiceIamServiceid serviceid: (optional)
               The IAM serviceid for the generated service credentials.
        """
        self.apikey = apikey
        self.role = role
        self.serviceid = serviceid

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceIam':
        """Initialize a ServiceCredentialsSourceServiceIam object from a json dictionary."""
        args = {}
        if 'apikey' in _dict:
            args['apikey'] = ServiceCredentialsSourceServiceIamApikey.from_dict(_dict.get('apikey'))
        if 'role' in _dict:
            args['role'] = ServiceCredentialsSourceServiceIamRole.from_dict(_dict.get('role'))
        if 'serviceid' in _dict:
            args['serviceid'] = ServiceCredentialsSourceServiceIamServiceid.from_dict(_dict.get('serviceid'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceIam object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'apikey') and self.apikey is not None:
            if isinstance(self.apikey, dict):
                _dict['apikey'] = self.apikey
            else:
                _dict['apikey'] = self.apikey.to_dict()
        if hasattr(self, 'role') and self.role is not None:
            if isinstance(self.role, dict):
                _dict['role'] = self.role
            else:
                _dict['role'] = self.role.to_dict()
        if hasattr(self, 'serviceid') and self.serviceid is not None:
            if isinstance(self.serviceid, dict):
                _dict['serviceid'] = self.serviceid
            else:
                _dict['serviceid'] = self.serviceid.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceIam object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceIam') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceIam') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceIamApikey:
    """
    The IAM apikey metadata for the IAM credentials that were generated.

    :param str description: (optional) The IAM API key description for the generated
          service credentials.
    :param str id: (optional) The IAM API key id for the generated service
          credentials.
    :param str name: (optional) The IAM API key name for the generated service
          credentials.
    """

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceIamApikey object.

        """
        self.description = description
        self.id = id
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceIamApikey':
        """Initialize a ServiceCredentialsSourceServiceIamApikey object from a json dictionary."""
        args = {}
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceIamApikey object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceIamApikey object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceIamApikey') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceIamApikey') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceIamRole:
    """
    The IAM role for the generate service credentials.

    :param str crn: (optional) The IAM role CRN assigned to the generated service
          credentials.
    """

    def __init__(
        self,
        *,
        crn: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceIamRole object.

        """
        self.crn = crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceIamRole':
        """Initialize a ServiceCredentialsSourceServiceIamRole object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceIamRole object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceIamRole object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceIamRole') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceIamRole') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceIamServiceid:
    """
    The IAM serviceid for the generated service credentials.

    :param str crn: (optional) The IAM Service ID CRN.
    """

    def __init__(
        self,
        *,
        crn: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceIamServiceid object.

        """
        self.crn = crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceIamServiceid':
        """Initialize a ServiceCredentialsSourceServiceIamServiceid object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceIamServiceid object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceIamServiceid object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceIamServiceid') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceIamServiceid') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceInstance:
    """
    The source service instance identifier.

    :param str crn: (optional) A CRN that uniquely identifies a service credentials
          source.
    """

    def __init__(
        self,
        *,
        crn: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceInstance object.

        :param str crn: (optional) A CRN that uniquely identifies a service
               credentials source.
        """
        self.crn = crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceInstance':
        """Initialize a ServiceCredentialsSourceServiceInstance object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceInstance object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceInstance object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceInstance') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceInstance') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceParameters:
    """
    Configuration options represented as key-value pairs. Service-defined options are used
    in the generation of credentials for some services. For example, Cloud Object Storage
    accepts the optional boolean parameter HMAC for creating specific kind of credentials.

    :param str serviceid_crn: (optional) An optional platform defined option to
          reuse an existing IAM Service ID for the role assignment.
    """

    # The set of defined properties for the class
    _properties = frozenset(['serviceid_crn'])

    def __init__(
        self,
        *,
        serviceid_crn: Optional[str] = None,
        **kwargs,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceParameters object.

        :param str serviceid_crn: (optional) An optional platform defined option to
               reuse an existing IAM Service ID for the role assignment.
        :param **kwargs: (optional) Any additional properties.
        """
        self.serviceid_crn = serviceid_crn
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceParameters':
        """Initialize a ServiceCredentialsSourceServiceParameters object from a json dictionary."""
        args = {}
        if 'serviceid_crn' in _dict:
            args['serviceid_crn'] = _dict.get('serviceid_crn')
        args.update({k: v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceParameters object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'serviceid_crn') and self.serviceid_crn is not None:
            _dict['serviceid_crn'] = self.serviceid_crn
        for _key in [k for k in vars(self).keys() if k not in ServiceCredentialsSourceServiceParameters._properties]:
            _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def get_properties(self) -> Dict:
        """Return a dictionary of arbitrary properties from this instance of ServiceCredentialsSourceServiceParameters"""
        _dict = {}

        for _key in [k for k in vars(self).keys() if k not in ServiceCredentialsSourceServiceParameters._properties]:
            _dict[_key] = getattr(self, _key)
        return _dict

    def set_properties(self, _dict: dict):
        """Set a dictionary of arbitrary properties to this instance of ServiceCredentialsSourceServiceParameters"""
        for _key in [k for k in vars(self).keys() if k not in ServiceCredentialsSourceServiceParameters._properties]:
            delattr(self, _key)

        for _key, _value in _dict.items():
            if _key not in ServiceCredentialsSourceServiceParameters._properties:
                setattr(self, _key, _value)

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceParameters object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceParameters') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceParameters') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSourceServiceRole:
    """
    The service-specific custom role. CRN is accepted. The role is assigned as part of an
    access policy to any auto-generated IAM service ID.  If you provide an existing
    service ID, it is added to the access policy for that ID.  If a role is not provided,
    any new service IDs that are autogenerated, will not have an assigned access policy
    and provided service IDs are not changed in any way.  Refer to the service
    documentation for supported roles.

    :param str crn: The service role CRN.
    """

    def __init__(
        self,
        crn: str,
    ) -> None:
        """
        Initialize a ServiceCredentialsSourceServiceRole object.

        :param str crn: The service role CRN.
        """
        self.crn = crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSourceServiceRole':
        """Initialize a ServiceCredentialsSourceServiceRole object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ServiceCredentialsSourceServiceRole JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSourceServiceRole object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSourceServiceRole object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSourceServiceRole') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSourceServiceRole') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class VersionAction:
    """
    The request body to specify the properties of the action to create a secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a VersionAction object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateVersionActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VersionAction':
        """Initialize a VersionAction object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'VersionAction'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateVersionActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a VersionAction object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateVersionActionRevoke'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in VersionAction JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ArbitrarySecret(Secret):
    """
    Your arbitrary secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str payload: (optional) The secret data that is assigned to an
          `arbitrary` secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        expiration_date: Optional[datetime] = None,
        payload: Optional[str] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str payload: (optional) The secret data that is assigned to an
               `arbitrary` secret.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.expiration_date = expiration_date
        self.payload = payload

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecret':
        """Initialize a ArbitrarySecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ArbitrarySecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ArbitrarySecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ArbitrarySecret JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ArbitrarySecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your arbitrary secret..

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        expiration_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretMetadata':
        """Initialize a ArbitrarySecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ArbitrarySecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ArbitrarySecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ArbitrarySecretMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ArbitrarySecretMetadataPatch(SecretMetadataPatch):
    """
    ArbitrarySecretMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretMetadataPatch':
        """Initialize a ArbitrarySecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ArbitrarySecretPrototype(SecretPrototype):
    """
    ArbitrarySecretPrototype.

    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str payload: The secret data that is assigned to an `arbitrary` secret.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        name: str,
        secret_type: str,
        payload: str,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        expiration_date: Optional[datetime] = None,
        labels: Optional[List[str]] = None,
        secret_group_id: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretPrototype object.

        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str payload: The secret data that is assigned to an `arbitrary`
               secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.description = description
        self.expiration_date = expiration_date
        self.labels = labels
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.payload = payload
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretPrototype':
        """Initialize a ArbitrarySecretPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in ArbitrarySecretPrototype JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretPrototype JSON')
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        else:
            raise ValueError('Required property \'payload\' not present in ArbitrarySecretPrototype JSON')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class ArbitrarySecretVersion(SecretVersion):
    """
    Your arbitrary secret version.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str payload: (optional) The secret data that is assigned to an
          `arbitrary` secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
        payload: Optional[str] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str payload: (optional) The secret data that is assigned to an
               `arbitrary` secret.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.payload = payload

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretVersion':
        """Initialize a ArbitrarySecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ArbitrarySecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ArbitrarySecretVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ArbitrarySecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your arbitrary secret.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretVersionMetadata':
        """Initialize a ArbitrarySecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ArbitrarySecretVersionPrototype(SecretVersionPrototype):
    """
    ArbitrarySecretVersionPrototype.

    :param str payload: The secret data that is assigned to an `arbitrary` secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        payload: str,
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretVersionPrototype object.

        :param str payload: The secret data that is assigned to an `arbitrary`
               secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.payload = payload
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretVersionPrototype':
        """Initialize a ArbitrarySecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        else:
            raise ValueError('Required property \'payload\' not present in ArbitrarySecretVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class CommonRotationPolicy(RotationPolicy):
    """
    This field indicates whether Secrets Manager rotates your secrets automatically.

    :param bool auto_rotate: This field indicates whether Secrets Manager rotates
          your secret automatically.
          The default is `false`. If `auto_rotate` is set to `true` the service rotates
          your secret based on the defined interval.
    :param int interval: (optional) The length of the secret rotation time interval.
    :param str unit: (optional) The units for the secret rotation time interval.
    """

    def __init__(
        self,
        auto_rotate: bool,
        *,
        interval: Optional[int] = None,
        unit: Optional[str] = None,
    ) -> None:
        """
        Initialize a CommonRotationPolicy object.

        :param bool auto_rotate: This field indicates whether Secrets Manager
               rotates your secret automatically.
               The default is `false`. If `auto_rotate` is set to `true` the service
               rotates your secret based on the defined interval.
        :param int interval: (optional) The length of the secret rotation time
               interval.
        :param str unit: (optional) The units for the secret rotation time
               interval.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotate = auto_rotate
        self.interval = interval
        self.unit = unit

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CommonRotationPolicy':
        """Initialize a CommonRotationPolicy object from a json dictionary."""
        args = {}
        if 'auto_rotate' in _dict:
            args['auto_rotate'] = _dict.get('auto_rotate')
        else:
            raise ValueError('Required property \'auto_rotate\' not present in CommonRotationPolicy JSON')
        if 'interval' in _dict:
            args['interval'] = _dict.get('interval')
        if 'unit' in _dict:
            args['unit'] = _dict.get('unit')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CommonRotationPolicy object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotate') and self.auto_rotate is not None:
            _dict['auto_rotate'] = self.auto_rotate
        if hasattr(self, 'interval') and self.interval is not None:
            _dict['interval'] = self.interval
        if hasattr(self, 'unit') and self.unit is not None:
            _dict['unit'] = self.unit
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CommonRotationPolicy object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CommonRotationPolicy') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CommonRotationPolicy') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class UnitEnum(str, Enum):
        """
        The units for the secret rotation time interval.
        """

        DAY = 'day'
        MONTH = 'month'



class IAMCredentialsConfiguration(Configuration):
    """
    Properties that describe a Classic Infrastructure DNS configuration.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str api_key: (optional) An IBM Cloud API key that can create and manage
          service IDs. The API key must be assigned the Editor platform role on the Access
          Groups Service and the Operator platform role on the IAM Identity Service.  For
          more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-configure-iam-engine).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        *,
        api_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsConfiguration object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfiguration':
        """Initialize a IAMCredentialsConfiguration object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in IAMCredentialsConfiguration JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsConfiguration JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsConfiguration JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsConfiguration JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsConfiguration JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsConfiguration JSON')
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfiguration object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'api_key') and getattr(self, 'api_key') is not None:
            _dict['api_key'] = getattr(self, 'api_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfiguration object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfiguration') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfiguration') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class IAMCredentialsConfigurationMetadata(ConfigurationMetadata):
    """
    Your IAMCredentials Configuration metadata properties.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
    ) -> None:
        """
        Initialize a IAMCredentialsConfigurationMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfigurationMetadata':
        """Initialize a IAMCredentialsConfigurationMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsConfigurationMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfigurationMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfigurationMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfigurationMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfigurationMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class IAMCredentialsConfigurationPatch(ConfigurationPatch):
    """
    The configuration update of the IAM Credentials engine.

    :param str api_key: An IBM Cloud API key that can create and manage service IDs.
          The API key must be assigned the Editor platform role on the Access Groups
          Service and the Operator platform role on the IAM Identity Service.  For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-configure-iam-engine).
    """

    def __init__(
        self,
        api_key: str,
    ) -> None:
        """
        Initialize a IAMCredentialsConfigurationPatch object.

        :param str api_key: An IBM Cloud API key that can create and manage service
               IDs. The API key must be assigned the Editor platform role on the Access
               Groups Service and the Operator platform role on the IAM Identity Service.
               For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-configure-iam-engine).
        """
        # pylint: disable=super-init-not-called
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfigurationPatch':
        """Initialize a IAMCredentialsConfigurationPatch object from a json dictionary."""
        args = {}
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        else:
            raise ValueError('Required property \'api_key\' not present in IAMCredentialsConfigurationPatch JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfigurationPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'api_key') and self.api_key is not None:
            _dict['api_key'] = self.api_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfigurationPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfigurationPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfigurationPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class IAMCredentialsConfigurationPrototype(ConfigurationPrototype):
    """
    IAMCredentialsConfigurationPrototype.

    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str api_key: The API key that is used to set the iam_credentials engine.
    """

    def __init__(
        self,
        name: str,
        config_type: str,
        api_key: str,
    ) -> None:
        """
        Initialize a IAMCredentialsConfigurationPrototype object.

        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str api_key: The API key that is used to set the iam_credentials
               engine.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.config_type = config_type
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfigurationPrototype':
        """Initialize a IAMCredentialsConfigurationPrototype object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsConfigurationPrototype JSON')
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in IAMCredentialsConfigurationPrototype JSON')
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        else:
            raise ValueError('Required property \'api_key\' not present in IAMCredentialsConfigurationPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfigurationPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'api_key') and self.api_key is not None:
            _dict['api_key'] = self.api_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfigurationPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfigurationPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfigurationPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'



class IAMCredentialsSecret(Secret):
    """
    Your IAM credentials secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str ttl: The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param List[str] access_groups: (optional) Access Groups that you can use for an
          `iam_credentials` secret.
          Up to 10 Access Groups can be used for each secret.
    :param str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :param str service_id: (optional) The service ID under which the API key (see
          the `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :param bool service_id_is_static: (optional) Indicates whether an
          `iam_credentials` secret was created with a static service ID.
          If it is set to `true`, the service ID for the secret was provided by the user
          at secret creation. If it is set to `false`, the service ID was generated by
          Secrets Manager.
    :param bool reuse_api_key: (IAM credentials) This parameter indicates whether to
          reuse the service ID and API key for future read operations.
          If it is set to `true`, the service reuses the current credentials. If it is set
          to `false`, a new service ID and API key are generated each time that the secret
          is read or accessed.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :param str api_key: (optional) The API key that is generated for this secret.
          After the secret reaches the end of its lease, the API key is deleted
          automatically. See the `time-to-live` field to understand the duration of the
          lease. If you want to continue to use the same API key for future read
          operations, see the `reuse_api_key` field.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        ttl: str,
        reuse_api_key: bool,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        access_groups: Optional[List[str]] = None,
        api_key_id: Optional[str] = None,
        service_id: Optional[str] = None,
        service_id_is_static: Optional[bool] = None,
        rotation: Optional['RotationPolicy'] = None,
        next_rotation_date: Optional[datetime] = None,
        api_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str ttl: The time-to-live (TTL) or lease duration to assign to
               credentials that are generated. Supported secret types: iam_credentials,
               service_credentials. The TTL defines how long generated credentials remain
               valid. The value can be either an integer that specifies the number of
               seconds, or the string  representation of a duration, such as `1440m` or
               `24h`. For the iam_credentials secret type, the TTL field is mandatory. The
               minimum duration is 1 minute. The maximum is 90 days. For the
               service_credentials secret type, the TTL field is optional. If it is set
               the minimum duration is 1 day. The maximum is 90 days. By default, the TTL
               is set to 0.
        :param bool reuse_api_key: (IAM credentials) This parameter indicates
               whether to reuse the service ID and API key for future read operations.
               If it is set to `true`, the service reuses the current credentials. If it
               is set to `false`, a new service ID and API key are generated each time
               that the secret is read or accessed.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] access_groups: (optional) Access Groups that you can use
               for an `iam_credentials` secret.
               Up to 10 Access Groups can be used for each secret.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.ttl = ttl
        self.access_groups = access_groups
        self.api_key_id = api_key_id
        self.service_id = service_id
        self.service_id_is_static = service_id_is_static
        self.reuse_api_key = reuse_api_key
        self.rotation = rotation
        self.next_rotation_date = next_rotation_date
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecret':
        """Initialize a IAMCredentialsSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in IAMCredentialsSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in IAMCredentialsSecret JSON')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        else:
            raise ValueError('Required property \'ttl\' not present in IAMCredentialsSecret JSON')
        if 'access_groups' in _dict:
            args['access_groups'] = _dict.get('access_groups')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'service_id_is_static' in _dict:
            args['service_id_is_static'] = _dict.get('service_id_is_static')
        if 'reuse_api_key' in _dict:
            args['reuse_api_key'] = _dict.get('reuse_api_key')
        else:
            raise ValueError('Required property \'reuse_api_key\' not present in IAMCredentialsSecret JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'access_groups') and self.access_groups is not None:
            _dict['access_groups'] = self.access_groups
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'service_id_is_static') and getattr(self, 'service_id_is_static') is not None:
            _dict['service_id_is_static'] = getattr(self, 'service_id_is_static')
        if hasattr(self, 'reuse_api_key') and self.reuse_api_key is not None:
            _dict['reuse_api_key'] = self.reuse_api_key
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'api_key') and getattr(self, 'api_key') is not None:
            _dict['api_key'] = getattr(self, 'api_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class IAMCredentialsSecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your IAM credentials secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str ttl: The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param List[str] access_groups: (optional) Access Groups that you can use for an
          `iam_credentials` secret.
          Up to 10 Access Groups can be used for each secret.
    :param str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :param str service_id: (optional) The service ID under which the API key (see
          the `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :param bool service_id_is_static: (optional) Indicates whether an
          `iam_credentials` secret was created with a static service ID.
          If it is set to `true`, the service ID for the secret was provided by the user
          at secret creation. If it is set to `false`, the service ID was generated by
          Secrets Manager.
    :param bool reuse_api_key: (IAM credentials) This parameter indicates whether to
          reuse the service ID and API key for future read operations.
          If it is set to `true`, the service reuses the current credentials. If it is set
          to `false`, a new service ID and API key are generated each time that the secret
          is read or accessed.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        ttl: str,
        reuse_api_key: bool,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        access_groups: Optional[List[str]] = None,
        api_key_id: Optional[str] = None,
        service_id: Optional[str] = None,
        service_id_is_static: Optional[bool] = None,
        rotation: Optional['RotationPolicy'] = None,
        next_rotation_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str ttl: The time-to-live (TTL) or lease duration to assign to
               credentials that are generated. Supported secret types: iam_credentials,
               service_credentials. The TTL defines how long generated credentials remain
               valid. The value can be either an integer that specifies the number of
               seconds, or the string  representation of a duration, such as `1440m` or
               `24h`. For the iam_credentials secret type, the TTL field is mandatory. The
               minimum duration is 1 minute. The maximum is 90 days. For the
               service_credentials secret type, the TTL field is optional. If it is set
               the minimum duration is 1 day. The maximum is 90 days. By default, the TTL
               is set to 0.
        :param bool reuse_api_key: (IAM credentials) This parameter indicates
               whether to reuse the service ID and API key for future read operations.
               If it is set to `true`, the service reuses the current credentials. If it
               is set to `false`, a new service ID and API key are generated each time
               that the secret is read or accessed.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] access_groups: (optional) Access Groups that you can use
               for an `iam_credentials` secret.
               Up to 10 Access Groups can be used for each secret.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.ttl = ttl
        self.access_groups = access_groups
        self.api_key_id = api_key_id
        self.service_id = service_id
        self.service_id_is_static = service_id_is_static
        self.reuse_api_key = reuse_api_key
        self.rotation = rotation
        self.next_rotation_date = next_rotation_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretMetadata':
        """Initialize a IAMCredentialsSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in IAMCredentialsSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in IAMCredentialsSecretMetadata JSON')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        else:
            raise ValueError('Required property \'ttl\' not present in IAMCredentialsSecretMetadata JSON')
        if 'access_groups' in _dict:
            args['access_groups'] = _dict.get('access_groups')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'service_id_is_static' in _dict:
            args['service_id_is_static'] = _dict.get('service_id_is_static')
        if 'reuse_api_key' in _dict:
            args['reuse_api_key'] = _dict.get('reuse_api_key')
        else:
            raise ValueError('Required property \'reuse_api_key\' not present in IAMCredentialsSecretMetadata JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'access_groups') and self.access_groups is not None:
            _dict['access_groups'] = self.access_groups
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'service_id_is_static') and getattr(self, 'service_id_is_static') is not None:
            _dict['service_id_is_static'] = getattr(self, 'service_id_is_static')
        if hasattr(self, 'reuse_api_key') and self.reuse_api_key is not None:
            _dict['reuse_api_key'] = self.reuse_api_key
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class IAMCredentialsSecretMetadataPatch(SecretMetadataPatch):
    """
    IAMCredentialsSecretMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str ttl: (optional) The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
        ttl: Optional[str] = None,
        rotation: Optional['RotationPolicy'] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str ttl: (optional) The time-to-live (TTL) or lease duration to
               assign to credentials that are generated. Supported secret types:
               iam_credentials, service_credentials. The TTL defines how long generated
               credentials remain valid. The value can be either an integer that specifies
               the number of seconds, or the string  representation of a duration, such as
               `1440m` or `24h`. For the iam_credentials secret type, the TTL field is
               mandatory. The minimum duration is 1 minute. The maximum is 90 days. For
               the service_credentials secret type, the TTL field is optional. If it is
               set the minimum duration is 1 day. The maximum is 90 days. By default, the
               TTL is set to 0.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.ttl = ttl
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretMetadataPatch':
        """Initialize a IAMCredentialsSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class IAMCredentialsSecretPrototype(SecretPrototype):
    """
    IAMCredentialsSecretPrototype.

    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str ttl: The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param List[str] access_groups: (optional) Access Groups that you can use for an
          `iam_credentials` secret.
          Up to 10 Access Groups can be used for each secret.
    :param str service_id: (optional) The service ID under which the API key (see
          the `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :param bool reuse_api_key: (IAM credentials) This parameter indicates whether to
          reuse the service ID and API key for future read operations.
          If it is set to `true`, the service reuses the current credentials. If it is set
          to `false`, a new service ID and API key are generated each time that the secret
          is read or accessed.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        ttl: str,
        reuse_api_key: bool,
        *,
        description: Optional[str] = None,
        secret_group_id: Optional[str] = None,
        labels: Optional[List[str]] = None,
        access_groups: Optional[List[str]] = None,
        service_id: Optional[str] = None,
        rotation: Optional['RotationPolicy'] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretPrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str ttl: The time-to-live (TTL) or lease duration to assign to
               credentials that are generated. Supported secret types: iam_credentials,
               service_credentials. The TTL defines how long generated credentials remain
               valid. The value can be either an integer that specifies the number of
               seconds, or the string  representation of a duration, such as `1440m` or
               `24h`. For the iam_credentials secret type, the TTL field is mandatory. The
               minimum duration is 1 minute. The maximum is 90 days. For the
               service_credentials secret type, the TTL field is optional. If it is set
               the minimum duration is 1 day. The maximum is 90 days. By default, the TTL
               is set to 0.
        :param bool reuse_api_key: (IAM credentials) This parameter indicates
               whether to reuse the service ID and API key for future read operations.
               If it is set to `true`, the service reuses the current credentials. If it
               is set to `false`, a new service ID and API key are generated each time
               that the secret is read or accessed.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] access_groups: (optional) Access Groups that you can use
               for an `iam_credentials` secret.
               Up to 10 Access Groups can be used for each secret.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.ttl = ttl
        self.access_groups = access_groups
        self.service_id = service_id
        self.reuse_api_key = reuse_api_key
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretPrototype':
        """Initialize a IAMCredentialsSecretPrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsSecretPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        else:
            raise ValueError('Required property \'ttl\' not present in IAMCredentialsSecretPrototype JSON')
        if 'access_groups' in _dict:
            args['access_groups'] = _dict.get('access_groups')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'reuse_api_key' in _dict:
            args['reuse_api_key'] = _dict.get('reuse_api_key')
        else:
            raise ValueError('Required property \'reuse_api_key\' not present in IAMCredentialsSecretPrototype JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'access_groups') and self.access_groups is not None:
            _dict['access_groups'] = self.access_groups
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'reuse_api_key') and self.reuse_api_key is not None:
            _dict['reuse_api_key'] = self.reuse_api_key
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class IAMCredentialsSecretRestoreFromVersionPrototype(SecretVersionPrototype):
    """
    IAMCredentialsSecretRestoreFromVersionPrototype.

    :param str restore_from_version: A v4 UUID identifier, or `current` or
          `previous` secret version aliases.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        restore_from_version: str,
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretRestoreFromVersionPrototype object.

        :param str restore_from_version: A v4 UUID identifier, or `current` or
               `previous` secret version aliases.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.restore_from_version = restore_from_version
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretRestoreFromVersionPrototype':
        """Initialize a IAMCredentialsSecretRestoreFromVersionPrototype object from a json dictionary."""
        args = {}
        if 'restore_from_version' in _dict:
            args['restore_from_version'] = _dict.get('restore_from_version')
        else:
            raise ValueError('Required property \'restore_from_version\' not present in IAMCredentialsSecretRestoreFromVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretRestoreFromVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'restore_from_version') and self.restore_from_version is not None:
            _dict['restore_from_version'] = self.restore_from_version
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretRestoreFromVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretRestoreFromVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretRestoreFromVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class IAMCredentialsSecretVersion(SecretVersion):
    """
    Your IAM credentials version.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :param str service_id: (optional) The service ID under which the API key (see
          the `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :param str api_key: (optional) The API key that is generated for this secret.
          After the secret reaches the end of its lease, the API key is deleted
          automatically. See the `time-to-live` field to understand the duration of the
          lease. If you want to continue to use the same API key for future read
          operations, see the `reuse_api_key` field.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        api_key_id: Optional[str] = None,
        service_id: Optional[str] = None,
        api_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.api_key_id = api_key_id
        self.service_id = service_id
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretVersion':
        """Initialize a IAMCredentialsSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in IAMCredentialsSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in IAMCredentialsSecretVersion JSON')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'api_key') and getattr(self, 'api_key') is not None:
            _dict['api_key'] = getattr(self, 'api_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class IAMCredentialsSecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your IAM credentials secret.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :param str service_id: (optional) The service ID under which the API key (see
          the `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        api_key_id: Optional[str] = None,
        service_id: Optional[str] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.api_key_id = api_key_id
        self.service_id = service_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretVersionMetadata':
        """Initialize a IAMCredentialsSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class IAMCredentialsSecretVersionPrototype(SecretVersionPrototype):
    """
    IAMCredentialsSecretVersionPrototype.

    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretVersionPrototype object.

        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretVersionPrototype':
        """Initialize a IAMCredentialsSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ImportedCertificate(Secret):
    """
    Your imported certificate.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str signing_algorithm: The identifier for the cryptographic algorithm
          that is used by the issuing certificate authority to sign a certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str common_name: (optional) The Common Name (CN) represents the server
          name protected by the SSL certificate.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param bool intermediate_included: Indicates whether the certificate was
          imported with an associated intermediate certificate.
    :param str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :param str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :param bool private_key_included: Indicates whether the certificate was imported
          with an associated private key.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str intermediate: (optional) The PEM-encoded intermediate certificate
          that is associated with the root certificate. The data must be formatted on a
          single line with embedded newline characters.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        expiration_date: datetime,
        intermediate_included: bool,
        issuer: str,
        private_key_included: bool,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        common_name: Optional[str] = None,
        key_algorithm: Optional[str] = None,
        intermediate: Optional[str] = None,
        private_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a ImportedCertificate object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param bool intermediate_included: Indicates whether the certificate was
               imported with an associated intermediate certificate.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param bool private_key_included: Indicates whether the certificate was
               imported with an associated private key.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name protected by the SSL certificate.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.intermediate_included = intermediate_included
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.private_key_included = private_key_included
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificate':
        """Initialize a ImportedCertificate object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificate JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ImportedCertificate JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificate JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificate JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ImportedCertificate JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ImportedCertificate JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in ImportedCertificate JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificate JSON')
        if 'intermediate_included' in _dict:
            args['intermediate_included'] = _dict.get('intermediate_included')
        else:
            raise ValueError('Required property \'intermediate_included\' not present in ImportedCertificate JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in ImportedCertificate JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'private_key_included' in _dict:
            args['private_key_included'] = _dict.get('private_key_included')
        else:
            raise ValueError('Required property \'private_key_included\' not present in ImportedCertificate JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificate JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificate JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificate JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'intermediate_included') and self.intermediate_included is not None:
            _dict['intermediate_included'] = self.intermediate_included
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'private_key_included') and self.private_key_included is not None:
            _dict['private_key_included'] = self.private_key_included
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ImportedCertificateMetadata(SecretMetadata):
    """
    Properties of the secret metadata of your imported certificate.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str signing_algorithm: The identifier for the cryptographic algorithm
          that is used by the issuing certificate authority to sign a certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str common_name: (optional) The Common Name (CN) represents the server
          name protected by the SSL certificate.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param bool intermediate_included: Indicates whether the certificate was
          imported with an associated intermediate certificate.
    :param str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :param str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :param bool private_key_included: Indicates whether the certificate was imported
          with an associated private key.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        expiration_date: datetime,
        intermediate_included: bool,
        issuer: str,
        private_key_included: bool,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        common_name: Optional[str] = None,
        key_algorithm: Optional[str] = None,
    ) -> None:
        """
        Initialize a ImportedCertificateMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param bool intermediate_included: Indicates whether the certificate was
               imported with an associated intermediate certificate.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param bool private_key_included: Indicates whether the certificate was
               imported with an associated private key.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name protected by the SSL certificate.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.intermediate_included = intermediate_included
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.private_key_included = private_key_included
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateMetadata':
        """Initialize a ImportedCertificateMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificateMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ImportedCertificateMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificateMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificateMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ImportedCertificateMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ImportedCertificateMetadata JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in ImportedCertificateMetadata JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificateMetadata JSON')
        if 'intermediate_included' in _dict:
            args['intermediate_included'] = _dict.get('intermediate_included')
        else:
            raise ValueError('Required property \'intermediate_included\' not present in ImportedCertificateMetadata JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in ImportedCertificateMetadata JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'private_key_included' in _dict:
            args['private_key_included'] = _dict.get('private_key_included')
        else:
            raise ValueError('Required property \'private_key_included\' not present in ImportedCertificateMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificateMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificateMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'intermediate_included') and self.intermediate_included is not None:
            _dict['intermediate_included'] = self.intermediate_included
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'private_key_included') and self.private_key_included is not None:
            _dict['private_key_included'] = self.private_key_included
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ImportedCertificateMetadataPatch(SecretMetadataPatch):
    """
    ImportedCertificateMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ImportedCertificateMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateMetadataPatch':
        """Initialize a ImportedCertificateMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ImportedCertificatePrototype(SecretPrototype):
    """
    ImportedCertificatePrototype.

    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str intermediate: (optional) The PEM-encoded intermediate certificate
          that is associated with the root certificate. The data must be formatted on a
          single line with embedded newline characters.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        certificate: str,
        *,
        description: Optional[str] = None,
        secret_group_id: Optional[str] = None,
        labels: Optional[List[str]] = None,
        intermediate: Optional[str] = None,
        private_key: Optional[str] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ImportedCertificatePrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificatePrototype':
        """Initialize a ImportedCertificatePrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in ImportedCertificatePrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificatePrototype JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class ImportedCertificateVersion(SecretVersion):
    """
    Versions of your imported certificate.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str intermediate: (optional) The PEM-encoded intermediate certificate
          that is associated with the root certificate. The data must be formatted on a
          single line with embedded newline characters.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        intermediate: Optional[str] = None,
        private_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a ImportedCertificateVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateVersion':
        """Initialize a ImportedCertificateVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificateVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificateVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificateVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificateVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificateVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ImportedCertificateVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ImportedCertificateVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificateVersion JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificateVersion JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificateVersion JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificateVersion JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ImportedCertificateVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your imported certificate.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ImportedCertificateVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateVersionMetadata':
        """Initialize a ImportedCertificateVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificateVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificateVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificateVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificateVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificateVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ImportedCertificateVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ImportedCertificateVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificateVersionMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificateVersionMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificateVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ImportedCertificateVersionPrototype(SecretVersionPrototype):
    """
    ImportedCertificateVersionPrototype.

    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str intermediate: (optional) The PEM-encoded intermediate certificate
          that is associated with the root certificate. The data must be formatted on a
          single line with embedded newline characters.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        certificate: str,
        *,
        intermediate: Optional[str] = None,
        private_key: Optional[str] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ImportedCertificateVersionPrototype object.

        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateVersionPrototype':
        """Initialize a ImportedCertificateVersionPrototype object from a json dictionary."""
        args = {}
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificateVersionPrototype JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KVSecret(Secret):
    """
    Your key-value secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param dict data: The payload data of a key-value secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        data: dict,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
    ) -> None:
        """
        Initialize a KVSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict data: The payload data of a key-value secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecret':
        """Initialize a KVSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in KVSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in KVSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in KVSecret JSON')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecret JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class KVSecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your key-value secret metadata.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
    ) -> None:
        """
        Initialize a KVSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretMetadata':
        """Initialize a KVSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in KVSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in KVSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in KVSecretMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class KVSecretMetadataPatch(SecretMetadataPatch):
    """
    KVSecretMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a KVSecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretMetadataPatch':
        """Initialize a KVSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KVSecretPrototype(SecretPrototype):
    """
    KVSecretPrototype.

    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict data: The payload data of a key-value secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        data: dict,
        *,
        description: Optional[str] = None,
        secret_group_id: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a KVSecretPrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param dict data: The payload data of a key-value secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.data = data
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretPrototype':
        """Initialize a KVSecretPrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in KVSecretPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecretPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class KVSecretVersion(SecretVersion):
    """
    Your key-value secret version.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param dict data: The payload data of a key-value secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        data: dict,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a KVSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param dict data: The payload data of a key-value secret.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretVersion':
        """Initialize a KVSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in KVSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in KVSecretVersion JSON')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecretVersion JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class KVSecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your key-value secret.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a KVSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretVersionMetadata':
        """Initialize a KVSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in KVSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in KVSecretVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class KVSecretVersionPrototype(SecretVersionPrototype):
    """
    KVSecretVersionPrototype.

    :param dict data: The payload data of a key-value secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        data: dict,
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a KVSecretVersionPrototype object.

        :param dict data: The payload data of a key-value secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.data = data
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretVersionPrototype':
        """Initialize a KVSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecretVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificate(Secret):
    """
    Your private certificate.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str signing_algorithm: The identifier for the cryptographic algorithm
          that is used by the issuing certificate authority to sign a certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str certificate_authority: (optional) The intermediate certificate
          authority that signed this certificate.
    :param str certificate_template: The name of the certificate template.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :param str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :param int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    :param datetime revocation_time_rfc3339: (optional) The date and time that the
          certificate was revoked. The date format follows `RFC 3339`.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str private_key: The PEM-encoded private key that is associated with the
          certificate. The data must be formatted on a single line with embedded newline
          characters.
    :param str issuing_ca: (optional) The PEM-encoded certificate of the certificate
          authority that signed and issued this certificate.
    :param List[str] ca_chain: (optional) The chain of certificate authorities that
          are associated with the certificate.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        certificate_template: str,
        common_name: str,
        expiration_date: datetime,
        issuer: str,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        private_key: str,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        certificate_authority: Optional[str] = None,
        key_algorithm: Optional[str] = None,
        next_rotation_date: Optional[datetime] = None,
        rotation: Optional['RotationPolicy'] = None,
        revocation_time_seconds: Optional[int] = None,
        revocation_time_rfc3339: Optional[datetime] = None,
        issuing_ca: Optional[str] = None,
        ca_chain: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a PrivateCertificate object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param str certificate_template: The name of the certificate template.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: The PEM-encoded private key that is associated with
               the certificate. The data must be formatted on a single line with embedded
               newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.certificate_authority = certificate_authority
        self.certificate_template = certificate_template
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.next_rotation_date = next_rotation_date
        self.rotation = rotation
        self.serial_number = serial_number
        self.validity = validity
        self.revocation_time_seconds = revocation_time_seconds
        self.revocation_time_rfc3339 = revocation_time_rfc3339
        self.certificate = certificate
        self.private_key = private_key
        self.issuing_ca = issuing_ca
        self.ca_chain = ca_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificate':
        """Initialize a PrivateCertificate object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificate JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PrivateCertificate JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificate JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificate JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificate JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PrivateCertificate JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in PrivateCertificate JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        if 'certificate_template' in _dict:
            args['certificate_template'] = _dict.get('certificate_template')
        else:
            raise ValueError('Required property \'certificate_template\' not present in PrivateCertificate JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificate JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificate JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in PrivateCertificate JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificate JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificate JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        if 'revocation_time_rfc3339' in _dict:
            args['revocation_time_rfc3339'] = string_to_datetime(_dict.get('revocation_time_rfc3339'))
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificate JSON')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        else:
            raise ValueError('Required property \'private_key\' not present in PrivateCertificate JSON')
        if 'issuing_ca' in _dict:
            args['issuing_ca'] = _dict.get('issuing_ca')
        if 'ca_chain' in _dict:
            args['ca_chain'] = _dict.get('ca_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'certificate_authority') and getattr(self, 'certificate_authority') is not None:
            _dict['certificate_authority'] = getattr(self, 'certificate_authority')
        if hasattr(self, 'certificate_template') and self.certificate_template is not None:
            _dict['certificate_template'] = self.certificate_template
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        if hasattr(self, 'revocation_time_rfc3339') and getattr(self, 'revocation_time_rfc3339') is not None:
            _dict['revocation_time_rfc3339'] = datetime_to_string(getattr(self, 'revocation_time_rfc3339'))
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'issuing_ca') and getattr(self, 'issuing_ca') is not None:
            _dict['issuing_ca'] = getattr(self, 'issuing_ca')
        if hasattr(self, 'ca_chain') and getattr(self, 'ca_chain') is not None:
            _dict['ca_chain'] = getattr(self, 'ca_chain')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PrivateCertificateActionRevoke(SecretAction):
    """
    The response body of the action to revoke the private certificate.

    :param str action_type: The type of secret action.
    :param int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    """

    def __init__(
        self,
        action_type: str,
        *,
        revocation_time_seconds: Optional[int] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateActionRevoke object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.revocation_time_seconds = revocation_time_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateActionRevoke':
        """Initialize a PrivateCertificateActionRevoke object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateActionRevoke JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateActionRevoke object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateActionRevoke object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateActionRevoke') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateActionRevoke') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateActionRevokePrototype(SecretActionPrototype):
    """
    The request body to specify the properties of the action to revoke the private
    certificate.

    :param str action_type: The type of secret action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateActionRevokePrototype object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateActionRevokePrototype':
        """Initialize a PrivateCertificateActionRevokePrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateActionRevokePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateActionRevokePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateActionRevokePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateActionRevokePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateActionRevokePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateConfigurationActionRevoke(ConfigurationAction):
    """
    The response body to specify the properties of the action to revoke the private
    certificate.

    :param str action_type: The type of configuration action.
    :param int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    """

    def __init__(
        self,
        action_type: str,
        *,
        revocation_time_seconds: Optional[int] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRevoke object.

        :param str action_type: The type of configuration action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.revocation_time_seconds = revocation_time_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRevoke':
        """Initialize a PrivateCertificateConfigurationActionRevoke object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRevoke JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRevoke object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRevoke object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRevoke') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRevoke') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionRevokePrototype(ConfigurationActionPrototype):
    """
    The request body to specify the properties of the action to revoke the private
    certificate configuration.

    :param str action_type: The type of configuration action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRevokePrototype object.

        :param str action_type: The type of configuration action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRevokePrototype':
        """Initialize a PrivateCertificateConfigurationActionRevokePrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRevokePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRevokePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRevokePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRevokePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRevokePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionRotateCRL(ConfigurationAction):
    """
    The response body of the action to rotate the CRL of an intermediate certificate
    authority for the private certificate configuration.

    :param str action_type: The type of configuration action.
    :param bool success: This field indicates whether the request to rotate the CRL
          for the private certificate configuration was successful.
    """

    def __init__(
        self,
        action_type: str,
        success: bool,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRotateCRL object.

        :param str action_type: The type of configuration action.
        :param bool success: This field indicates whether the request to rotate the
               CRL for the private certificate configuration was successful.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.success = success

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRotateCRL':
        """Initialize a PrivateCertificateConfigurationActionRotateCRL object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRotateCRL JSON')
        if 'success' in _dict:
            args['success'] = _dict.get('success')
        else:
            raise ValueError('Required property \'success\' not present in PrivateCertificateConfigurationActionRotateCRL JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRotateCRL object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'success') and self.success is not None:
            _dict['success'] = self.success
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRotateCRL object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRotateCRL') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRotateCRL') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionRotateCRLPrototype(ConfigurationActionPrototype):
    """
    The request body of the action to rotate the CRL of an intermediate certificate
    authority for the private certificate configuration.

    :param str action_type: The type of configuration action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRotateCRLPrototype object.

        :param str action_type: The type of configuration action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRotateCRLPrototype':
        """Initialize a PrivateCertificateConfigurationActionRotateCRLPrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRotateCRLPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRotateCRLPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRotateCRLPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRotateCRLPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRotateCRLPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSetSigned(ConfigurationAction):
    """
    The response body of the action to set a signed intermediate certificate authority for
    the private certificate configuration.

    :param str action_type: The type of configuration action.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    """

    def __init__(
        self,
        action_type: str,
        certificate: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSetSigned object.

        :param str action_type: The type of configuration action.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.certificate = certificate

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSetSigned':
        """Initialize a PrivateCertificateConfigurationActionSetSigned object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSetSigned JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateConfigurationActionSetSigned JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSetSigned object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSetSigned object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSetSigned') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSetSigned') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSetSignedPrototype(ConfigurationActionPrototype):
    """
    The request body of the action to set a signed intermediate certificate authority for
    the private certificate consideration.

    :param str action_type: The type of configuration action.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    """

    def __init__(
        self,
        action_type: str,
        certificate: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSetSignedPrototype object.

        :param str action_type: The type of configuration action.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.certificate = certificate

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSetSignedPrototype':
        """Initialize a PrivateCertificateConfigurationActionSetSignedPrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSetSignedPrototype JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateConfigurationActionSetSignedPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSetSignedPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSetSignedPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSetSignedPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSetSignedPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignCSR(ConfigurationAction):
    """
    The response body of the action to sign the CSR for the private certificate
    configuration.

    :param str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :param str format: (optional) The format of the returned data.
    :param int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :param bool use_csr_values: (optional) This field indicates whether to use
          values from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :param str action_type: The type of configuration action.
    :param str csr: The certificate signing request.
    :param PrivateCertificateConfigurationCACertificate data: (optional) The data
          that is associated with the root certificate authority.
    """

    def __init__(
        self,
        action_type: str,
        csr: str,
        *,
        common_name: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        ttl: Optional[str] = None,
        format: Optional[str] = None,
        max_path_length: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        permitted_dns_domains: Optional[List[str]] = None,
        use_csr_values: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
        data: Optional['PrivateCertificateConfigurationCACertificate'] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignCSR object.

        :param str action_type: The type of configuration action.
        :param str csr: The certificate signing request.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.csr = csr
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignCSR':
        """Initialize a PrivateCertificateConfigurationActionSignCSR object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignCSR JSON')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        else:
            raise ValueError('Required property \'csr\' not present in PrivateCertificateConfigurationActionSignCSR JSON')
        if 'data' in _dict:
            args['data'] = PrivateCertificateConfigurationCACertificate.from_dict(_dict.get('data'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignCSR object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        if hasattr(self, 'data') and getattr(self, 'data') is not None:
            if isinstance(getattr(self, 'data'), dict):
                _dict['data'] = getattr(self, 'data')
            else:
                _dict['data'] = getattr(self, 'data').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignCSR object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignCSR') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignCSR') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignCSRPrototype(ConfigurationActionPrototype):
    """
    The request body to specify the properties of the action to sign a CSR for the private
    certificate configuration.

    :param str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :param str format: (optional) The format of the returned data.
    :param int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :param bool use_csr_values: (optional) This field indicates whether to use
          values from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :param str action_type: The type of configuration action.
    :param str csr: The certificate signing request.
    """

    def __init__(
        self,
        action_type: str,
        csr: str,
        *,
        common_name: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        ttl: Optional[str] = None,
        format: Optional[str] = None,
        max_path_length: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        permitted_dns_domains: Optional[List[str]] = None,
        use_csr_values: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignCSRPrototype object.

        :param str action_type: The type of configuration action.
        :param str csr: The certificate signing request.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.csr = csr

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignCSRPrototype':
        """Initialize a PrivateCertificateConfigurationActionSignCSRPrototype object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignCSRPrototype JSON')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        else:
            raise ValueError('Required property \'csr\' not present in PrivateCertificateConfigurationActionSignCSRPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignCSRPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignCSRPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignCSRPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignCSRPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignIntermediate(ConfigurationAction):
    """
    The response body of the action to sign the intermediate certificate authority for the
    private certificate configuration.

    :param str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :param str format: (optional) The format of the returned data.
    :param int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :param bool use_csr_values: (optional) This field indicates whether to use
          values from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :param str action_type: The type of configuration action.
    :param str intermediate_certificate_authority: The unique name of your
          configuration.
    """

    def __init__(
        self,
        action_type: str,
        intermediate_certificate_authority: str,
        *,
        common_name: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        ttl: Optional[str] = None,
        format: Optional[str] = None,
        max_path_length: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        permitted_dns_domains: Optional[List[str]] = None,
        use_csr_values: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignIntermediate object.

        :param str action_type: The type of configuration action.
        :param str intermediate_certificate_authority: The unique name of your
               configuration.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.intermediate_certificate_authority = intermediate_certificate_authority

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignIntermediate':
        """Initialize a PrivateCertificateConfigurationActionSignIntermediate object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignIntermediate JSON')
        if 'intermediate_certificate_authority' in _dict:
            args['intermediate_certificate_authority'] = _dict.get('intermediate_certificate_authority')
        else:
            raise ValueError('Required property \'intermediate_certificate_authority\' not present in PrivateCertificateConfigurationActionSignIntermediate JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignIntermediate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'intermediate_certificate_authority') and self.intermediate_certificate_authority is not None:
            _dict['intermediate_certificate_authority'] = self.intermediate_certificate_authority
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignIntermediate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignIntermediate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignIntermediate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignIntermediatePrototype(ConfigurationActionPrototype):
    """
    The request body to specify the properties of the action to sign an intermediate
    certificate authority for the private certificate configuration.

    :param str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :param str format: (optional) The format of the returned data.
    :param int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :param bool use_csr_values: (optional) This field indicates whether to use
          values from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :param str action_type: The type of configuration action.
    :param str intermediate_certificate_authority: The unique name of your
          configuration.
    """

    def __init__(
        self,
        action_type: str,
        intermediate_certificate_authority: str,
        *,
        common_name: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        ttl: Optional[str] = None,
        format: Optional[str] = None,
        max_path_length: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        permitted_dns_domains: Optional[List[str]] = None,
        use_csr_values: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignIntermediatePrototype object.

        :param str action_type: The type of configuration action.
        :param str intermediate_certificate_authority: The unique name of your
               configuration.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.intermediate_certificate_authority = intermediate_certificate_authority

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignIntermediatePrototype':
        """Initialize a PrivateCertificateConfigurationActionSignIntermediatePrototype object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignIntermediatePrototype JSON')
        if 'intermediate_certificate_authority' in _dict:
            args['intermediate_certificate_authority'] = _dict.get('intermediate_certificate_authority')
        else:
            raise ValueError('Required property \'intermediate_certificate_authority\' not present in PrivateCertificateConfigurationActionSignIntermediatePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignIntermediatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'intermediate_certificate_authority') and self.intermediate_certificate_authority is not None:
            _dict['intermediate_certificate_authority'] = self.intermediate_certificate_authority
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignIntermediatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignIntermediatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignIntermediatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationCACertificate(PrivateCertificateCAData):
    """
    The data that is associated with the root certificate authority.

    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str issuing_ca: (optional) The PEM-encoded certificate of the certificate
          authority that signed and issued this certificate.
    :param List[str] ca_chain: (optional) The chain of certificate authorities that
          are associated with the certificate.
    :param int expiration: (optional) The certificate expiration time.
    """

    def __init__(
        self,
        certificate: str,
        *,
        issuing_ca: Optional[str] = None,
        ca_chain: Optional[List[str]] = None,
        expiration: Optional[int] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationCACertificate object.

        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.certificate = certificate
        self.issuing_ca = issuing_ca
        self.ca_chain = ca_chain
        self.expiration = expiration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationCACertificate':
        """Initialize a PrivateCertificateConfigurationCACertificate object from a json dictionary."""
        args = {}
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateConfigurationCACertificate JSON')
        if 'issuing_ca' in _dict:
            args['issuing_ca'] = _dict.get('issuing_ca')
        if 'ca_chain' in _dict:
            args['ca_chain'] = _dict.get('ca_chain')
        if 'expiration' in _dict:
            args['expiration'] = _dict.get('expiration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationCACertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'issuing_ca') and getattr(self, 'issuing_ca') is not None:
            _dict['issuing_ca'] = getattr(self, 'issuing_ca')
        if hasattr(self, 'ca_chain') and getattr(self, 'ca_chain') is not None:
            _dict['ca_chain'] = getattr(self, 'ca_chain')
        if hasattr(self, 'expiration') and getattr(self, 'expiration') is not None:
            _dict['expiration'] = getattr(self, 'expiration')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationCACertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationCACertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationCACertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateConfigurationIntermediateCA(Configuration):
    """
    The configuration of the root certificate authority.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param str signing_method: The signing method to use with this certificate
          authority to generate private certificates.
          You can choose between internal or externally signed options. For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
    :param str status: (optional) The status of the certificate authority. The
          status of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    :param int max_ttl_seconds: (optional) The maximum time-to-live (TTL) for
          certificates that are created by this CA in seconds.
    :param int crl_expiry_seconds: (optional) The time until the certificate
          revocation list (CRL) expires, in seconds.
    :param bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :param bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str format: (optional) The format of the returned data.
    :param str private_key_format: (optional) The format of the generated private
          key.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :param PrivateCertificateCAData data: (optional) The configuration data of your
          Private Certificate.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        signing_method: str,
        *,
        crl_distribution_points_encoded: Optional[bool] = None,
        expiration_date: Optional[datetime] = None,
        issuer: Optional[str] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        status: Optional[str] = None,
        max_ttl_seconds: Optional[int] = None,
        crl_expiry_seconds: Optional[int] = None,
        crl_disable: Optional[bool] = None,
        issuing_certificates_urls_encoded: Optional[bool] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        format: Optional[str] = None,
        private_key_format: Optional[str] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
        data: Optional['PrivateCertificateCAData'] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCA object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str signing_method: The signing method to use with this certificate
               authority to generate private certificates.
               You can choose between internal or externally signed options. For more
               information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param PrivateCertificateCAData data: (optional) The configuration data of
               your Private Certificate.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_type = key_type
        self.key_bits = key_bits
        self.signing_method = signing_method
        self.status = status
        self.max_ttl_seconds = max_ttl_seconds
        self.crl_expiry_seconds = crl_expiry_seconds
        self.crl_disable = crl_disable
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.format = format
        self.private_key_format = private_key_format
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCA':
        """Initialize a PrivateCertificateConfigurationIntermediateCA object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'signing_method' in _dict:
            args['signing_method'] = _dict.get('signing_method')
        else:
            raise ValueError('Required property \'signing_method\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'max_ttl_seconds' in _dict:
            args['max_ttl_seconds'] = _dict.get('max_ttl_seconds')
        if 'crl_expiry_seconds' in _dict:
            args['crl_expiry_seconds'] = _dict.get('crl_expiry_seconds')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCA object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'signing_method') and self.signing_method is not None:
            _dict['signing_method'] = self.signing_method
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        if hasattr(self, 'max_ttl_seconds') and getattr(self, 'max_ttl_seconds') is not None:
            _dict['max_ttl_seconds'] = getattr(self, 'max_ttl_seconds')
        if hasattr(self, 'crl_expiry_seconds') and getattr(self, 'crl_expiry_seconds') is not None:
            _dict['crl_expiry_seconds'] = getattr(self, 'crl_expiry_seconds')
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'data') and self.data is not None:
            if isinstance(self.data, dict):
                _dict['data'] = self.data
            else:
                _dict['data'] = self.data.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCA object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCA') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCA') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class SigningMethodEnum(str, Enum):
        """
        The signing method to use with this certificate authority to generate private
        certificates.
        You can choose between internal or externally signed options. For more
        information, see the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        """

        INTERNAL = 'internal'
        EXTERNAL = 'external'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'



class PrivateCertificateConfigurationIntermediateCACSR(PrivateCertificateCAData):
    """
    The data that is associated with the intermediate certificate authority.

    :param str csr: (optional) The certificate signing request.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    :param str private_key_type: (optional) The type of private key to generate.
    :param int expiration: (optional) The certificate expiration time.
    """

    def __init__(
        self,
        *,
        csr: Optional[str] = None,
        private_key: Optional[str] = None,
        private_key_type: Optional[str] = None,
        expiration: Optional[int] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCACSR object.

        :param str csr: (optional) The certificate signing request.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        :param str private_key_type: (optional) The type of private key to
               generate.
        """
        # pylint: disable=super-init-not-called
        self.csr = csr
        self.private_key = private_key
        self.private_key_type = private_key_type
        self.expiration = expiration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCACSR':
        """Initialize a PrivateCertificateConfigurationIntermediateCACSR object from a json dictionary."""
        args = {}
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        if 'private_key_type' in _dict:
            args['private_key_type'] = _dict.get('private_key_type')
        if 'expiration' in _dict:
            args['expiration'] = _dict.get('expiration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCACSR object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'private_key_type') and self.private_key_type is not None:
            _dict['private_key_type'] = self.private_key_type
        if hasattr(self, 'expiration') and getattr(self, 'expiration') is not None:
            _dict['expiration'] = getattr(self, 'expiration')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCACSR object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCACSR') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCACSR') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class PrivateKeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationIntermediateCAMetadata(ConfigurationMetadata):
    """
    The configuration of the metadata properties of the intermediate certificate
    authority.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param str signing_method: The signing method to use with this certificate
          authority to generate private certificates.
          You can choose between internal or externally signed options. For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
    :param str status: (optional) The status of the certificate authority. The
          status of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        signing_method: str,
        *,
        crl_distribution_points_encoded: Optional[bool] = None,
        expiration_date: Optional[datetime] = None,
        issuer: Optional[str] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        status: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCAMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str signing_method: The signing method to use with this certificate
               authority to generate private certificates.
               You can choose between internal or externally signed options. For more
               information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_type = key_type
        self.key_bits = key_bits
        self.signing_method = signing_method
        self.status = status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCAMetadata':
        """Initialize a PrivateCertificateConfigurationIntermediateCAMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'signing_method' in _dict:
            args['signing_method'] = _dict.get('signing_method')
        else:
            raise ValueError('Required property \'signing_method\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCAMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'signing_method') and self.signing_method is not None:
            _dict['signing_method'] = self.signing_method
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCAMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCAMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCAMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class SigningMethodEnum(str, Enum):
        """
        The signing method to use with this certificate authority to generate private
        certificates.
        You can choose between internal or externally signed options. For more
        information, see the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        """

        INTERNAL = 'internal'
        EXTERNAL = 'external'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'



class PrivateCertificateConfigurationIntermediateCAPatch(ConfigurationPatch):
    """
    The configuration patch of the intermediate certificate authority.

    :param str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :param str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :param bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    """

    def __init__(
        self,
        *,
        max_ttl: Optional[str] = None,
        crl_expiry: Optional[str] = None,
        crl_disable: Optional[bool] = None,
        crl_distribution_points_encoded: Optional[bool] = None,
        issuing_certificates_urls_encoded: Optional[bool] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCAPatch object.

        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        """
        # pylint: disable=super-init-not-called
        self.max_ttl = max_ttl
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCAPatch':
        """Initialize a PrivateCertificateConfigurationIntermediateCAPatch object from a json dictionary."""
        args = {}
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCAPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCAPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCAPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCAPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateConfigurationIntermediateCAPrototype(ConfigurationPrototype):
    """
    The configuration of the intermediate certificate authority.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str max_ttl: The maximum time-to-live (TTL) for certificates that are
          created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :param str signing_method: The signing method to use with this certificate
          authority to generate private certificates.
          You can choose between internal or externally signed options. For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
    :param str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :param str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :param bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str format: (optional) The format of the returned data.
    :param str private_key_format: (optional) The format of the generated private
          key.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        max_ttl: str,
        signing_method: str,
        common_name: str,
        *,
        issuer: Optional[str] = None,
        crl_expiry: Optional[str] = None,
        crl_disable: Optional[bool] = None,
        crl_distribution_points_encoded: Optional[bool] = None,
        issuing_certificates_urls_encoded: Optional[bool] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        format: Optional[str] = None,
        private_key_format: Optional[str] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCAPrototype object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str max_ttl: The maximum time-to-live (TTL) for certificates that
               are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str signing_method: The signing method to use with this certificate
               authority to generate private certificates.
               You can choose between internal or externally signed options. For more
               information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.max_ttl = max_ttl
        self.signing_method = signing_method
        self.issuer = issuer
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.format = format
        self.private_key_format = private_key_format
        self.key_type = key_type
        self.key_bits = key_bits
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCAPrototype':
        """Initialize a PrivateCertificateConfigurationIntermediateCAPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        else:
            raise ValueError('Required property \'max_ttl\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'signing_method' in _dict:
            args['signing_method'] = _dict.get('signing_method')
        else:
            raise ValueError('Required property \'signing_method\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCAPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'signing_method') and self.signing_method is not None:
            _dict['signing_method'] = self.signing_method
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCAPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCAPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCAPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SigningMethodEnum(str, Enum):
        """
        The signing method to use with this certificate authority to generate private
        certificates.
        You can choose between internal or externally signed options. For more
        information, see the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        """

        INTERNAL = 'internal'
        EXTERNAL = 'external'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationRootCA(Configuration):
    """
    The root certificate authority .

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param str status: (optional) The status of the certificate authority. The
          status of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    :param int max_ttl_seconds: (optional) The maximum time-to-live (TTL) for
          certificates that are created by this CA in seconds.
    :param int crl_expiry_seconds: (optional) The time until the certificate
          revocation list (CRL) expires, in seconds.
    :param bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :param bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param int ttl_seconds: (optional) he requested TTL, after which the certificate
          expires.
    :param str format: (optional) The format of the returned data.
    :param str private_key_format: (optional) The format of the generated private
          key.
    :param int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :param PrivateCertificateCAData data: (optional) The configuration data of your
          Private Certificate.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        *,
        crl_distribution_points_encoded: Optional[bool] = None,
        expiration_date: Optional[datetime] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        status: Optional[str] = None,
        max_ttl_seconds: Optional[int] = None,
        crl_expiry_seconds: Optional[int] = None,
        crl_disable: Optional[bool] = None,
        issuing_certificates_urls_encoded: Optional[bool] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        ttl_seconds: Optional[int] = None,
        format: Optional[str] = None,
        private_key_format: Optional[str] = None,
        max_path_length: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        permitted_dns_domains: Optional[List[str]] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
        data: Optional['PrivateCertificateCAData'] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCA object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param PrivateCertificateCAData data: (optional) The configuration data of
               your Private Certificate.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.key_type = key_type
        self.key_bits = key_bits
        self.status = status
        self.max_ttl_seconds = max_ttl_seconds
        self.crl_expiry_seconds = crl_expiry_seconds
        self.crl_disable = crl_disable
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl_seconds = ttl_seconds
        self.format = format
        self.private_key_format = private_key_format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCA':
        """Initialize a PrivateCertificateConfigurationRootCA object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'max_ttl_seconds' in _dict:
            args['max_ttl_seconds'] = _dict.get('max_ttl_seconds')
        if 'crl_expiry_seconds' in _dict:
            args['crl_expiry_seconds'] = _dict.get('crl_expiry_seconds')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl_seconds' in _dict:
            args['ttl_seconds'] = _dict.get('ttl_seconds')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCA object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        if hasattr(self, 'max_ttl_seconds') and getattr(self, 'max_ttl_seconds') is not None:
            _dict['max_ttl_seconds'] = getattr(self, 'max_ttl_seconds')
        if hasattr(self, 'crl_expiry_seconds') and getattr(self, 'crl_expiry_seconds') is not None:
            _dict['crl_expiry_seconds'] = getattr(self, 'crl_expiry_seconds')
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl_seconds') and getattr(self, 'ttl_seconds') is not None:
            _dict['ttl_seconds'] = getattr(self, 'ttl_seconds')
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'data') and self.data is not None:
            if isinstance(self.data, dict):
                _dict['data'] = self.data
            else:
                _dict['data'] = self.data.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCA object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCA') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCA') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'



class PrivateCertificateConfigurationRootCAMetadata(ConfigurationMetadata):
    """
    The configuration of the metadata properties of the root certificate authority.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param str status: (optional) The status of the certificate authority. The
          status of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        *,
        crl_distribution_points_encoded: Optional[bool] = None,
        expiration_date: Optional[datetime] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        status: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCAMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.key_type = key_type
        self.key_bits = key_bits
        self.status = status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCAMetadata':
        """Initialize a PrivateCertificateConfigurationRootCAMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCAMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCAMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCAMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCAMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'



class PrivateCertificateConfigurationRootCAPatch(ConfigurationPatch):
    """
    The configuration of the metadata patch for the root certificate authority.

    :param str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :param str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :param bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    """

    def __init__(
        self,
        *,
        max_ttl: Optional[str] = None,
        crl_expiry: Optional[str] = None,
        crl_disable: Optional[bool] = None,
        crl_distribution_points_encoded: Optional[bool] = None,
        issuing_certificates_urls_encoded: Optional[bool] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCAPatch object.

        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        """
        # pylint: disable=super-init-not-called
        self.max_ttl = max_ttl
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCAPatch':
        """Initialize a PrivateCertificateConfigurationRootCAPatch object from a json dictionary."""
        args = {}
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCAPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCAPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCAPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCAPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateConfigurationRootCAPrototype(ConfigurationPrototype):
    """
    The configuration of the root certificate authority.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str max_ttl: The maximum time-to-live (TTL) for certificates that are
          created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :param str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :param bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :param bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :param bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str ttl: (optional) The requested time-to-live (TTL) for certificates
          that are created by this CA. This field's value can't be longer than the
          `max_ttl` limit.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
    :param str format: (optional) The format of the returned data.
    :param str private_key_format: (optional) The format of the generated private
          key.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        max_ttl: str,
        common_name: str,
        *,
        crl_expiry: Optional[str] = None,
        crl_disable: Optional[bool] = None,
        crl_distribution_points_encoded: Optional[bool] = None,
        issuing_certificates_urls_encoded: Optional[bool] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        ttl: Optional[str] = None,
        format: Optional[str] = None,
        private_key_format: Optional[str] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        max_path_length: Optional[int] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        permitted_dns_domains: Optional[List[str]] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCAPrototype object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str max_ttl: The maximum time-to-live (TTL) for certificates that
               are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The requested time-to-live (TTL) for
               certificates that are created by this CA. This field's value can't be
               longer than the `max_ttl` limit.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.max_ttl = max_ttl
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.private_key_format = private_key_format
        self.key_type = key_type
        self.key_bits = key_bits
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCAPrototype':
        """Initialize a PrivateCertificateConfigurationRootCAPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        else:
            raise ValueError('Required property \'max_ttl\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCAPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCAPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCAPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCAPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationTemplate(Configuration):
    """
    The configuration of the private certificate template.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str certificate_authority: The name of the intermediate certificate
          authority.
    :param str allowed_secret_groups: (optional) This field scopes the creation of
          private certificates to only the secret groups that you specify.
          This field can be supplied as a comma-delimited list of secret group IDs.
    :param int max_ttl_seconds: (optional) The maximum time-to-live (TTL) for
          certificates that are created by this CA in seconds.
    :param int ttl_seconds: (optional) he requested TTL, after which the certificate
          expires.
    :param bool allow_localhost: (optional) This field indicates whether to allow
          `localhost` to be included as one of the requested common names.
    :param List[str] allowed_domains: (optional) The domains to define for the
          certificate template. This property is used along with the `allow_bare_domains`
          and `allow_subdomains` options.
    :param bool allowed_domains_template: (optional) This field indicates whether to
          allow the domains that are supplied in the `allowed_domains` field to contain
          access control list (ACL) templates.
    :param bool allow_bare_domains: (optional) This field indicates whether to allow
          clients to request private certificates that match the value of the actual
          domains on the final certificate.
          For example, if you specify `example.com` in the `allowed_domains` field, you
          grant clients the ability to request a certificate that contains the name
          `example.com` as one of the DNS values on the final certificate.
          **Important:** In some scenarios, allowing bare domains can be considered a
          security risk.
    :param bool allow_subdomains: (optional) This field indicates whether to allow
          clients to request private certificates with common names (CN) that are
          subdomains of the CNs that are allowed by the other certificate template
          options. This includes wildcard subdomains.
          For example, if `allowed_domains` has a value of `example.com` and
          `allow_subdomains`is set to `true`, then the following subdomains are allowed:
          `foo.example.com`, `bar.example.com`, `*.example.com`.
          **Note:** This field is redundant if you use the `allow_any_name` option.
    :param bool allow_glob_domains: (optional) This field indicates whether to allow
          glob patterns, for example, `ftp*.example.com`, in the names that are specified
          in the `allowed_domains` field.
          If set to `true`, clients are allowed to request private certificates with names
          that match the glob patterns.
    :param bool allow_any_name: (optional) This field indicates whether to allow
          clients to request a private certificate that matches any common name.
    :param bool enforce_hostnames: (optional) This field indicates whether to
          enforce only valid hostnames for common names, DNS Subject Alternative Names,
          and the host section of email addresses.
    :param bool allow_ip_sans: (optional) This field indicates whether to allow
          clients to request a private certificate with IP Subject Alternative Names.
    :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative Names
          to allow for private certificates.
          Values can contain glob patterns, for example `spiffe://hostname/*`.
    :param List[str] allowed_other_sans: (optional) The custom Object Identifier
          (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private
          certificates.
          The format for each element in the list is the same as OpenSSL:
          `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
          value for an OID, use `*` as its value. Alternatively, specify a single `*` to
          allow any `other_sans` input.
    :param bool server_flag: (optional) This field indicates whether private
          certificates are flagged for server use.
    :param bool client_flag: (optional) This field indicates whether private
          certificates are flagged for client use.
    :param bool code_signing_flag: (optional) This field indicates whether private
          certificates are flagged for code signing use.
    :param bool email_protection_flag: (optional) This field indicates whether
          private certificates are flagged for email protection use.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param List[str] key_usage: (optional) The allowed key usage constraint to
          define for private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage`
          part of the value. Values are not case-sensitive. To specify no key usage
          constraints, set this field to an empty list.
    :param List[str] ext_key_usage: (optional) The allowed extended key usage
          constraint on private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
          `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no
          key usage constraints, set this field to an empty list.
    :param List[str] ext_key_usage_oids: (optional) A list of extended key usage
          Object Identifiers (OIDs).
    :param bool use_csr_common_name: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the common name (CN) from a certificate signing request (CSR)
          instead of the CN that is included in the data of the certificate.
          Does not include any requested Subject Alternative Names (SANs) in the CSR. To
          use the alternative names, include the `use_csr_sans` property.
    :param bool use_csr_sans: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the Subject Alternative Names
          (SANs) from a certificate signing request (CSR) instead of the SANs that are
          included in the data of the certificate.
          This field does not include the common name in the CSR. To use the common name,
          include the `use_csr_common_name` property.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) This field is deprecated. You can ignore
          its value.
    :param bool require_cn: (optional) This field indicates whether to require a
          common name to create a private certificate.
          By default, a common name is required to generate a certificate. To make the
          `common_name` field optional, set the `require_cn` option to `false`.
    :param List[str] policy_identifiers: (optional) A list of policy Object
          Identifiers (OIDs).
    :param bool basic_constraints_valid_for_non_ca: (optional) This field indicates
          whether to mark the Basic Constraints extension of an issued private certificate
          as valid for non-CA certificates.
    :param int not_before_duration_seconds: (optional) The duration in seconds by
          which to backdate the `not_before` property of an issued private certificate.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        certificate_authority: str,
        *,
        allowed_secret_groups: Optional[str] = None,
        max_ttl_seconds: Optional[int] = None,
        ttl_seconds: Optional[int] = None,
        allow_localhost: Optional[bool] = None,
        allowed_domains: Optional[List[str]] = None,
        allowed_domains_template: Optional[bool] = None,
        allow_bare_domains: Optional[bool] = None,
        allow_subdomains: Optional[bool] = None,
        allow_glob_domains: Optional[bool] = None,
        allow_any_name: Optional[bool] = None,
        enforce_hostnames: Optional[bool] = None,
        allow_ip_sans: Optional[bool] = None,
        allowed_uri_sans: Optional[List[str]] = None,
        allowed_other_sans: Optional[List[str]] = None,
        server_flag: Optional[bool] = None,
        client_flag: Optional[bool] = None,
        code_signing_flag: Optional[bool] = None,
        email_protection_flag: Optional[bool] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        key_usage: Optional[List[str]] = None,
        ext_key_usage: Optional[List[str]] = None,
        ext_key_usage_oids: Optional[List[str]] = None,
        use_csr_common_name: Optional[bool] = None,
        use_csr_sans: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
        require_cn: Optional[bool] = None,
        policy_identifiers: Optional[List[str]] = None,
        basic_constraints_valid_for_non_ca: Optional[bool] = None,
        not_before_duration_seconds: Optional[int] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplate object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str certificate_authority: The name of the intermediate certificate
               authority.
        :param str allowed_secret_groups: (optional) This field scopes the creation
               of private certificates to only the secret groups that you specify.
               This field can be supplied as a comma-delimited list of secret group IDs.
        :param bool allow_localhost: (optional) This field indicates whether to
               allow `localhost` to be included as one of the requested common names.
        :param List[str] allowed_domains: (optional) The domains to define for the
               certificate template. This property is used along with the
               `allow_bare_domains` and `allow_subdomains` options.
        :param bool allowed_domains_template: (optional) This field indicates
               whether to allow the domains that are supplied in the `allowed_domains`
               field to contain access control list (ACL) templates.
        :param bool allow_bare_domains: (optional) This field indicates whether to
               allow clients to request private certificates that match the value of the
               actual domains on the final certificate.
               For example, if you specify `example.com` in the `allowed_domains` field,
               you grant clients the ability to request a certificate that contains the
               name `example.com` as one of the DNS values on the final certificate.
               **Important:** In some scenarios, allowing bare domains can be considered a
               security risk.
        :param bool allow_subdomains: (optional) This field indicates whether to
               allow clients to request private certificates with common names (CN) that
               are subdomains of the CNs that are allowed by the other certificate
               template options. This includes wildcard subdomains.
               For example, if `allowed_domains` has a value of `example.com` and
               `allow_subdomains`is set to `true`, then the following subdomains are
               allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.
               **Note:** This field is redundant if you use the `allow_any_name` option.
        :param bool allow_glob_domains: (optional) This field indicates whether to
               allow glob patterns, for example, `ftp*.example.com`, in the names that are
               specified in the `allowed_domains` field.
               If set to `true`, clients are allowed to request private certificates with
               names that match the glob patterns.
        :param bool allow_any_name: (optional) This field indicates whether to
               allow clients to request a private certificate that matches any common
               name.
        :param bool enforce_hostnames: (optional) This field indicates whether to
               enforce only valid hostnames for common names, DNS Subject Alternative
               Names, and the host section of email addresses.
        :param bool allow_ip_sans: (optional) This field indicates whether to allow
               clients to request a private certificate with IP Subject Alternative Names.
        :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative
               Names to allow for private certificates.
               Values can contain glob patterns, for example `spiffe://hostname/*`.
        :param List[str] allowed_other_sans: (optional) The custom Object
               Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow
               for private certificates.
               The format for each element in the list is the same as OpenSSL:
               `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
               value for an OID, use `*` as its value. Alternatively, specify a single `*`
               to allow any `other_sans` input.
        :param bool server_flag: (optional) This field indicates whether private
               certificates are flagged for server use.
        :param bool client_flag: (optional) This field indicates whether private
               certificates are flagged for client use.
        :param bool code_signing_flag: (optional) This field indicates whether
               private certificates are flagged for code signing use.
        :param bool email_protection_flag: (optional) This field indicates whether
               private certificates are flagged for email protection use.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param List[str] key_usage: (optional) The allowed key usage constraint to
               define for private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the
               `KeyUsage` part of the value. Values are not case-sensitive. To specify no
               key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage: (optional) The allowed extended key usage
               constraint on private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
               `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify
               no key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage_oids: (optional) A list of extended key
               usage Object Identifiers (OIDs).
        :param bool use_csr_common_name: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the common name (CN) from a certificate signing request
               (CSR) instead of the CN that is included in the data of the certificate.
               Does not include any requested Subject Alternative Names (SANs) in the CSR.
               To use the alternative names, include the `use_csr_sans` property.
        :param bool use_csr_sans: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the Subject Alternative Names
               (SANs) from a certificate signing request (CSR) instead of the SANs that
               are included in the data of the certificate.
               This field does not include the common name in the CSR. To use the common
               name, include the `use_csr_common_name` property.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) This field is deprecated. You can
               ignore its value.
        :param bool require_cn: (optional) This field indicates whether to require
               a common name to create a private certificate.
               By default, a common name is required to generate a certificate. To make
               the `common_name` field optional, set the `require_cn` option to `false`.
        :param List[str] policy_identifiers: (optional) A list of policy Object
               Identifiers (OIDs).
        :param bool basic_constraints_valid_for_non_ca: (optional) This field
               indicates whether to mark the Basic Constraints extension of an issued
               private certificate as valid for non-CA certificates.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.certificate_authority = certificate_authority
        self.allowed_secret_groups = allowed_secret_groups
        self.max_ttl_seconds = max_ttl_seconds
        self.ttl_seconds = ttl_seconds
        self.allow_localhost = allow_localhost
        self.allowed_domains = allowed_domains
        self.allowed_domains_template = allowed_domains_template
        self.allow_bare_domains = allow_bare_domains
        self.allow_subdomains = allow_subdomains
        self.allow_glob_domains = allow_glob_domains
        self.allow_any_name = allow_any_name
        self.enforce_hostnames = enforce_hostnames
        self.allow_ip_sans = allow_ip_sans
        self.allowed_uri_sans = allowed_uri_sans
        self.allowed_other_sans = allowed_other_sans
        self.server_flag = server_flag
        self.client_flag = client_flag
        self.code_signing_flag = code_signing_flag
        self.email_protection_flag = email_protection_flag
        self.key_type = key_type
        self.key_bits = key_bits
        self.key_usage = key_usage
        self.ext_key_usage = ext_key_usage
        self.ext_key_usage_oids = ext_key_usage_oids
        self.use_csr_common_name = use_csr_common_name
        self.use_csr_sans = use_csr_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.require_cn = require_cn
        self.policy_identifiers = policy_identifiers
        self.basic_constraints_valid_for_non_ca = basic_constraints_valid_for_non_ca
        self.not_before_duration_seconds = not_before_duration_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplate':
        """Initialize a PrivateCertificateConfigurationTemplate object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        else:
            raise ValueError('Required property \'certificate_authority\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'allowed_secret_groups' in _dict:
            args['allowed_secret_groups'] = _dict.get('allowed_secret_groups')
        if 'max_ttl_seconds' in _dict:
            args['max_ttl_seconds'] = _dict.get('max_ttl_seconds')
        if 'ttl_seconds' in _dict:
            args['ttl_seconds'] = _dict.get('ttl_seconds')
        if 'allow_localhost' in _dict:
            args['allow_localhost'] = _dict.get('allow_localhost')
        if 'allowed_domains' in _dict:
            args['allowed_domains'] = _dict.get('allowed_domains')
        if 'allowed_domains_template' in _dict:
            args['allowed_domains_template'] = _dict.get('allowed_domains_template')
        if 'allow_bare_domains' in _dict:
            args['allow_bare_domains'] = _dict.get('allow_bare_domains')
        if 'allow_subdomains' in _dict:
            args['allow_subdomains'] = _dict.get('allow_subdomains')
        if 'allow_glob_domains' in _dict:
            args['allow_glob_domains'] = _dict.get('allow_glob_domains')
        if 'allow_any_name' in _dict:
            args['allow_any_name'] = _dict.get('allow_any_name')
        if 'enforce_hostnames' in _dict:
            args['enforce_hostnames'] = _dict.get('enforce_hostnames')
        if 'allow_ip_sans' in _dict:
            args['allow_ip_sans'] = _dict.get('allow_ip_sans')
        if 'allowed_uri_sans' in _dict:
            args['allowed_uri_sans'] = _dict.get('allowed_uri_sans')
        if 'allowed_other_sans' in _dict:
            args['allowed_other_sans'] = _dict.get('allowed_other_sans')
        if 'server_flag' in _dict:
            args['server_flag'] = _dict.get('server_flag')
        if 'client_flag' in _dict:
            args['client_flag'] = _dict.get('client_flag')
        if 'code_signing_flag' in _dict:
            args['code_signing_flag'] = _dict.get('code_signing_flag')
        if 'email_protection_flag' in _dict:
            args['email_protection_flag'] = _dict.get('email_protection_flag')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'key_usage' in _dict:
            args['key_usage'] = _dict.get('key_usage')
        if 'ext_key_usage' in _dict:
            args['ext_key_usage'] = _dict.get('ext_key_usage')
        if 'ext_key_usage_oids' in _dict:
            args['ext_key_usage_oids'] = _dict.get('ext_key_usage_oids')
        if 'use_csr_common_name' in _dict:
            args['use_csr_common_name'] = _dict.get('use_csr_common_name')
        if 'use_csr_sans' in _dict:
            args['use_csr_sans'] = _dict.get('use_csr_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'require_cn' in _dict:
            args['require_cn'] = _dict.get('require_cn')
        if 'policy_identifiers' in _dict:
            args['policy_identifiers'] = _dict.get('policy_identifiers')
        if 'basic_constraints_valid_for_non_ca' in _dict:
            args['basic_constraints_valid_for_non_ca'] = _dict.get('basic_constraints_valid_for_non_ca')
        if 'not_before_duration_seconds' in _dict:
            args['not_before_duration_seconds'] = _dict.get('not_before_duration_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'certificate_authority') and self.certificate_authority is not None:
            _dict['certificate_authority'] = self.certificate_authority
        if hasattr(self, 'allowed_secret_groups') and self.allowed_secret_groups is not None:
            _dict['allowed_secret_groups'] = self.allowed_secret_groups
        if hasattr(self, 'max_ttl_seconds') and getattr(self, 'max_ttl_seconds') is not None:
            _dict['max_ttl_seconds'] = getattr(self, 'max_ttl_seconds')
        if hasattr(self, 'ttl_seconds') and getattr(self, 'ttl_seconds') is not None:
            _dict['ttl_seconds'] = getattr(self, 'ttl_seconds')
        if hasattr(self, 'allow_localhost') and self.allow_localhost is not None:
            _dict['allow_localhost'] = self.allow_localhost
        if hasattr(self, 'allowed_domains') and self.allowed_domains is not None:
            _dict['allowed_domains'] = self.allowed_domains
        if hasattr(self, 'allowed_domains_template') and self.allowed_domains_template is not None:
            _dict['allowed_domains_template'] = self.allowed_domains_template
        if hasattr(self, 'allow_bare_domains') and self.allow_bare_domains is not None:
            _dict['allow_bare_domains'] = self.allow_bare_domains
        if hasattr(self, 'allow_subdomains') and self.allow_subdomains is not None:
            _dict['allow_subdomains'] = self.allow_subdomains
        if hasattr(self, 'allow_glob_domains') and self.allow_glob_domains is not None:
            _dict['allow_glob_domains'] = self.allow_glob_domains
        if hasattr(self, 'allow_any_name') and self.allow_any_name is not None:
            _dict['allow_any_name'] = self.allow_any_name
        if hasattr(self, 'enforce_hostnames') and self.enforce_hostnames is not None:
            _dict['enforce_hostnames'] = self.enforce_hostnames
        if hasattr(self, 'allow_ip_sans') and self.allow_ip_sans is not None:
            _dict['allow_ip_sans'] = self.allow_ip_sans
        if hasattr(self, 'allowed_uri_sans') and self.allowed_uri_sans is not None:
            _dict['allowed_uri_sans'] = self.allowed_uri_sans
        if hasattr(self, 'allowed_other_sans') and self.allowed_other_sans is not None:
            _dict['allowed_other_sans'] = self.allowed_other_sans
        if hasattr(self, 'server_flag') and self.server_flag is not None:
            _dict['server_flag'] = self.server_flag
        if hasattr(self, 'client_flag') and self.client_flag is not None:
            _dict['client_flag'] = self.client_flag
        if hasattr(self, 'code_signing_flag') and self.code_signing_flag is not None:
            _dict['code_signing_flag'] = self.code_signing_flag
        if hasattr(self, 'email_protection_flag') and self.email_protection_flag is not None:
            _dict['email_protection_flag'] = self.email_protection_flag
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'key_usage') and self.key_usage is not None:
            _dict['key_usage'] = self.key_usage
        if hasattr(self, 'ext_key_usage') and self.ext_key_usage is not None:
            _dict['ext_key_usage'] = self.ext_key_usage
        if hasattr(self, 'ext_key_usage_oids') and self.ext_key_usage_oids is not None:
            _dict['ext_key_usage_oids'] = self.ext_key_usage_oids
        if hasattr(self, 'use_csr_common_name') and self.use_csr_common_name is not None:
            _dict['use_csr_common_name'] = self.use_csr_common_name
        if hasattr(self, 'use_csr_sans') and self.use_csr_sans is not None:
            _dict['use_csr_sans'] = self.use_csr_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'require_cn') and self.require_cn is not None:
            _dict['require_cn'] = self.require_cn
        if hasattr(self, 'policy_identifiers') and self.policy_identifiers is not None:
            _dict['policy_identifiers'] = self.policy_identifiers
        if hasattr(self, 'basic_constraints_valid_for_non_ca') and self.basic_constraints_valid_for_non_ca is not None:
            _dict['basic_constraints_valid_for_non_ca'] = self.basic_constraints_valid_for_non_ca
        if hasattr(self, 'not_before_duration_seconds') and getattr(self, 'not_before_duration_seconds') is not None:
            _dict['not_before_duration_seconds'] = getattr(self, 'not_before_duration_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationTemplateMetadata(ConfigurationMetadata):
    """
    The metadata properties of the configuration of the private certificate template.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str certificate_authority: The name of the intermediate certificate
          authority.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        certificate_authority: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplateMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str certificate_authority: The name of the intermediate certificate
               authority.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.certificate_authority = certificate_authority

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplateMetadata':
        """Initialize a PrivateCertificateConfigurationTemplateMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        else:
            raise ValueError('Required property \'certificate_authority\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'certificate_authority') and self.certificate_authority is not None:
            _dict['certificate_authority'] = self.certificate_authority
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class PrivateCertificateConfigurationTemplatePatch(ConfigurationPatch):
    """
    Properties that describe a certificate template. You can use a certificate template to
    control the parameters that are applied to your issued private certificates. For more
    information, see the
    [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-certificate-templates).

    :param str allowed_secret_groups: (optional) This field scopes the creation of
          private certificates to only the secret groups that you specify.
          This field can be supplied as a comma-delimited list of secret group IDs.
    :param str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :param str ttl: (optional) The requested time-to-live (TTL) for certificates
          that are created by this CA. This field's value can't be longer than the
          `max_ttl` limit.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
    :param bool allow_localhost: (optional) This field indicates whether to allow
          `localhost` to be included as one of the requested common names.
    :param List[str] allowed_domains: (optional) The domains to define for the
          certificate template. This property is used along with the `allow_bare_domains`
          and `allow_subdomains` options.
    :param bool allowed_domains_template: (optional) This field indicates whether to
          allow the domains that are supplied in the `allowed_domains` field to contain
          access control list (ACL) templates.
    :param bool allow_bare_domains: (optional) This field indicates whether to allow
          clients to request private certificates that match the value of the actual
          domains on the final certificate.
          For example, if you specify `example.com` in the `allowed_domains` field, you
          grant clients the ability to request a certificate that contains the name
          `example.com` as one of the DNS values on the final certificate.
          **Important:** In some scenarios, allowing bare domains can be considered a
          security risk.
    :param bool allow_subdomains: (optional) This field indicates whether to allow
          clients to request private certificates with common names (CN) that are
          subdomains of the CNs that are allowed by the other certificate template
          options. This includes wildcard subdomains.
          For example, if `allowed_domains` has a value of `example.com` and
          `allow_subdomains`is set to `true`, then the following subdomains are allowed:
          `foo.example.com`, `bar.example.com`, `*.example.com`.
          **Note:** This field is redundant if you use the `allow_any_name` option.
    :param bool allow_glob_domains: (optional) This field indicates whether to allow
          glob patterns, for example, `ftp*.example.com`, in the names that are specified
          in the `allowed_domains` field.
          If set to `true`, clients are allowed to request private certificates with names
          that match the glob patterns.
    :param bool allow_any_name: (optional) This field indicates whether to allow
          clients to request a private certificate that matches any common name.
    :param bool enforce_hostnames: (optional) This field indicates whether to
          enforce only valid hostnames for common names, DNS Subject Alternative Names,
          and the host section of email addresses.
    :param bool allow_ip_sans: (optional) This field indicates whether to allow
          clients to request a private certificate with IP Subject Alternative Names.
    :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative Names
          to allow for private certificates.
          Values can contain glob patterns, for example `spiffe://hostname/*`.
    :param List[str] allowed_other_sans: (optional) The custom Object Identifier
          (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private
          certificates.
          The format for each element in the list is the same as OpenSSL:
          `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
          value for an OID, use `*` as its value. Alternatively, specify a single `*` to
          allow any `other_sans` input.
    :param bool server_flag: (optional) This field indicates whether private
          certificates are flagged for server use.
    :param bool client_flag: (optional) This field indicates whether private
          certificates are flagged for client use.
    :param bool code_signing_flag: (optional) This field indicates whether private
          certificates are flagged for code signing use.
    :param bool email_protection_flag: (optional) This field indicates whether
          private certificates are flagged for email protection use.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param List[str] key_usage: (optional) The allowed key usage constraint to
          define for private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage`
          part of the value. Values are not case-sensitive. To specify no key usage
          constraints, set this field to an empty list.
    :param List[str] ext_key_usage: (optional) The allowed extended key usage
          constraint on private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
          `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no
          key usage constraints, set this field to an empty list.
    :param List[str] ext_key_usage_oids: (optional) A list of extended key usage
          Object Identifiers (OIDs).
    :param bool use_csr_common_name: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the common name (CN) from a certificate signing request (CSR)
          instead of the CN that is included in the data of the certificate.
          Does not include any requested Subject Alternative Names (SANs) in the CSR. To
          use the alternative names, include the `use_csr_sans` property.
    :param bool use_csr_sans: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the Subject Alternative Names
          (SANs) from a certificate signing request (CSR) instead of the SANs that are
          included in the data of the certificate.
          This field does not include the common name in the CSR. To use the common name,
          include the `use_csr_common_name` property.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) This field is deprecated. You can ignore
          its value.
    :param bool require_cn: (optional) This field indicates whether to require a
          common name to create a private certificate.
          By default, a common name is required to generate a certificate. To make the
          `common_name` field optional, set the `require_cn` option to `false`.
    :param List[str] policy_identifiers: (optional) A list of policy Object
          Identifiers (OIDs).
    :param bool basic_constraints_valid_for_non_ca: (optional) This field indicates
          whether to mark the Basic Constraints extension of an issued private certificate
          as valid for non-CA certificates.
    :param str not_before_duration: (optional) The duration in seconds by which to
          backdate the `not_before` property of an issued private certificate.
          The value can be supplied as a string representation of a duration, such as
          `30s`. In the API response, this value is returned in seconds (integer).
    """

    def __init__(
        self,
        *,
        allowed_secret_groups: Optional[str] = None,
        max_ttl: Optional[str] = None,
        ttl: Optional[str] = None,
        allow_localhost: Optional[bool] = None,
        allowed_domains: Optional[List[str]] = None,
        allowed_domains_template: Optional[bool] = None,
        allow_bare_domains: Optional[bool] = None,
        allow_subdomains: Optional[bool] = None,
        allow_glob_domains: Optional[bool] = None,
        allow_any_name: Optional[bool] = None,
        enforce_hostnames: Optional[bool] = None,
        allow_ip_sans: Optional[bool] = None,
        allowed_uri_sans: Optional[List[str]] = None,
        allowed_other_sans: Optional[List[str]] = None,
        server_flag: Optional[bool] = None,
        client_flag: Optional[bool] = None,
        code_signing_flag: Optional[bool] = None,
        email_protection_flag: Optional[bool] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        key_usage: Optional[List[str]] = None,
        ext_key_usage: Optional[List[str]] = None,
        ext_key_usage_oids: Optional[List[str]] = None,
        use_csr_common_name: Optional[bool] = None,
        use_csr_sans: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
        require_cn: Optional[bool] = None,
        policy_identifiers: Optional[List[str]] = None,
        basic_constraints_valid_for_non_ca: Optional[bool] = None,
        not_before_duration: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplatePatch object.

        :param str allowed_secret_groups: (optional) This field scopes the creation
               of private certificates to only the secret groups that you specify.
               This field can be supplied as a comma-delimited list of secret group IDs.
        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str ttl: (optional) The requested time-to-live (TTL) for
               certificates that are created by this CA. This field's value can't be
               longer than the `max_ttl` limit.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
        :param bool allow_localhost: (optional) This field indicates whether to
               allow `localhost` to be included as one of the requested common names.
        :param List[str] allowed_domains: (optional) The domains to define for the
               certificate template. This property is used along with the
               `allow_bare_domains` and `allow_subdomains` options.
        :param bool allowed_domains_template: (optional) This field indicates
               whether to allow the domains that are supplied in the `allowed_domains`
               field to contain access control list (ACL) templates.
        :param bool allow_bare_domains: (optional) This field indicates whether to
               allow clients to request private certificates that match the value of the
               actual domains on the final certificate.
               For example, if you specify `example.com` in the `allowed_domains` field,
               you grant clients the ability to request a certificate that contains the
               name `example.com` as one of the DNS values on the final certificate.
               **Important:** In some scenarios, allowing bare domains can be considered a
               security risk.
        :param bool allow_subdomains: (optional) This field indicates whether to
               allow clients to request private certificates with common names (CN) that
               are subdomains of the CNs that are allowed by the other certificate
               template options. This includes wildcard subdomains.
               For example, if `allowed_domains` has a value of `example.com` and
               `allow_subdomains`is set to `true`, then the following subdomains are
               allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.
               **Note:** This field is redundant if you use the `allow_any_name` option.
        :param bool allow_glob_domains: (optional) This field indicates whether to
               allow glob patterns, for example, `ftp*.example.com`, in the names that are
               specified in the `allowed_domains` field.
               If set to `true`, clients are allowed to request private certificates with
               names that match the glob patterns.
        :param bool allow_any_name: (optional) This field indicates whether to
               allow clients to request a private certificate that matches any common
               name.
        :param bool enforce_hostnames: (optional) This field indicates whether to
               enforce only valid hostnames for common names, DNS Subject Alternative
               Names, and the host section of email addresses.
        :param bool allow_ip_sans: (optional) This field indicates whether to allow
               clients to request a private certificate with IP Subject Alternative Names.
        :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative
               Names to allow for private certificates.
               Values can contain glob patterns, for example `spiffe://hostname/*`.
        :param List[str] allowed_other_sans: (optional) The custom Object
               Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow
               for private certificates.
               The format for each element in the list is the same as OpenSSL:
               `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
               value for an OID, use `*` as its value. Alternatively, specify a single `*`
               to allow any `other_sans` input.
        :param bool server_flag: (optional) This field indicates whether private
               certificates are flagged for server use.
        :param bool client_flag: (optional) This field indicates whether private
               certificates are flagged for client use.
        :param bool code_signing_flag: (optional) This field indicates whether
               private certificates are flagged for code signing use.
        :param bool email_protection_flag: (optional) This field indicates whether
               private certificates are flagged for email protection use.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param List[str] key_usage: (optional) The allowed key usage constraint to
               define for private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the
               `KeyUsage` part of the value. Values are not case-sensitive. To specify no
               key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage: (optional) The allowed extended key usage
               constraint on private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
               `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify
               no key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage_oids: (optional) A list of extended key
               usage Object Identifiers (OIDs).
        :param bool use_csr_common_name: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the common name (CN) from a certificate signing request
               (CSR) instead of the CN that is included in the data of the certificate.
               Does not include any requested Subject Alternative Names (SANs) in the CSR.
               To use the alternative names, include the `use_csr_sans` property.
        :param bool use_csr_sans: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the Subject Alternative Names
               (SANs) from a certificate signing request (CSR) instead of the SANs that
               are included in the data of the certificate.
               This field does not include the common name in the CSR. To use the common
               name, include the `use_csr_common_name` property.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) This field is deprecated. You can
               ignore its value.
        :param bool require_cn: (optional) This field indicates whether to require
               a common name to create a private certificate.
               By default, a common name is required to generate a certificate. To make
               the `common_name` field optional, set the `require_cn` option to `false`.
        :param List[str] policy_identifiers: (optional) A list of policy Object
               Identifiers (OIDs).
        :param bool basic_constraints_valid_for_non_ca: (optional) This field
               indicates whether to mark the Basic Constraints extension of an issued
               private certificate as valid for non-CA certificates.
        :param str not_before_duration: (optional) The duration in seconds by which
               to backdate the `not_before` property of an issued private certificate.
               The value can be supplied as a string representation of a duration, such as
               `30s`. In the API response, this value is returned in seconds (integer).
        """
        # pylint: disable=super-init-not-called
        self.allowed_secret_groups = allowed_secret_groups
        self.max_ttl = max_ttl
        self.ttl = ttl
        self.allow_localhost = allow_localhost
        self.allowed_domains = allowed_domains
        self.allowed_domains_template = allowed_domains_template
        self.allow_bare_domains = allow_bare_domains
        self.allow_subdomains = allow_subdomains
        self.allow_glob_domains = allow_glob_domains
        self.allow_any_name = allow_any_name
        self.enforce_hostnames = enforce_hostnames
        self.allow_ip_sans = allow_ip_sans
        self.allowed_uri_sans = allowed_uri_sans
        self.allowed_other_sans = allowed_other_sans
        self.server_flag = server_flag
        self.client_flag = client_flag
        self.code_signing_flag = code_signing_flag
        self.email_protection_flag = email_protection_flag
        self.key_type = key_type
        self.key_bits = key_bits
        self.key_usage = key_usage
        self.ext_key_usage = ext_key_usage
        self.ext_key_usage_oids = ext_key_usage_oids
        self.use_csr_common_name = use_csr_common_name
        self.use_csr_sans = use_csr_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.require_cn = require_cn
        self.policy_identifiers = policy_identifiers
        self.basic_constraints_valid_for_non_ca = basic_constraints_valid_for_non_ca
        self.not_before_duration = not_before_duration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplatePatch':
        """Initialize a PrivateCertificateConfigurationTemplatePatch object from a json dictionary."""
        args = {}
        if 'allowed_secret_groups' in _dict:
            args['allowed_secret_groups'] = _dict.get('allowed_secret_groups')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'allow_localhost' in _dict:
            args['allow_localhost'] = _dict.get('allow_localhost')
        if 'allowed_domains' in _dict:
            args['allowed_domains'] = _dict.get('allowed_domains')
        if 'allowed_domains_template' in _dict:
            args['allowed_domains_template'] = _dict.get('allowed_domains_template')
        if 'allow_bare_domains' in _dict:
            args['allow_bare_domains'] = _dict.get('allow_bare_domains')
        if 'allow_subdomains' in _dict:
            args['allow_subdomains'] = _dict.get('allow_subdomains')
        if 'allow_glob_domains' in _dict:
            args['allow_glob_domains'] = _dict.get('allow_glob_domains')
        if 'allow_any_name' in _dict:
            args['allow_any_name'] = _dict.get('allow_any_name')
        if 'enforce_hostnames' in _dict:
            args['enforce_hostnames'] = _dict.get('enforce_hostnames')
        if 'allow_ip_sans' in _dict:
            args['allow_ip_sans'] = _dict.get('allow_ip_sans')
        if 'allowed_uri_sans' in _dict:
            args['allowed_uri_sans'] = _dict.get('allowed_uri_sans')
        if 'allowed_other_sans' in _dict:
            args['allowed_other_sans'] = _dict.get('allowed_other_sans')
        if 'server_flag' in _dict:
            args['server_flag'] = _dict.get('server_flag')
        if 'client_flag' in _dict:
            args['client_flag'] = _dict.get('client_flag')
        if 'code_signing_flag' in _dict:
            args['code_signing_flag'] = _dict.get('code_signing_flag')
        if 'email_protection_flag' in _dict:
            args['email_protection_flag'] = _dict.get('email_protection_flag')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'key_usage' in _dict:
            args['key_usage'] = _dict.get('key_usage')
        if 'ext_key_usage' in _dict:
            args['ext_key_usage'] = _dict.get('ext_key_usage')
        if 'ext_key_usage_oids' in _dict:
            args['ext_key_usage_oids'] = _dict.get('ext_key_usage_oids')
        if 'use_csr_common_name' in _dict:
            args['use_csr_common_name'] = _dict.get('use_csr_common_name')
        if 'use_csr_sans' in _dict:
            args['use_csr_sans'] = _dict.get('use_csr_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'require_cn' in _dict:
            args['require_cn'] = _dict.get('require_cn')
        if 'policy_identifiers' in _dict:
            args['policy_identifiers'] = _dict.get('policy_identifiers')
        if 'basic_constraints_valid_for_non_ca' in _dict:
            args['basic_constraints_valid_for_non_ca'] = _dict.get('basic_constraints_valid_for_non_ca')
        if 'not_before_duration' in _dict:
            args['not_before_duration'] = _dict.get('not_before_duration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplatePatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'allowed_secret_groups') and self.allowed_secret_groups is not None:
            _dict['allowed_secret_groups'] = self.allowed_secret_groups
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'allow_localhost') and self.allow_localhost is not None:
            _dict['allow_localhost'] = self.allow_localhost
        if hasattr(self, 'allowed_domains') and self.allowed_domains is not None:
            _dict['allowed_domains'] = self.allowed_domains
        if hasattr(self, 'allowed_domains_template') and self.allowed_domains_template is not None:
            _dict['allowed_domains_template'] = self.allowed_domains_template
        if hasattr(self, 'allow_bare_domains') and self.allow_bare_domains is not None:
            _dict['allow_bare_domains'] = self.allow_bare_domains
        if hasattr(self, 'allow_subdomains') and self.allow_subdomains is not None:
            _dict['allow_subdomains'] = self.allow_subdomains
        if hasattr(self, 'allow_glob_domains') and self.allow_glob_domains is not None:
            _dict['allow_glob_domains'] = self.allow_glob_domains
        if hasattr(self, 'allow_any_name') and self.allow_any_name is not None:
            _dict['allow_any_name'] = self.allow_any_name
        if hasattr(self, 'enforce_hostnames') and self.enforce_hostnames is not None:
            _dict['enforce_hostnames'] = self.enforce_hostnames
        if hasattr(self, 'allow_ip_sans') and self.allow_ip_sans is not None:
            _dict['allow_ip_sans'] = self.allow_ip_sans
        if hasattr(self, 'allowed_uri_sans') and self.allowed_uri_sans is not None:
            _dict['allowed_uri_sans'] = self.allowed_uri_sans
        if hasattr(self, 'allowed_other_sans') and self.allowed_other_sans is not None:
            _dict['allowed_other_sans'] = self.allowed_other_sans
        if hasattr(self, 'server_flag') and self.server_flag is not None:
            _dict['server_flag'] = self.server_flag
        if hasattr(self, 'client_flag') and self.client_flag is not None:
            _dict['client_flag'] = self.client_flag
        if hasattr(self, 'code_signing_flag') and self.code_signing_flag is not None:
            _dict['code_signing_flag'] = self.code_signing_flag
        if hasattr(self, 'email_protection_flag') and self.email_protection_flag is not None:
            _dict['email_protection_flag'] = self.email_protection_flag
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'key_usage') and self.key_usage is not None:
            _dict['key_usage'] = self.key_usage
        if hasattr(self, 'ext_key_usage') and self.ext_key_usage is not None:
            _dict['ext_key_usage'] = self.ext_key_usage
        if hasattr(self, 'ext_key_usage_oids') and self.ext_key_usage_oids is not None:
            _dict['ext_key_usage_oids'] = self.ext_key_usage_oids
        if hasattr(self, 'use_csr_common_name') and self.use_csr_common_name is not None:
            _dict['use_csr_common_name'] = self.use_csr_common_name
        if hasattr(self, 'use_csr_sans') and self.use_csr_sans is not None:
            _dict['use_csr_sans'] = self.use_csr_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'require_cn') and self.require_cn is not None:
            _dict['require_cn'] = self.require_cn
        if hasattr(self, 'policy_identifiers') and self.policy_identifiers is not None:
            _dict['policy_identifiers'] = self.policy_identifiers
        if hasattr(self, 'basic_constraints_valid_for_non_ca') and self.basic_constraints_valid_for_non_ca is not None:
            _dict['basic_constraints_valid_for_non_ca'] = self.basic_constraints_valid_for_non_ca
        if hasattr(self, 'not_before_duration') and self.not_before_duration is not None:
            _dict['not_before_duration'] = self.not_before_duration
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplatePatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplatePatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplatePatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationTemplatePrototype(ConfigurationPrototype):
    """
    Properties that describe a certificate template. You can use a certificate template to
    control the parameters that are applied to your issued private certificates. For more
    information, see the
    [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-certificate-templates).

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str certificate_authority: The name of the intermediate certificate
          authority.
    :param str allowed_secret_groups: (optional) This field scopes the creation of
          private certificates to only the secret groups that you specify.
          This field can be supplied as a comma-delimited list of secret group IDs.
    :param str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :param str ttl: (optional) The requested time-to-live (TTL) for certificates
          that are created by this CA. This field's value can't be longer than the
          `max_ttl` limit.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
    :param bool allow_localhost: (optional) This field indicates whether to allow
          `localhost` to be included as one of the requested common names.
    :param List[str] allowed_domains: (optional) The domains to define for the
          certificate template. This property is used along with the `allow_bare_domains`
          and `allow_subdomains` options.
    :param bool allowed_domains_template: (optional) This field indicates whether to
          allow the domains that are supplied in the `allowed_domains` field to contain
          access control list (ACL) templates.
    :param bool allow_bare_domains: (optional) This field indicates whether to allow
          clients to request private certificates that match the value of the actual
          domains on the final certificate.
          For example, if you specify `example.com` in the `allowed_domains` field, you
          grant clients the ability to request a certificate that contains the name
          `example.com` as one of the DNS values on the final certificate.
          **Important:** In some scenarios, allowing bare domains can be considered a
          security risk.
    :param bool allow_subdomains: (optional) This field indicates whether to allow
          clients to request private certificates with common names (CN) that are
          subdomains of the CNs that are allowed by the other certificate template
          options. This includes wildcard subdomains.
          For example, if `allowed_domains` has a value of `example.com` and
          `allow_subdomains`is set to `true`, then the following subdomains are allowed:
          `foo.example.com`, `bar.example.com`, `*.example.com`.
          **Note:** This field is redundant if you use the `allow_any_name` option.
    :param bool allow_glob_domains: (optional) This field indicates whether to allow
          glob patterns, for example, `ftp*.example.com`, in the names that are specified
          in the `allowed_domains` field.
          If set to `true`, clients are allowed to request private certificates with names
          that match the glob patterns.
    :param bool allow_wildcard_certificates: (optional) This field indicates whether
          the issuance of certificates with RFC 6125 wildcards in the CN field.
          When set to false, this field prevents wildcards from being issued even if they
          can be allowed by an option `allow_glob_domains`.
    :param bool allow_any_name: (optional) This field indicates whether to allow
          clients to request a private certificate that matches any common name.
    :param bool enforce_hostnames: (optional) This field indicates whether to
          enforce only valid hostnames for common names, DNS Subject Alternative Names,
          and the host section of email addresses.
    :param bool allow_ip_sans: (optional) This field indicates whether to allow
          clients to request a private certificate with IP Subject Alternative Names.
    :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative Names
          to allow for private certificates.
          Values can contain glob patterns, for example `spiffe://hostname/*`.
    :param List[str] allowed_other_sans: (optional) The custom Object Identifier
          (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private
          certificates.
          The format for each element in the list is the same as OpenSSL:
          `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
          value for an OID, use `*` as its value. Alternatively, specify a single `*` to
          allow any `other_sans` input.
    :param bool server_flag: (optional) This field indicates whether private
          certificates are flagged for server use.
    :param bool client_flag: (optional) This field indicates whether private
          certificates are flagged for client use.
    :param bool code_signing_flag: (optional) This field indicates whether private
          certificates are flagged for code signing use.
    :param bool email_protection_flag: (optional) This field indicates whether
          private certificates are flagged for email protection use.
    :param str key_type: (optional) The type of private key to generate.
    :param int key_bits: (optional) The number of bits to use to generate the
          private key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :param List[str] key_usage: (optional) The allowed key usage constraint to
          define for private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage`
          part of the value. Values are not case-sensitive. To specify no key usage
          constraints, set this field to an empty list.
    :param List[str] ext_key_usage: (optional) The allowed extended key usage
          constraint on private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
          `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no
          key usage constraints, set this field to an empty list.
    :param List[str] ext_key_usage_oids: (optional) A list of extended key usage
          Object Identifiers (OIDs).
    :param bool use_csr_common_name: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the common name (CN) from a certificate signing request (CSR)
          instead of the CN that is included in the data of the certificate.
          Does not include any requested Subject Alternative Names (SANs) in the CSR. To
          use the alternative names, include the `use_csr_sans` property.
    :param bool use_csr_sans: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the Subject Alternative Names
          (SANs) from a certificate signing request (CSR) instead of the SANs that are
          included in the data of the certificate.
          This field does not include the common name in the CSR. To use the common name,
          include the `use_csr_common_name` property.
    :param List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :param List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :param List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :param List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :param List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :param List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :param List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :param str serial_number: (optional) This field is deprecated. You can ignore
          its value.
    :param bool require_cn: (optional) This field indicates whether to require a
          common name to create a private certificate.
          By default, a common name is required to generate a certificate. To make the
          `common_name` field optional, set the `require_cn` option to `false`.
    :param List[str] policy_identifiers: (optional) A list of policy Object
          Identifiers (OIDs).
    :param bool basic_constraints_valid_for_non_ca: (optional) This field indicates
          whether to mark the Basic Constraints extension of an issued private certificate
          as valid for non-CA certificates.
    :param str not_before_duration: (optional) The duration in seconds by which to
          backdate the `not_before` property of an issued private certificate.
          The value can be supplied as a string representation of a duration, such as
          `30s`. In the API response, this value is returned in seconds (integer).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        certificate_authority: str,
        *,
        allowed_secret_groups: Optional[str] = None,
        max_ttl: Optional[str] = None,
        ttl: Optional[str] = None,
        allow_localhost: Optional[bool] = None,
        allowed_domains: Optional[List[str]] = None,
        allowed_domains_template: Optional[bool] = None,
        allow_bare_domains: Optional[bool] = None,
        allow_subdomains: Optional[bool] = None,
        allow_glob_domains: Optional[bool] = None,
        allow_wildcard_certificates: Optional[bool] = None,
        allow_any_name: Optional[bool] = None,
        enforce_hostnames: Optional[bool] = None,
        allow_ip_sans: Optional[bool] = None,
        allowed_uri_sans: Optional[List[str]] = None,
        allowed_other_sans: Optional[List[str]] = None,
        server_flag: Optional[bool] = None,
        client_flag: Optional[bool] = None,
        code_signing_flag: Optional[bool] = None,
        email_protection_flag: Optional[bool] = None,
        key_type: Optional[str] = None,
        key_bits: Optional[int] = None,
        key_usage: Optional[List[str]] = None,
        ext_key_usage: Optional[List[str]] = None,
        ext_key_usage_oids: Optional[List[str]] = None,
        use_csr_common_name: Optional[bool] = None,
        use_csr_sans: Optional[bool] = None,
        ou: Optional[List[str]] = None,
        organization: Optional[List[str]] = None,
        country: Optional[List[str]] = None,
        locality: Optional[List[str]] = None,
        province: Optional[List[str]] = None,
        street_address: Optional[List[str]] = None,
        postal_code: Optional[List[str]] = None,
        serial_number: Optional[str] = None,
        require_cn: Optional[bool] = None,
        policy_identifiers: Optional[List[str]] = None,
        basic_constraints_valid_for_non_ca: Optional[bool] = None,
        not_before_duration: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplatePrototype object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str certificate_authority: The name of the intermediate certificate
               authority.
        :param str allowed_secret_groups: (optional) This field scopes the creation
               of private certificates to only the secret groups that you specify.
               This field can be supplied as a comma-delimited list of secret group IDs.
        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str ttl: (optional) The requested time-to-live (TTL) for
               certificates that are created by this CA. This field's value can't be
               longer than the `max_ttl` limit.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
        :param bool allow_localhost: (optional) This field indicates whether to
               allow `localhost` to be included as one of the requested common names.
        :param List[str] allowed_domains: (optional) The domains to define for the
               certificate template. This property is used along with the
               `allow_bare_domains` and `allow_subdomains` options.
        :param bool allowed_domains_template: (optional) This field indicates
               whether to allow the domains that are supplied in the `allowed_domains`
               field to contain access control list (ACL) templates.
        :param bool allow_bare_domains: (optional) This field indicates whether to
               allow clients to request private certificates that match the value of the
               actual domains on the final certificate.
               For example, if you specify `example.com` in the `allowed_domains` field,
               you grant clients the ability to request a certificate that contains the
               name `example.com` as one of the DNS values on the final certificate.
               **Important:** In some scenarios, allowing bare domains can be considered a
               security risk.
        :param bool allow_subdomains: (optional) This field indicates whether to
               allow clients to request private certificates with common names (CN) that
               are subdomains of the CNs that are allowed by the other certificate
               template options. This includes wildcard subdomains.
               For example, if `allowed_domains` has a value of `example.com` and
               `allow_subdomains`is set to `true`, then the following subdomains are
               allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.
               **Note:** This field is redundant if you use the `allow_any_name` option.
        :param bool allow_glob_domains: (optional) This field indicates whether to
               allow glob patterns, for example, `ftp*.example.com`, in the names that are
               specified in the `allowed_domains` field.
               If set to `true`, clients are allowed to request private certificates with
               names that match the glob patterns.
        :param bool allow_wildcard_certificates: (optional) This field indicates
               whether the issuance of certificates with RFC 6125 wildcards in the CN
               field.
               When set to false, this field prevents wildcards from being issued even if
               they can be allowed by an option `allow_glob_domains`.
        :param bool allow_any_name: (optional) This field indicates whether to
               allow clients to request a private certificate that matches any common
               name.
        :param bool enforce_hostnames: (optional) This field indicates whether to
               enforce only valid hostnames for common names, DNS Subject Alternative
               Names, and the host section of email addresses.
        :param bool allow_ip_sans: (optional) This field indicates whether to allow
               clients to request a private certificate with IP Subject Alternative Names.
        :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative
               Names to allow for private certificates.
               Values can contain glob patterns, for example `spiffe://hostname/*`.
        :param List[str] allowed_other_sans: (optional) The custom Object
               Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow
               for private certificates.
               The format for each element in the list is the same as OpenSSL:
               `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
               value for an OID, use `*` as its value. Alternatively, specify a single `*`
               to allow any `other_sans` input.
        :param bool server_flag: (optional) This field indicates whether private
               certificates are flagged for server use.
        :param bool client_flag: (optional) This field indicates whether private
               certificates are flagged for client use.
        :param bool code_signing_flag: (optional) This field indicates whether
               private certificates are flagged for code signing use.
        :param bool email_protection_flag: (optional) This field indicates whether
               private certificates are flagged for email protection use.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param List[str] key_usage: (optional) The allowed key usage constraint to
               define for private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the
               `KeyUsage` part of the value. Values are not case-sensitive. To specify no
               key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage: (optional) The allowed extended key usage
               constraint on private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
               `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify
               no key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage_oids: (optional) A list of extended key
               usage Object Identifiers (OIDs).
        :param bool use_csr_common_name: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the common name (CN) from a certificate signing request
               (CSR) instead of the CN that is included in the data of the certificate.
               Does not include any requested Subject Alternative Names (SANs) in the CSR.
               To use the alternative names, include the `use_csr_sans` property.
        :param bool use_csr_sans: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the Subject Alternative Names
               (SANs) from a certificate signing request (CSR) instead of the SANs that
               are included in the data of the certificate.
               This field does not include the common name in the CSR. To use the common
               name, include the `use_csr_common_name` property.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) This field is deprecated. You can
               ignore its value.
        :param bool require_cn: (optional) This field indicates whether to require
               a common name to create a private certificate.
               By default, a common name is required to generate a certificate. To make
               the `common_name` field optional, set the `require_cn` option to `false`.
        :param List[str] policy_identifiers: (optional) A list of policy Object
               Identifiers (OIDs).
        :param bool basic_constraints_valid_for_non_ca: (optional) This field
               indicates whether to mark the Basic Constraints extension of an issued
               private certificate as valid for non-CA certificates.
        :param str not_before_duration: (optional) The duration in seconds by which
               to backdate the `not_before` property of an issued private certificate.
               The value can be supplied as a string representation of a duration, such as
               `30s`. In the API response, this value is returned in seconds (integer).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.certificate_authority = certificate_authority
        self.allowed_secret_groups = allowed_secret_groups
        self.max_ttl = max_ttl
        self.ttl = ttl
        self.allow_localhost = allow_localhost
        self.allowed_domains = allowed_domains
        self.allowed_domains_template = allowed_domains_template
        self.allow_bare_domains = allow_bare_domains
        self.allow_subdomains = allow_subdomains
        self.allow_glob_domains = allow_glob_domains
        self.allow_wildcard_certificates = allow_wildcard_certificates
        self.allow_any_name = allow_any_name
        self.enforce_hostnames = enforce_hostnames
        self.allow_ip_sans = allow_ip_sans
        self.allowed_uri_sans = allowed_uri_sans
        self.allowed_other_sans = allowed_other_sans
        self.server_flag = server_flag
        self.client_flag = client_flag
        self.code_signing_flag = code_signing_flag
        self.email_protection_flag = email_protection_flag
        self.key_type = key_type
        self.key_bits = key_bits
        self.key_usage = key_usage
        self.ext_key_usage = ext_key_usage
        self.ext_key_usage_oids = ext_key_usage_oids
        self.use_csr_common_name = use_csr_common_name
        self.use_csr_sans = use_csr_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.require_cn = require_cn
        self.policy_identifiers = policy_identifiers
        self.basic_constraints_valid_for_non_ca = basic_constraints_valid_for_non_ca
        self.not_before_duration = not_before_duration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplatePrototype':
        """Initialize a PrivateCertificateConfigurationTemplatePrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationTemplatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationTemplatePrototype JSON')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        else:
            raise ValueError('Required property \'certificate_authority\' not present in PrivateCertificateConfigurationTemplatePrototype JSON')
        if 'allowed_secret_groups' in _dict:
            args['allowed_secret_groups'] = _dict.get('allowed_secret_groups')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'allow_localhost' in _dict:
            args['allow_localhost'] = _dict.get('allow_localhost')
        if 'allowed_domains' in _dict:
            args['allowed_domains'] = _dict.get('allowed_domains')
        if 'allowed_domains_template' in _dict:
            args['allowed_domains_template'] = _dict.get('allowed_domains_template')
        if 'allow_bare_domains' in _dict:
            args['allow_bare_domains'] = _dict.get('allow_bare_domains')
        if 'allow_subdomains' in _dict:
            args['allow_subdomains'] = _dict.get('allow_subdomains')
        if 'allow_glob_domains' in _dict:
            args['allow_glob_domains'] = _dict.get('allow_glob_domains')
        if 'allow_wildcard_certificates' in _dict:
            args['allow_wildcard_certificates'] = _dict.get('allow_wildcard_certificates')
        if 'allow_any_name' in _dict:
            args['allow_any_name'] = _dict.get('allow_any_name')
        if 'enforce_hostnames' in _dict:
            args['enforce_hostnames'] = _dict.get('enforce_hostnames')
        if 'allow_ip_sans' in _dict:
            args['allow_ip_sans'] = _dict.get('allow_ip_sans')
        if 'allowed_uri_sans' in _dict:
            args['allowed_uri_sans'] = _dict.get('allowed_uri_sans')
        if 'allowed_other_sans' in _dict:
            args['allowed_other_sans'] = _dict.get('allowed_other_sans')
        if 'server_flag' in _dict:
            args['server_flag'] = _dict.get('server_flag')
        if 'client_flag' in _dict:
            args['client_flag'] = _dict.get('client_flag')
        if 'code_signing_flag' in _dict:
            args['code_signing_flag'] = _dict.get('code_signing_flag')
        if 'email_protection_flag' in _dict:
            args['email_protection_flag'] = _dict.get('email_protection_flag')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'key_usage' in _dict:
            args['key_usage'] = _dict.get('key_usage')
        if 'ext_key_usage' in _dict:
            args['ext_key_usage'] = _dict.get('ext_key_usage')
        if 'ext_key_usage_oids' in _dict:
            args['ext_key_usage_oids'] = _dict.get('ext_key_usage_oids')
        if 'use_csr_common_name' in _dict:
            args['use_csr_common_name'] = _dict.get('use_csr_common_name')
        if 'use_csr_sans' in _dict:
            args['use_csr_sans'] = _dict.get('use_csr_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'require_cn' in _dict:
            args['require_cn'] = _dict.get('require_cn')
        if 'policy_identifiers' in _dict:
            args['policy_identifiers'] = _dict.get('policy_identifiers')
        if 'basic_constraints_valid_for_non_ca' in _dict:
            args['basic_constraints_valid_for_non_ca'] = _dict.get('basic_constraints_valid_for_non_ca')
        if 'not_before_duration' in _dict:
            args['not_before_duration'] = _dict.get('not_before_duration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'certificate_authority') and self.certificate_authority is not None:
            _dict['certificate_authority'] = self.certificate_authority
        if hasattr(self, 'allowed_secret_groups') and self.allowed_secret_groups is not None:
            _dict['allowed_secret_groups'] = self.allowed_secret_groups
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'allow_localhost') and self.allow_localhost is not None:
            _dict['allow_localhost'] = self.allow_localhost
        if hasattr(self, 'allowed_domains') and self.allowed_domains is not None:
            _dict['allowed_domains'] = self.allowed_domains
        if hasattr(self, 'allowed_domains_template') and self.allowed_domains_template is not None:
            _dict['allowed_domains_template'] = self.allowed_domains_template
        if hasattr(self, 'allow_bare_domains') and self.allow_bare_domains is not None:
            _dict['allow_bare_domains'] = self.allow_bare_domains
        if hasattr(self, 'allow_subdomains') and self.allow_subdomains is not None:
            _dict['allow_subdomains'] = self.allow_subdomains
        if hasattr(self, 'allow_glob_domains') and self.allow_glob_domains is not None:
            _dict['allow_glob_domains'] = self.allow_glob_domains
        if hasattr(self, 'allow_wildcard_certificates') and self.allow_wildcard_certificates is not None:
            _dict['allow_wildcard_certificates'] = self.allow_wildcard_certificates
        if hasattr(self, 'allow_any_name') and self.allow_any_name is not None:
            _dict['allow_any_name'] = self.allow_any_name
        if hasattr(self, 'enforce_hostnames') and self.enforce_hostnames is not None:
            _dict['enforce_hostnames'] = self.enforce_hostnames
        if hasattr(self, 'allow_ip_sans') and self.allow_ip_sans is not None:
            _dict['allow_ip_sans'] = self.allow_ip_sans
        if hasattr(self, 'allowed_uri_sans') and self.allowed_uri_sans is not None:
            _dict['allowed_uri_sans'] = self.allowed_uri_sans
        if hasattr(self, 'allowed_other_sans') and self.allowed_other_sans is not None:
            _dict['allowed_other_sans'] = self.allowed_other_sans
        if hasattr(self, 'server_flag') and self.server_flag is not None:
            _dict['server_flag'] = self.server_flag
        if hasattr(self, 'client_flag') and self.client_flag is not None:
            _dict['client_flag'] = self.client_flag
        if hasattr(self, 'code_signing_flag') and self.code_signing_flag is not None:
            _dict['code_signing_flag'] = self.code_signing_flag
        if hasattr(self, 'email_protection_flag') and self.email_protection_flag is not None:
            _dict['email_protection_flag'] = self.email_protection_flag
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'key_usage') and self.key_usage is not None:
            _dict['key_usage'] = self.key_usage
        if hasattr(self, 'ext_key_usage') and self.ext_key_usage is not None:
            _dict['ext_key_usage'] = self.ext_key_usage
        if hasattr(self, 'ext_key_usage_oids') and self.ext_key_usage_oids is not None:
            _dict['ext_key_usage_oids'] = self.ext_key_usage_oids
        if hasattr(self, 'use_csr_common_name') and self.use_csr_common_name is not None:
            _dict['use_csr_common_name'] = self.use_csr_common_name
        if hasattr(self, 'use_csr_sans') and self.use_csr_sans is not None:
            _dict['use_csr_sans'] = self.use_csr_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'require_cn') and self.require_cn is not None:
            _dict['require_cn'] = self.require_cn
        if hasattr(self, 'policy_identifiers') and self.policy_identifiers is not None:
            _dict['policy_identifiers'] = self.policy_identifiers
        if hasattr(self, 'basic_constraints_valid_for_non_ca') and self.basic_constraints_valid_for_non_ca is not None:
            _dict['basic_constraints_valid_for_non_ca'] = self.basic_constraints_valid_for_non_ca
        if hasattr(self, 'not_before_duration') and self.not_before_duration is not None:
            _dict['not_before_duration'] = self.not_before_duration
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateMetadata(SecretMetadata):
    """
    Properties of the metadata of your private certificate.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str signing_algorithm: The identifier for the cryptographic algorithm
          that is used by the issuing certificate authority to sign a certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str certificate_authority: (optional) The intermediate certificate
          authority that signed this certificate.
    :param str certificate_template: The name of the certificate template.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :param str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :param int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    :param datetime revocation_time_rfc3339: (optional) The date and time that the
          certificate was revoked. The date format follows `RFC 3339`.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        certificate_template: str,
        common_name: str,
        expiration_date: datetime,
        issuer: str,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        certificate_authority: Optional[str] = None,
        key_algorithm: Optional[str] = None,
        next_rotation_date: Optional[datetime] = None,
        rotation: Optional['RotationPolicy'] = None,
        revocation_time_seconds: Optional[int] = None,
        revocation_time_rfc3339: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param str certificate_template: The name of the certificate template.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.certificate_authority = certificate_authority
        self.certificate_template = certificate_template
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.next_rotation_date = next_rotation_date
        self.rotation = rotation
        self.serial_number = serial_number
        self.validity = validity
        self.revocation_time_seconds = revocation_time_seconds
        self.revocation_time_rfc3339 = revocation_time_rfc3339

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateMetadata':
        """Initialize a PrivateCertificateMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PrivateCertificateMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificateMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PrivateCertificateMetadata JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in PrivateCertificateMetadata JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        if 'certificate_template' in _dict:
            args['certificate_template'] = _dict.get('certificate_template')
        else:
            raise ValueError('Required property \'certificate_template\' not present in PrivateCertificateMetadata JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificateMetadata JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in PrivateCertificateMetadata JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificateMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificateMetadata JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        if 'revocation_time_rfc3339' in _dict:
            args['revocation_time_rfc3339'] = string_to_datetime(_dict.get('revocation_time_rfc3339'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'certificate_authority') and getattr(self, 'certificate_authority') is not None:
            _dict['certificate_authority'] = getattr(self, 'certificate_authority')
        if hasattr(self, 'certificate_template') and self.certificate_template is not None:
            _dict['certificate_template'] = self.certificate_template
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        if hasattr(self, 'revocation_time_rfc3339') and getattr(self, 'revocation_time_rfc3339') is not None:
            _dict['revocation_time_rfc3339'] = datetime_to_string(getattr(self, 'revocation_time_rfc3339'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PrivateCertificateMetadataPatch(SecretMetadataPatch):
    """
    PrivateCertificateMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
        rotation: Optional['RotationPolicy'] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateMetadataPatch':
        """Initialize a PrivateCertificateMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificatePrototype(SecretPrototype):
    """
    PrivateCertificatePrototype.

    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str certificate_template: The name of the certificate template.
    :param str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str ip_sans: (optional) The IP Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :param List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :param str csr: (optional) The certificate signing request.
    :param str format: (optional) The format of the returned data.
    :param str private_key_format: (optional) The format of the generated private
          key.
    :param bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :param str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        certificate_template: str,
        common_name: str,
        *,
        description: Optional[str] = None,
        secret_group_id: Optional[str] = None,
        labels: Optional[List[str]] = None,
        alt_names: Optional[List[str]] = None,
        ip_sans: Optional[str] = None,
        uri_sans: Optional[str] = None,
        other_sans: Optional[List[str]] = None,
        csr: Optional[str] = None,
        format: Optional[str] = None,
        private_key_format: Optional[str] = None,
        exclude_cn_from_sans: Optional[bool] = None,
        ttl: Optional[str] = None,
        rotation: Optional['RotationPolicy'] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a PrivateCertificatePrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str certificate_template: The name of the certificate template.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str csr: (optional) The certificate signing request.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.certificate_template = certificate_template
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.csr = csr
        self.format = format
        self.private_key_format = private_key_format
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.ttl = ttl
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificatePrototype':
        """Initialize a PrivateCertificatePrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificatePrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'certificate_template' in _dict:
            args['certificate_template'] = _dict.get('certificate_template')
        else:
            raise ValueError('Required property \'certificate_template\' not present in PrivateCertificatePrototype JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificatePrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'certificate_template') and self.certificate_template is not None:
            _dict['certificate_template'] = self.certificate_template
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'



class PrivateCertificateVersion(SecretVersion):
    """
    Your private certificate version.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :param str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :param str private_key: The PEM-encoded private key that is associated with the
          certificate. The data must be formatted on a single line with embedded newline
          characters.
    :param str issuing_ca: (optional) The PEM-encoded certificate of the certificate
          authority that signed and issued this certificate.
    :param List[str] ca_chain: (optional) The chain of certificate authorities that
          are associated with the certificate.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        private_key: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        issuing_ca: Optional[str] = None,
        ca_chain: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: The PEM-encoded private key that is associated with
               the certificate. The data must be formatted on a single line with embedded
               newline characters.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.private_key = private_key
        self.issuing_ca = issuing_ca
        self.ca_chain = ca_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersion':
        """Initialize a PrivateCertificateVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificateVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificateVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PrivateCertificateVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PrivateCertificateVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificateVersion JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificateVersion JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificateVersion JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateVersion JSON')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        else:
            raise ValueError('Required property \'private_key\' not present in PrivateCertificateVersion JSON')
        if 'issuing_ca' in _dict:
            args['issuing_ca'] = _dict.get('issuing_ca')
        if 'ca_chain' in _dict:
            args['ca_chain'] = _dict.get('ca_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'issuing_ca') and getattr(self, 'issuing_ca') is not None:
            _dict['issuing_ca'] = getattr(self, 'issuing_ca')
        if hasattr(self, 'ca_chain') and getattr(self, 'ca_chain') is not None:
            _dict['ca_chain'] = getattr(self, 'ca_chain')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PrivateCertificateVersionActionRevoke(VersionAction):
    """
    The response body to specify the properties of the action to revoke the private
    certificate.

    :param str action_type: The type of secret version action.
    :param int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    """

    def __init__(
        self,
        action_type: str,
        *,
        revocation_time_seconds: Optional[int] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionActionRevoke object.

        :param str action_type: The type of secret version action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.revocation_time_seconds = revocation_time_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionActionRevoke':
        """Initialize a PrivateCertificateVersionActionRevoke object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateVersionActionRevoke JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionActionRevoke object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionActionRevoke object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionActionRevoke') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionActionRevoke') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret version action.
        """

        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateVersionActionRevokePrototype(SecretVersionActionPrototype):
    """
    The request body to specify the properties of the action to revoke the private
    certificate.

    :param str action_type: The type of secret version action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionActionRevokePrototype object.

        :param str action_type: The type of secret version action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionActionRevokePrototype':
        """Initialize a PrivateCertificateVersionActionRevokePrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateVersionActionRevokePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionActionRevokePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionActionRevokePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionActionRevokePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionActionRevokePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret version action.
        """

        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your private certificate.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :param str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :param CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionMetadata':
        """Initialize a PrivateCertificateVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificateVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificateVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PrivateCertificateVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PrivateCertificateVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificateVersionMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificateVersionMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificateVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PrivateCertificateVersionPrototype(SecretVersionPrototype):
    """
    PrivateCertificateVersionPrototype.

    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str csr: (optional) The certificate signing request.
    """

    def __init__(
        self,
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
        csr: Optional[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionPrototype object.

        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str csr: (optional) The certificate signing request.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata
        self.csr = csr

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionPrototype':
        """Initialize a PrivateCertificateVersionPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificate(Secret):
    """
    Your public certificate.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str signing_algorithm: (optional) The identifier for the cryptographic
          algorithm that is used by the issuing certificate authority to sign a
          certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str common_name: The Common Name (CN) represents the server name
          protected by the SSL certificate.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param CertificateIssuanceInfo issuance_info: (optional) Issuance information
          that is associated with your certificate.
    :param str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :param str key_algorithm: The identifier for the cryptographic algorithm that is
          used to generate the public key that is associated with the certificate.
          The algorithm that you select determines the encryption algorithm (`RSA` or
          `ECDSA`) and key size to be used to generate keys and sign certificates. For
          longer living certificates, it is recommended to use longer keys to provide more
          encryption protection. Allowed values:  `RSA2048`, `RSA4096`, `ECDSA256`, and
          `ECDSA384`.
    :param str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :param CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    :param RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :param bool bundle_certs: (optional) Indicates whether the issued certificate is
          bundled with intermediate certificates.
    :param str ca: (optional) The name of the certificate authority configuration.
    :param str dns: (optional) The name of the DNS provider configuration.
    :param str certificate: (optional) Your PEM-encoded certificate. The data must
          be formatted on a single line with embedded newline characters.
    :param str intermediate: (optional) The PEM-encoded intermediate certificate
          that is associated with the root certificate. The data must be formatted on a
          single line with embedded newline characters.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        common_name: str,
        key_algorithm: str,
        rotation: 'RotationPolicy',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        signing_algorithm: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        expiration_date: Optional[datetime] = None,
        issuance_info: Optional['CertificateIssuanceInfo'] = None,
        issuer: Optional[str] = None,
        serial_number: Optional[str] = None,
        validity: Optional['CertificateValidity'] = None,
        bundle_certs: Optional[bool] = None,
        ca: Optional[str] = None,
        dns: Optional[str] = None,
        certificate: Optional[str] = None,
        intermediate: Optional[str] = None,
        private_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificate object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str common_name: The Common Name (CN) represents the server name
               protected by the SSL certificate.
        :param str key_algorithm: The identifier for the cryptographic algorithm
               that is used to generate the public key that is associated with the
               certificate.
               The algorithm that you select determines the encryption algorithm (`RSA` or
               `ECDSA`) and key size to be used to generate keys and sign certificates.
               For longer living certificates, it is recommended to use longer keys to
               provide more encryption protection. Allowed values:  `RSA2048`, `RSA4096`,
               `ECDSA256`, and `ECDSA384`.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str signing_algorithm: (optional) The identifier for the
               cryptographic algorithm that is used by the issuing certificate authority
               to sign a certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        :param str certificate: (optional) Your PEM-encoded certificate. The data
               must be formatted on a single line with embedded newline characters.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuance_info = issuance_info
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.serial_number = serial_number
        self.validity = validity
        self.rotation = rotation
        self.bundle_certs = bundle_certs
        self.ca = ca
        self.dns = dns
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificate':
        """Initialize a PublicCertificate object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificate JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PublicCertificate JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificate JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificate JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificate JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PublicCertificate JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PublicCertificate JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuance_info' in _dict:
            args['issuance_info'] = CertificateIssuanceInfo.from_dict(_dict.get('issuance_info'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        else:
            raise ValueError('Required property \'key_algorithm\' not present in PublicCertificate JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in PublicCertificate JSON')
        if 'bundle_certs' in _dict:
            args['bundle_certs'] = _dict.get('bundle_certs')
        if 'ca' in _dict:
            args['ca'] = _dict.get('ca')
        if 'dns' in _dict:
            args['dns'] = _dict.get('dns')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuance_info') and getattr(self, 'issuance_info') is not None:
            if isinstance(getattr(self, 'issuance_info'), dict):
                _dict['issuance_info'] = getattr(self, 'issuance_info')
            else:
                _dict['issuance_info'] = getattr(self, 'issuance_info').to_dict()
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and self.key_algorithm is not None:
            _dict['key_algorithm'] = self.key_algorithm
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'bundle_certs') and getattr(self, 'bundle_certs') is not None:
            _dict['bundle_certs'] = getattr(self, 'bundle_certs')
        if hasattr(self, 'ca') and getattr(self, 'ca') is not None:
            _dict['ca'] = getattr(self, 'ca')
        if hasattr(self, 'dns') and getattr(self, 'dns') is not None:
            _dict['dns'] = getattr(self, 'dns')
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PublicCertificateActionValidateManualDNS(SecretAction):
    """
    The response body of the action to validate manual DNS challenges for the public
    certificate.

    :param str action_type: The type of secret action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PublicCertificateActionValidateManualDNS object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateActionValidateManualDNS':
        """Initialize a PublicCertificateActionValidateManualDNS object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PublicCertificateActionValidateManualDNS JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateActionValidateManualDNS object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateActionValidateManualDNS object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateActionValidateManualDNS') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateActionValidateManualDNS') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PublicCertificateActionValidateManualDNSPrototype(SecretActionPrototype):
    """
    The request body to specify the properties of the action to validate manual DNS
    challenges for the public certificate.

    :param str action_type: The type of secret action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PublicCertificateActionValidateManualDNSPrototype object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateActionValidateManualDNSPrototype':
        """Initialize a PublicCertificateActionValidateManualDNSPrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PublicCertificateActionValidateManualDNSPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateActionValidateManualDNSPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateActionValidateManualDNSPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateActionValidateManualDNSPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateActionValidateManualDNSPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PublicCertificateConfigurationCALetsEncrypt(Configuration):
    """
    Properties that describe a Let's Encrypt CA configuration.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :param str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    :param str lets_encrypt_private_key: The PEM-encoded private key of your Let's
          Encrypt account. The data must be formatted on a single line with embedded
          newline characters.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        lets_encrypt_environment: str,
        lets_encrypt_private_key: str,
        *,
        lets_encrypt_preferred_chain: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncrypt object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_private_key: The PEM-encoded private key of your
               Let's Encrypt account. The data must be formatted on a single line with
               embedded newline characters.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain
        self.lets_encrypt_private_key = lets_encrypt_private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncrypt':
        """Initialize a PublicCertificateConfigurationCALetsEncrypt object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        if 'lets_encrypt_private_key' in _dict:
            args['lets_encrypt_private_key'] = _dict.get('lets_encrypt_private_key')
        else:
            raise ValueError('Required property \'lets_encrypt_private_key\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncrypt object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        if hasattr(self, 'lets_encrypt_private_key') and self.lets_encrypt_private_key is not None:
            _dict['lets_encrypt_private_key'] = self.lets_encrypt_private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncrypt object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncrypt') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncrypt') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationCALetsEncryptMetadata(ConfigurationMetadata):
    """
    Your Let's Encrypt CA metadata properties.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :param str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        lets_encrypt_environment: str,
        *,
        lets_encrypt_preferred_chain: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncryptMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncryptMetadata':
        """Initialize a PublicCertificateConfigurationCALetsEncryptMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncryptMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncryptMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncryptMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncryptMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationCALetsEncryptPatch(ConfigurationPatch):
    """
    The configuration update of the Let's Encrypt Certificate Authority.

    :param str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :param str lets_encrypt_private_key: (optional) The PEM-encoded private key of
          your Let's Encrypt account. The data must be formatted on a single line with
          embedded newline characters.
    :param str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    """

    def __init__(
        self,
        lets_encrypt_environment: str,
        *,
        lets_encrypt_private_key: Optional[str] = None,
        lets_encrypt_preferred_chain: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncryptPatch object.

        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_private_key: (optional) The PEM-encoded private key
               of your Let's Encrypt account. The data must be formatted on a single line
               with embedded newline characters.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_private_key = lets_encrypt_private_key
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncryptPatch':
        """Initialize a PublicCertificateConfigurationCALetsEncryptPatch object from a json dictionary."""
        args = {}
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncryptPatch JSON')
        if 'lets_encrypt_private_key' in _dict:
            args['lets_encrypt_private_key'] = _dict.get('lets_encrypt_private_key')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncryptPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_private_key') and self.lets_encrypt_private_key is not None:
            _dict['lets_encrypt_private_key'] = self.lets_encrypt_private_key
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncryptPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncryptPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncryptPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationCALetsEncryptPrototype(ConfigurationPrototype):
    """
    The properties of the Let's Encrypt CA configuration.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :param str lets_encrypt_private_key: The PEM-encoded private key of your Let's
          Encrypt account. The data must be formatted on a single line with embedded
          newline characters.
    :param str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        lets_encrypt_environment: str,
        lets_encrypt_private_key: str,
        *,
        lets_encrypt_preferred_chain: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncryptPrototype object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_private_key: The PEM-encoded private key of your
               Let's Encrypt account. The data must be formatted on a single line with
               embedded newline characters.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_private_key = lets_encrypt_private_key
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncryptPrototype':
        """Initialize a PublicCertificateConfigurationCALetsEncryptPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'lets_encrypt_private_key' in _dict:
            args['lets_encrypt_private_key'] = _dict.get('lets_encrypt_private_key')
        else:
            raise ValueError('Required property \'lets_encrypt_private_key\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncryptPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_private_key') and self.lets_encrypt_private_key is not None:
            _dict['lets_encrypt_private_key'] = self.lets_encrypt_private_key
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncryptPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncryptPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncryptPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationDNSClassicInfrastructure(Configuration):
    """
    Properties that describe a Classic Infrastructure DNS configuration.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str classic_infrastructure_username: The username that is associated with
          your classic infrastructure account.
          In most cases, your classic infrastructure username is your
          `<account_id>_<email_address>`. For more information, see the
          [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    :param str classic_infrastructure_password: Your classic infrastructure API key.
          For information about viewing and accessing your classic infrastructure API key,
          see the [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        classic_infrastructure_username: str,
        classic_infrastructure_password: str,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructure object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str classic_infrastructure_username: The username that is associated
               with your classic infrastructure account.
               In most cases, your classic infrastructure username is your
               `<account_id>_<email_address>`. For more information, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        :param str classic_infrastructure_password: Your classic infrastructure API
               key.
               For information about viewing and accessing your classic infrastructure API
               key, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.classic_infrastructure_username = classic_infrastructure_username
        self.classic_infrastructure_password = classic_infrastructure_password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructure':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructure object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'classic_infrastructure_username' in _dict:
            args['classic_infrastructure_username'] = _dict.get('classic_infrastructure_username')
        else:
            raise ValueError('Required property \'classic_infrastructure_username\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'classic_infrastructure_password' in _dict:
            args['classic_infrastructure_password'] = _dict.get('classic_infrastructure_password')
        else:
            raise ValueError('Required property \'classic_infrastructure_password\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructure object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'classic_infrastructure_username') and self.classic_infrastructure_username is not None:
            _dict['classic_infrastructure_username'] = self.classic_infrastructure_username
        if hasattr(self, 'classic_infrastructure_password') and self.classic_infrastructure_password is not None:
            _dict['classic_infrastructure_password'] = self.classic_infrastructure_password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructure object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructure') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructure') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class PublicCertificateConfigurationDNSClassicInfrastructureMetadata(ConfigurationMetadata):
    """
    Your Classic Infrastructure DNS metadata properties.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructureMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructureMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructureMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructureMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class PublicCertificateConfigurationDNSClassicInfrastructurePatch(ConfigurationPatch):
    """
    Properties that describe the configuration update of an IBM Cloud classic
    infrastructure (SoftLayer).

    :param str classic_infrastructure_username: (optional) The username that is
          associated with your classic infrastructure account.
          In most cases, your classic infrastructure username is your
          `<account_id>_<email_address>`. For more information, see the
          [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    :param str classic_infrastructure_password: (optional) Your classic
          infrastructure API key.
          For information about viewing and accessing your classic infrastructure API key,
          see the [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    """

    def __init__(
        self,
        *,
        classic_infrastructure_username: Optional[str] = None,
        classic_infrastructure_password: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePatch object.

        :param str classic_infrastructure_username: (optional) The username that is
               associated with your classic infrastructure account.
               In most cases, your classic infrastructure username is your
               `<account_id>_<email_address>`. For more information, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        :param str classic_infrastructure_password: (optional) Your classic
               infrastructure API key.
               For information about viewing and accessing your classic infrastructure API
               key, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        """
        # pylint: disable=super-init-not-called
        self.classic_infrastructure_username = classic_infrastructure_username
        self.classic_infrastructure_password = classic_infrastructure_password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructurePatch':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePatch object from a json dictionary."""
        args = {}
        if 'classic_infrastructure_username' in _dict:
            args['classic_infrastructure_username'] = _dict.get('classic_infrastructure_username')
        if 'classic_infrastructure_password' in _dict:
            args['classic_infrastructure_password'] = _dict.get('classic_infrastructure_password')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'classic_infrastructure_username') and self.classic_infrastructure_username is not None:
            _dict['classic_infrastructure_username'] = self.classic_infrastructure_username
        if hasattr(self, 'classic_infrastructure_password') and self.classic_infrastructure_password is not None:
            _dict['classic_infrastructure_password'] = self.classic_infrastructure_password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructurePatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificateConfigurationDNSClassicInfrastructurePrototype(ConfigurationPrototype):
    """
    PublicCertificateConfigurationDNSClassicInfrastructurePrototype.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str classic_infrastructure_username: The username that is associated with
          your classic infrastructure account.
          In most cases, your classic infrastructure username is your
          `<account_id>_<email_address>`. For more information, see the
          [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    :param str classic_infrastructure_password: Your classic infrastructure API key.
          For information about viewing and accessing your classic infrastructure API key,
          see the [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        classic_infrastructure_username: str,
        classic_infrastructure_password: str,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePrototype object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str classic_infrastructure_username: The username that is associated
               with your classic infrastructure account.
               In most cases, your classic infrastructure username is your
               `<account_id>_<email_address>`. For more information, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        :param str classic_infrastructure_password: Your classic infrastructure API
               key.
               For information about viewing and accessing your classic infrastructure API
               key, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.classic_infrastructure_username = classic_infrastructure_username
        self.classic_infrastructure_password = classic_infrastructure_password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        if 'classic_infrastructure_username' in _dict:
            args['classic_infrastructure_username'] = _dict.get('classic_infrastructure_username')
        else:
            raise ValueError('Required property \'classic_infrastructure_username\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        if 'classic_infrastructure_password' in _dict:
            args['classic_infrastructure_password'] = _dict.get('classic_infrastructure_password')
        else:
            raise ValueError('Required property \'classic_infrastructure_password\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'classic_infrastructure_username') and self.classic_infrastructure_username is not None:
            _dict['classic_infrastructure_username'] = self.classic_infrastructure_username
        if hasattr(self, 'classic_infrastructure_password') and self.classic_infrastructure_password is not None:
            _dict['classic_infrastructure_password'] = self.classic_infrastructure_password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructurePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'



class PublicCertificateConfigurationDNSCloudInternetServices(Configuration):
    """
    Properties that describe a Cloud Internet Services DNS configuration.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param str cloud_internet_services_apikey: (optional) An IBM Cloud API key that
          can to list domains in your Cloud Internet Services instance.
          To grant Secrets Manager the ability to view the Cloud Internet Services
          instance and all of its domains, the API key must be assigned the Reader service
          role on Internet Services (`internet-svcs`).
          If you need to manage specific domains, you can assign the Manager role. For
          production environments, it is recommended that you assign the Reader access
          role, and then use the
          [IAM Policy Management
          API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
          control specific domains. For more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
    :param str cloud_internet_services_crn: A CRN that uniquely identifies an IBM
          Cloud resource.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        cloud_internet_services_crn: str,
        *,
        cloud_internet_services_apikey: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServices object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str cloud_internet_services_crn: A CRN that uniquely identifies an
               IBM Cloud resource.
        :param str cloud_internet_services_apikey: (optional) An IBM Cloud API key
               that can to list domains in your Cloud Internet Services instance.
               To grant Secrets Manager the ability to view the Cloud Internet Services
               instance and all of its domains, the API key must be assigned the Reader
               service role on Internet Services (`internet-svcs`).
               If you need to manage specific domains, you can assign the Manager role.
               For production environments, it is recommended that you assign the Reader
               access role, and then use the
               [IAM Policy Management
               API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
               control specific domains. For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.cloud_internet_services_apikey = cloud_internet_services_apikey
        self.cloud_internet_services_crn = cloud_internet_services_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServices':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServices object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'cloud_internet_services_apikey' in _dict:
            args['cloud_internet_services_apikey'] = _dict.get('cloud_internet_services_apikey')
        if 'cloud_internet_services_crn' in _dict:
            args['cloud_internet_services_crn'] = _dict.get('cloud_internet_services_crn')
        else:
            raise ValueError('Required property \'cloud_internet_services_crn\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServices object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'cloud_internet_services_apikey') and self.cloud_internet_services_apikey is not None:
            _dict['cloud_internet_services_apikey'] = self.cloud_internet_services_apikey
        if hasattr(self, 'cloud_internet_services_crn') and self.cloud_internet_services_crn is not None:
            _dict['cloud_internet_services_crn'] = self.cloud_internet_services_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServices object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServices') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServices') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class PublicCertificateConfigurationDNSCloudInternetServicesMetadata(ConfigurationMetadata):
    """
    Your Cloud Internet Services DNS metadata properties.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: The unique name of your configuration.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServicesMetadata object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServicesMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class PublicCertificateConfigurationDNSCloudInternetServicesPatch(ConfigurationPatch):
    """
    The configuration update of the Cloud Internet Services DNS.

    :param str cloud_internet_services_apikey: An IBM Cloud API key that can to list
          domains in your Cloud Internet Services instance.
          To grant Secrets Manager the ability to view the Cloud Internet Services
          instance and all of its domains, the API key must be assigned the Reader service
          role on Internet Services (`internet-svcs`).
          If you need to manage specific domains, you can assign the Manager role. For
          production environments, it is recommended that you assign the Reader access
          role, and then use the
          [IAM Policy Management
          API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
          control specific domains. For more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
    :param str cloud_internet_services_crn: (optional) A CRN that uniquely
          identifies an IBM Cloud resource.
    """

    def __init__(
        self,
        cloud_internet_services_apikey: str,
        *,
        cloud_internet_services_crn: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPatch object.

        :param str cloud_internet_services_apikey: An IBM Cloud API key that can to
               list domains in your Cloud Internet Services instance.
               To grant Secrets Manager the ability to view the Cloud Internet Services
               instance and all of its domains, the API key must be assigned the Reader
               service role on Internet Services (`internet-svcs`).
               If you need to manage specific domains, you can assign the Manager role.
               For production environments, it is recommended that you assign the Reader
               access role, and then use the
               [IAM Policy Management
               API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
               control specific domains. For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
        :param str cloud_internet_services_crn: (optional) A CRN that uniquely
               identifies an IBM Cloud resource.
        """
        # pylint: disable=super-init-not-called
        self.cloud_internet_services_apikey = cloud_internet_services_apikey
        self.cloud_internet_services_crn = cloud_internet_services_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServicesPatch':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPatch object from a json dictionary."""
        args = {}
        if 'cloud_internet_services_apikey' in _dict:
            args['cloud_internet_services_apikey'] = _dict.get('cloud_internet_services_apikey')
        else:
            raise ValueError('Required property \'cloud_internet_services_apikey\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPatch JSON')
        if 'cloud_internet_services_crn' in _dict:
            args['cloud_internet_services_crn'] = _dict.get('cloud_internet_services_crn')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'cloud_internet_services_apikey') and self.cloud_internet_services_apikey is not None:
            _dict['cloud_internet_services_apikey'] = self.cloud_internet_services_apikey
        if hasattr(self, 'cloud_internet_services_crn') and self.cloud_internet_services_crn is not None:
            _dict['cloud_internet_services_crn'] = self.cloud_internet_services_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServicesPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificateConfigurationDNSCloudInternetServicesPrototype(ConfigurationPrototype):
    """
    Specify the properties for Cloud Internet Services DNS configuration.

    :param str config_type: The configuration type. Can be one of:
          iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
          public_cert_configuration_dns_classic_infrastructure,
          public_cert_configuration_dns_cloud_internet_services,
          private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
          private_cert_configuration_template.
    :param str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :param str cloud_internet_services_apikey: (optional) An IBM Cloud API key that
          can to list domains in your Cloud Internet Services instance.
          To grant Secrets Manager the ability to view the Cloud Internet Services
          instance and all of its domains, the API key must be assigned the Reader service
          role on Internet Services (`internet-svcs`).
          If you need to manage specific domains, you can assign the Manager role. For
          production environments, it is recommended that you assign the Reader access
          role, and then use the
          [IAM Policy Management
          API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
          control specific domains. For more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
    :param str cloud_internet_services_crn: A CRN that uniquely identifies an IBM
          Cloud resource.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        cloud_internet_services_crn: str,
        *,
        cloud_internet_services_apikey: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPrototype object.

        :param str config_type: The configuration type. Can be one of:
               iam_credentials_configuration, public_cert_configuration_ca_lets_encrypt,
               public_cert_configuration_dns_classic_infrastructure,
               public_cert_configuration_dns_cloud_internet_services,
               private_cert_configuration_root_ca,
               private_cert_configuration_intermediate_ca,
               private_cert_configuration_template.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str cloud_internet_services_crn: A CRN that uniquely identifies an
               IBM Cloud resource.
        :param str cloud_internet_services_apikey: (optional) An IBM Cloud API key
               that can to list domains in your Cloud Internet Services instance.
               To grant Secrets Manager the ability to view the Cloud Internet Services
               instance and all of its domains, the API key must be assigned the Reader
               service role on Internet Services (`internet-svcs`).
               If you need to manage specific domains, you can assign the Manager role.
               For production environments, it is recommended that you assign the Reader
               access role, and then use the
               [IAM Policy Management
               API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
               control specific domains. For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.cloud_internet_services_apikey = cloud_internet_services_apikey
        self.cloud_internet_services_crn = cloud_internet_services_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPrototype JSON')
        if 'cloud_internet_services_apikey' in _dict:
            args['cloud_internet_services_apikey'] = _dict.get('cloud_internet_services_apikey')
        if 'cloud_internet_services_crn' in _dict:
            args['cloud_internet_services_crn'] = _dict.get('cloud_internet_services_crn')
        else:
            raise ValueError('Required property \'cloud_internet_services_crn\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'cloud_internet_services_apikey') and self.cloud_internet_services_apikey is not None:
            _dict['cloud_internet_services_apikey'] = self.cloud_internet_services_apikey
        if hasattr(self, 'cloud_internet_services_crn') and self.cloud_internet_services_crn is not None:
            _dict['cloud_internet_services_crn'] = self.cloud_internet_services_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServicesPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type. Can be one of: iam_credentials_configuration,
        public_cert_configuration_ca_lets_encrypt,
        public_cert_configuration_dns_classic_infrastructure,
        public_cert_configuration_dns_cloud_internet_services,
        private_cert_configuration_root_ca, private_cert_configuration_intermediate_ca,
        private_cert_configuration_template.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'



class PublicCertificateMetadata(SecretMetadata):
    """
    Properties of the metadata of your public certificate.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param str signing_algorithm: (optional) The identifier for the cryptographic
          algorithm that is used by the issuing certificate authority to sign a
          certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str common_name: The Common Name (CN) represents the server name
          protected by the SSL certificate.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param CertificateIssuanceInfo issuance_info: (optional) Issuance information
          that is associated with your certificate.
    :param str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :param str key_algorithm: The identifier for the cryptographic algorithm that is
          used to generate the public key that is associated with the certificate.
          The algorithm that you select determines the encryption algorithm (`RSA` or
          `ECDSA`) and key size to be used to generate keys and sign certificates. For
          longer living certificates, it is recommended to use longer keys to provide more
          encryption protection. Allowed values:  `RSA2048`, `RSA4096`, `ECDSA256`, and
          `ECDSA384`.
    :param str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :param CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    :param RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :param bool bundle_certs: (optional) Indicates whether the issued certificate is
          bundled with intermediate certificates.
    :param str ca: (optional) The name of the certificate authority configuration.
    :param str dns: (optional) The name of the DNS provider configuration.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        common_name: str,
        key_algorithm: str,
        rotation: 'RotationPolicy',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        signing_algorithm: Optional[str] = None,
        alt_names: Optional[List[str]] = None,
        expiration_date: Optional[datetime] = None,
        issuance_info: Optional['CertificateIssuanceInfo'] = None,
        issuer: Optional[str] = None,
        serial_number: Optional[str] = None,
        validity: Optional['CertificateValidity'] = None,
        bundle_certs: Optional[bool] = None,
        ca: Optional[str] = None,
        dns: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str common_name: The Common Name (CN) represents the server name
               protected by the SSL certificate.
        :param str key_algorithm: The identifier for the cryptographic algorithm
               that is used to generate the public key that is associated with the
               certificate.
               The algorithm that you select determines the encryption algorithm (`RSA` or
               `ECDSA`) and key size to be used to generate keys and sign certificates.
               For longer living certificates, it is recommended to use longer keys to
               provide more encryption protection. Allowed values:  `RSA2048`, `RSA4096`,
               `ECDSA256`, and `ECDSA384`.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str signing_algorithm: (optional) The identifier for the
               cryptographic algorithm that is used by the issuing certificate authority
               to sign a certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuance_info = issuance_info
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.serial_number = serial_number
        self.validity = validity
        self.rotation = rotation
        self.bundle_certs = bundle_certs
        self.ca = ca
        self.dns = dns

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateMetadata':
        """Initialize a PublicCertificateMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PublicCertificateMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificateMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PublicCertificateMetadata JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PublicCertificateMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuance_info' in _dict:
            args['issuance_info'] = CertificateIssuanceInfo.from_dict(_dict.get('issuance_info'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        else:
            raise ValueError('Required property \'key_algorithm\' not present in PublicCertificateMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in PublicCertificateMetadata JSON')
        if 'bundle_certs' in _dict:
            args['bundle_certs'] = _dict.get('bundle_certs')
        if 'ca' in _dict:
            args['ca'] = _dict.get('ca')
        if 'dns' in _dict:
            args['dns'] = _dict.get('dns')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuance_info') and getattr(self, 'issuance_info') is not None:
            if isinstance(getattr(self, 'issuance_info'), dict):
                _dict['issuance_info'] = getattr(self, 'issuance_info')
            else:
                _dict['issuance_info'] = getattr(self, 'issuance_info').to_dict()
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and self.key_algorithm is not None:
            _dict['key_algorithm'] = self.key_algorithm
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'bundle_certs') and getattr(self, 'bundle_certs') is not None:
            _dict['bundle_certs'] = getattr(self, 'bundle_certs')
        if hasattr(self, 'ca') and getattr(self, 'ca') is not None:
            _dict['ca'] = getattr(self, 'ca')
        if hasattr(self, 'dns') and getattr(self, 'dns') is not None:
            _dict['dns'] = getattr(self, 'dns')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PublicCertificateMetadataPatch(SecretMetadataPatch):
    """
    PublicCertificateMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
        rotation: Optional['RotationPolicy'] = None,
    ) -> None:
        """
        Initialize a PublicCertificateMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateMetadataPatch':
        """Initialize a PublicCertificateMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificatePrototype(SecretPrototype):
    """
    PublicCertificatePrototype.

    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str common_name: The Common Name (CN) represents the server name
          protected by the SSL certificate.
    :param List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :param str key_algorithm: (optional) The identifier for the cryptographic
          algorithm that is used to generate the public key that is associated with the
          certificate.
          The algorithm that you select determines the encryption algorithm (`RSA` or
          `ECDSA`) and key size to be used to generate keys and sign certificates. For
          longer living certificates, it is recommended to use longer keys to provide more
          encryption protection. Allowed values:  `RSA2048`, `RSA4096`, `ECDSA256`, and
          `ECDSA384`.
    :param str ca: The name of the certificate authority configuration.
    :param str dns: The name of the DNS provider configuration.
    :param bool bundle_certs: (optional) This field indicates whether your issued
          certificate is bundled with intermediate certificates. Set to `false` for the
          certificate file to contain only the issued certificate.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        common_name: str,
        ca: str,
        dns: str,
        *,
        description: Optional[str] = None,
        secret_group_id: Optional[str] = None,
        labels: Optional[List[str]] = None,
        alt_names: Optional[List[str]] = None,
        key_algorithm: Optional[str] = None,
        bundle_certs: Optional[bool] = None,
        rotation: Optional['RotationPolicy'] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a PublicCertificatePrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str common_name: The Common Name (CN) represents the server name
               protected by the SSL certificate.
        :param str ca: The name of the certificate authority configuration.
        :param str dns: The name of the DNS provider configuration.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str key_algorithm: (optional) The identifier for the cryptographic
               algorithm that is used to generate the public key that is associated with
               the certificate.
               The algorithm that you select determines the encryption algorithm (`RSA` or
               `ECDSA`) and key size to be used to generate keys and sign certificates.
               For longer living certificates, it is recommended to use longer keys to
               provide more encryption protection. Allowed values:  `RSA2048`, `RSA4096`,
               `ECDSA256`, and `ECDSA384`.
        :param bool bundle_certs: (optional) This field indicates whether your
               issued certificate is bundled with intermediate certificates. Set to
               `false` for the certificate file to contain only the issued certificate.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.common_name = common_name
        self.alt_names = alt_names
        self.key_algorithm = key_algorithm
        self.ca = ca
        self.dns = dns
        self.bundle_certs = bundle_certs
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificatePrototype':
        """Initialize a PublicCertificatePrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificatePrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PublicCertificatePrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'ca' in _dict:
            args['ca'] = _dict.get('ca')
        else:
            raise ValueError('Required property \'ca\' not present in PublicCertificatePrototype JSON')
        if 'dns' in _dict:
            args['dns'] = _dict.get('dns')
        else:
            raise ValueError('Required property \'dns\' not present in PublicCertificatePrototype JSON')
        if 'bundle_certs' in _dict:
            args['bundle_certs'] = _dict.get('bundle_certs')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'key_algorithm') and self.key_algorithm is not None:
            _dict['key_algorithm'] = self.key_algorithm
        if hasattr(self, 'ca') and self.ca is not None:
            _dict['ca'] = self.ca
        if hasattr(self, 'dns') and self.dns is not None:
            _dict['dns'] = self.dns
        if hasattr(self, 'bundle_certs') and self.bundle_certs is not None:
            _dict['bundle_certs'] = self.bundle_certs
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class PublicCertificateRotationPolicy(RotationPolicy):
    """
    This field indicates whether Secrets Manager rotates your secrets automatically.
    For public certificates, if `auto_rotate` is set to `true`, the service reorders your
    certificate for 31 days, before it expires.

    :param bool auto_rotate: This field indicates whether Secrets Manager rotates
          your secret automatically.
          The default is `false`. If `auto_rotate` is set to `true` the service rotates
          your secret based on the defined interval.
    :param bool rotate_keys: This field indicates whether Secrets Manager rotates
          the private key for your public certificate automatically.
          The default is `false`. If it is set to `true`, the service generates and stores
          a new private key for your rotated certificate.
    """

    def __init__(
        self,
        auto_rotate: bool,
        rotate_keys: bool,
    ) -> None:
        """
        Initialize a PublicCertificateRotationPolicy object.

        :param bool auto_rotate: This field indicates whether Secrets Manager
               rotates your secret automatically.
               The default is `false`. If `auto_rotate` is set to `true` the service
               rotates your secret based on the defined interval.
        :param bool rotate_keys: This field indicates whether Secrets Manager
               rotates the private key for your public certificate automatically.
               The default is `false`. If it is set to `true`, the service generates and
               stores a new private key for your rotated certificate.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotate = auto_rotate
        self.rotate_keys = rotate_keys

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateRotationPolicy':
        """Initialize a PublicCertificateRotationPolicy object from a json dictionary."""
        args = {}
        if 'auto_rotate' in _dict:
            args['auto_rotate'] = _dict.get('auto_rotate')
        else:
            raise ValueError('Required property \'auto_rotate\' not present in PublicCertificateRotationPolicy JSON')
        if 'rotate_keys' in _dict:
            args['rotate_keys'] = _dict.get('rotate_keys')
        else:
            raise ValueError('Required property \'rotate_keys\' not present in PublicCertificateRotationPolicy JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateRotationPolicy object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotate') and self.auto_rotate is not None:
            _dict['auto_rotate'] = self.auto_rotate
        if hasattr(self, 'rotate_keys') and self.rotate_keys is not None:
            _dict['rotate_keys'] = self.rotate_keys
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateRotationPolicy object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateRotationPolicy') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateRotationPolicy') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificateVersion(SecretVersion):
    """
    Versions of your public certificate.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :param CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    :param str certificate: (optional) Your PEM-encoded certificate. The data must
          be formatted on a single line with embedded newline characters.
    :param str intermediate: (optional) The PEM-encoded intermediate certificate
          that is associated with the root certificate. The data must be formatted on a
          single line with embedded newline characters.
    :param str private_key: (optional) The PEM-encoded private key that is
          associated with the certificate. The data must be formatted on a single line
          with embedded newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
        serial_number: Optional[str] = None,
        validity: Optional['CertificateValidity'] = None,
        certificate: Optional[str] = None,
        intermediate: Optional[str] = None,
        private_key: Optional[str] = None,
    ) -> None:
        """
        Initialize a PublicCertificateVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        :param str certificate: (optional) Your PEM-encoded certificate. The data
               must be formatted on a single line with embedded newline characters.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateVersion':
        """Initialize a PublicCertificateVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificateVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificateVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PublicCertificateVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PublicCertificateVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PublicCertificateVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your public certificate.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :param CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
        serial_number: Optional[str] = None,
        validity: Optional['CertificateValidity'] = None,
    ) -> None:
        """
        Initialize a PublicCertificateVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateVersionMetadata':
        """Initialize a PublicCertificateVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificateVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificateVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PublicCertificateVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PublicCertificateVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PublicCertificateVersionPrototype(SecretVersionPrototype):
    """
    PublicCertificateVersionPrototype.

    :param PublicCertificateRotationObject rotation: Defines the rotation object
          that is used to manually rotate public certificates.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        rotation: 'PublicCertificateRotationObject',
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a PublicCertificateVersionPrototype object.

        :param PublicCertificateRotationObject rotation: Defines the rotation
               object that is used to manually rotate public certificates.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateVersionPrototype':
        """Initialize a PublicCertificateVersionPrototype object from a json dictionary."""
        args = {}
        if 'rotation' in _dict:
            args['rotation'] = PublicCertificateRotationObject.from_dict(_dict.get('rotation'))
        else:
            raise ValueError('Required property \'rotation\' not present in PublicCertificateVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSecret(Secret):
    """
    Your service credentials secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param str ttl: (optional) The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param ServiceCredentialsSecretSourceService source_service: The properties that
          are required to create the service credentials for the specified source service
          instance.
    :param ServiceCredentialsSecretCredentials credentials: The properties of the
          service credentials secret payload.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        source_service: 'ServiceCredentialsSecretSourceService',
        credentials: 'ServiceCredentialsSecretCredentials',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        next_rotation_date: Optional[datetime] = None,
        rotation: Optional['RotationPolicy'] = None,
        ttl: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param ServiceCredentialsSecretSourceService source_service: The properties
               that are required to create the service credentials for the specified
               source service instance.
        :param ServiceCredentialsSecretCredentials credentials: The properties of
               the service credentials secret payload.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param str ttl: (optional) The time-to-live (TTL) or lease duration to
               assign to credentials that are generated. Supported secret types:
               iam_credentials, service_credentials. The TTL defines how long generated
               credentials remain valid. The value can be either an integer that specifies
               the number of seconds, or the string  representation of a duration, such as
               `1440m` or `24h`. For the iam_credentials secret type, the TTL field is
               mandatory. The minimum duration is 1 minute. The maximum is 90 days. For
               the service_credentials secret type, the TTL field is optional. If it is
               set the minimum duration is 1 day. The maximum is 90 days. By default, the
               TTL is set to 0.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.next_rotation_date = next_rotation_date
        self.rotation = rotation
        self.ttl = ttl
        self.source_service = source_service
        self.credentials = credentials

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecret':
        """Initialize a ServiceCredentialsSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ServiceCredentialsSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ServiceCredentialsSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ServiceCredentialsSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ServiceCredentialsSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ServiceCredentialsSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ServiceCredentialsSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ServiceCredentialsSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ServiceCredentialsSecret JSON')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'source_service' in _dict:
            args['source_service'] = ServiceCredentialsSecretSourceService.from_dict(_dict.get('source_service'))
        else:
            raise ValueError('Required property \'source_service\' not present in ServiceCredentialsSecret JSON')
        if 'credentials' in _dict:
            args['credentials'] = ServiceCredentialsSecretCredentials.from_dict(_dict.get('credentials'))
        else:
            raise ValueError('Required property \'credentials\' not present in ServiceCredentialsSecret JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'source_service') and self.source_service is not None:
            if isinstance(self.source_service, dict):
                _dict['source_service'] = self.source_service
            else:
                _dict['source_service'] = self.source_service.to_dict()
        if hasattr(self, 'credentials') and self.credentials is not None:
            if isinstance(self.credentials, dict):
                _dict['credentials'] = self.credentials
            else:
                _dict['credentials'] = self.credentials.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ServiceCredentialsSecretMetadata(SecretMetadata):
    """
    The metadata properties for your service credentials secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param str ttl: (optional) The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param ServiceCredentialsSecretSourceService source_service: The properties that
          are required to create the service credentials for the specified source service
          instance.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        source_service: 'ServiceCredentialsSecretSourceService',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        next_rotation_date: Optional[datetime] = None,
        rotation: Optional['RotationPolicy'] = None,
        ttl: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param ServiceCredentialsSecretSourceService source_service: The properties
               that are required to create the service credentials for the specified
               source service instance.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param str ttl: (optional) The time-to-live (TTL) or lease duration to
               assign to credentials that are generated. Supported secret types:
               iam_credentials, service_credentials. The TTL defines how long generated
               credentials remain valid. The value can be either an integer that specifies
               the number of seconds, or the string  representation of a duration, such as
               `1440m` or `24h`. For the iam_credentials secret type, the TTL field is
               mandatory. The minimum duration is 1 minute. The maximum is 90 days. For
               the service_credentials secret type, the TTL field is optional. If it is
               set the minimum duration is 1 day. The maximum is 90 days. By default, the
               TTL is set to 0.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.next_rotation_date = next_rotation_date
        self.rotation = rotation
        self.ttl = ttl
        self.source_service = source_service

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretMetadata':
        """Initialize a ServiceCredentialsSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ServiceCredentialsSecretMetadata JSON')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'source_service' in _dict:
            args['source_service'] = ServiceCredentialsSecretSourceService.from_dict(_dict.get('source_service'))
        else:
            raise ValueError('Required property \'source_service\' not present in ServiceCredentialsSecretMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'source_service') and self.source_service is not None:
            if isinstance(self.source_service, dict):
                _dict['source_service'] = self.source_service
            else:
                _dict['source_service'] = self.source_service.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ServiceCredentialsSecretMetadataPatch(SecretMetadataPatch):
    """
    ServiceCredentialsSecretMetadataPatch.

    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param str ttl: (optional) The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    """

    def __init__(
        self,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        name: Optional[str] = None,
        rotation: Optional['RotationPolicy'] = None,
        ttl: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretMetadataPatch object.

        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param str ttl: (optional) The time-to-live (TTL) or lease duration to
               assign to credentials that are generated. Supported secret types:
               iam_credentials, service_credentials. The TTL defines how long generated
               credentials remain valid. The value can be either an integer that specifies
               the number of seconds, or the string  representation of a duration, such as
               `1440m` or `24h`. For the iam_credentials secret type, the TTL field is
               mandatory. The minimum duration is 1 minute. The maximum is 90 days. For
               the service_credentials secret type, the TTL field is optional. If it is
               set the minimum duration is 1 day. The maximum is 90 days. By default, the
               TTL is set to 0.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.description = description
        self.labels = labels
        self.name = name
        self.rotation = rotation
        self.ttl = ttl

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretMetadataPatch':
        """Initialize a ServiceCredentialsSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ServiceCredentialsSecretPrototype(SecretPrototype):
    """
    ServiceCredentialsSecretPrototype.

    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param ServiceCredentialsSecretSourceService source_service: The properties that
          are required to create the service credentials for the specified source service
          instance.
    :param str ttl: (optional) The time-to-live (TTL) or lease duration to assign to
          credentials that are generated. Supported secret types: iam_credentials,
          service_credentials. The TTL defines how long generated credentials remain
          valid. The value can be either an integer that specifies the number of seconds,
          or the string  representation of a duration, such as `1440m` or `24h`. For the
          iam_credentials secret type, the TTL field is mandatory. The minimum duration is
          1 minute. The maximum is 90 days. For the service_credentials secret type, the
          TTL field is optional. If it is set the minimum duration is 1 day. The maximum
          is 90 days. By default, the TTL is set to 0.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        name: str,
        secret_type: str,
        source_service: 'ServiceCredentialsSecretSourceService',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        rotation: Optional['RotationPolicy'] = None,
        secret_group_id: Optional[str] = None,
        ttl: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretPrototype object.

        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param ServiceCredentialsSecretSourceService source_service: The properties
               that are required to create the service credentials for the specified
               source service instance.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param str ttl: (optional) The time-to-live (TTL) or lease duration to
               assign to credentials that are generated. Supported secret types:
               iam_credentials, service_credentials. The TTL defines how long generated
               credentials remain valid. The value can be either an integer that specifies
               the number of seconds, or the string  representation of a duration, such as
               `1440m` or `24h`. For the iam_credentials secret type, the TTL field is
               mandatory. The minimum duration is 1 minute. The maximum is 90 days. For
               the service_credentials secret type, the TTL field is optional. If it is
               set the minimum duration is 1 day. The maximum is 90 days. By default, the
               TTL is set to 0.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.description = description
        self.labels = labels
        self.name = name
        self.rotation = rotation
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.source_service = source_service
        self.ttl = ttl
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretPrototype':
        """Initialize a ServiceCredentialsSecretPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in ServiceCredentialsSecretPrototype JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ServiceCredentialsSecretPrototype JSON')
        if 'source_service' in _dict:
            args['source_service'] = ServiceCredentialsSecretSourceService.from_dict(_dict.get('source_service'))
        else:
            raise ValueError('Required property \'source_service\' not present in ServiceCredentialsSecretPrototype JSON')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'source_service') and self.source_service is not None:
            if isinstance(self.source_service, dict):
                _dict['source_service'] = self.source_service
            else:
                _dict['source_service'] = self.source_service.to_dict()
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class ServiceCredentialsSecretVersion(SecretVersion):
    """
    Your service credentials secret version.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param ServiceCredentialsResourceKey resource_key: (optional) The source service
          resource key data of the generated service credentials.
    :param ServiceCredentialsSecretCredentials credentials: The properties of the
          service credentials secret payload.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        credentials: 'ServiceCredentialsSecretCredentials',
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
        resource_key: Optional['ServiceCredentialsResourceKey'] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param ServiceCredentialsSecretCredentials credentials: The properties of
               the service credentials secret payload.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param ServiceCredentialsResourceKey resource_key: (optional) The source
               service resource key data of the generated service credentials.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.resource_key = resource_key
        self.credentials = credentials

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretVersion':
        """Initialize a ServiceCredentialsSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ServiceCredentialsSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ServiceCredentialsSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ServiceCredentialsSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ServiceCredentialsSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ServiceCredentialsSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ServiceCredentialsSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ServiceCredentialsSecretVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'resource_key' in _dict:
            args['resource_key'] = ServiceCredentialsResourceKey.from_dict(_dict.get('resource_key'))
        if 'credentials' in _dict:
            args['credentials'] = ServiceCredentialsSecretCredentials.from_dict(_dict.get('credentials'))
        else:
            raise ValueError('Required property \'credentials\' not present in ServiceCredentialsSecretVersion JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'resource_key') and self.resource_key is not None:
            if isinstance(self.resource_key, dict):
                _dict['resource_key'] = self.resource_key
            else:
                _dict['resource_key'] = self.resource_key.to_dict()
        if hasattr(self, 'credentials') and self.credentials is not None:
            if isinstance(self.credentials, dict):
                _dict['credentials'] = self.credentials
            else:
                _dict['credentials'] = self.credentials.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ServiceCredentialsSecretVersionMetadata(SecretVersionMetadata):
    """
    The version metadata properties for your service credentials secret.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param ServiceCredentialsResourceKey resource_key: (optional) The source service
          resource key data of the generated service credentials.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
        expiration_date: Optional[datetime] = None,
        resource_key: Optional['ServiceCredentialsResourceKey'] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param ServiceCredentialsResourceKey resource_key: (optional) The source
               service resource key data of the generated service credentials.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.resource_key = resource_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretVersionMetadata':
        """Initialize a ServiceCredentialsSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ServiceCredentialsSecretVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'resource_key' in _dict:
            args['resource_key'] = ServiceCredentialsResourceKey.from_dict(_dict.get('resource_key'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'resource_key') and self.resource_key is not None:
            if isinstance(self.resource_key, dict):
                _dict['resource_key'] = self.resource_key
            else:
                _dict['resource_key'] = self.resource_key.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ServiceCredentialsSecretVersionPrototype(SecretVersionPrototype):
    """
    ServiceCredentialsSecretVersionPrototype.

    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a ServiceCredentialsSecretVersionPrototype object.

        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceCredentialsSecretVersionPrototype':
        """Initialize a ServiceCredentialsSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceCredentialsSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceCredentialsSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceCredentialsSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceCredentialsSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class UsernamePasswordSecret(Secret):
    """
    Your user credentials secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :param str username: The username that is assigned to an `username_password`
          secret.
    :param str password: The password that is assigned to an `username_password`
          secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        rotation: 'RotationPolicy',
        username: str,
        password: str,
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        expiration_date: Optional[datetime] = None,
        next_rotation_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param str username: The username that is assigned to an
               `username_password` secret.
        :param str password: The password that is assigned to an
               `username_password` secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.rotation = rotation
        self.expiration_date = expiration_date
        self.next_rotation_date = next_rotation_date
        self.username = username
        self.password = password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecret':
        """Initialize a UsernamePasswordSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in UsernamePasswordSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in UsernamePasswordSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in UsernamePasswordSecret JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in UsernamePasswordSecret JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        else:
            raise ValueError('Required property \'username\' not present in UsernamePasswordSecret JSON')
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        else:
            raise ValueError('Required property \'password\' not present in UsernamePasswordSecret JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class UsernamePasswordSecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your user credentials secret.

    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param int locks_total: (optional) The number of locks of the secret.
    :param str name: (optional) The human-readable name of your secret.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :param str state_description: (optional) A text representation of the secret
          state.
    :param datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :param int versions_total: The number of versions of your secret.
    :param RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        rotation: 'RotationPolicy',
        *,
        custom_metadata: Optional[dict] = None,
        description: Optional[str] = None,
        downloaded: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        locks_total: Optional[int] = None,
        name: Optional[str] = None,
        state: Optional[int] = None,
        state_description: Optional[str] = None,
        expiration_date: Optional[datetime] = None,
        next_rotation_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.rotation = rotation
        self.expiration_date = expiration_date
        self.next_rotation_date = next_rotation_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretMetadata':
        """Initialize a UsernamePasswordSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in UsernamePasswordSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in UsernamePasswordSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in UsernamePasswordSecretMetadata JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in UsernamePasswordSecretMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class UsernamePasswordSecretMetadataPatch(SecretMetadataPatch):
    """
    UsernamePasswordSecretMetadataPatch.

    :param str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[List[str]] = None,
        custom_metadata: Optional[dict] = None,
        rotation: Optional['RotationPolicy'] = None,
        expiration_date: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.rotation = rotation
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretMetadataPatch':
        """Initialize a UsernamePasswordSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class UsernamePasswordSecretPrototype(SecretPrototype):
    """
    UsernamePasswordSecretPrototype.

    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :param str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :param str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :param List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :param str username: The username that is assigned to an `username_password`
          secret.
    :param str password: The password that is assigned to an `username_password`
          secret.
    :param datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        username: str,
        password: str,
        *,
        description: Optional[str] = None,
        secret_group_id: Optional[str] = None,
        labels: Optional[List[str]] = None,
        expiration_date: Optional[datetime] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
        rotation: Optional['RotationPolicy'] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretPrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str username: The username that is assigned to an
               `username_password` secret.
        :param str password: The password that is assigned to an
               `username_password` secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.username = username
        self.password = password
        self.expiration_date = expiration_date
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretPrototype':
        """Initialize a UsernamePasswordSecretPrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in UsernamePasswordSecretPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        else:
            raise ValueError('Required property \'username\' not present in UsernamePasswordSecretPrototype JSON')
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        else:
            raise ValueError('Required property \'password\' not present in UsernamePasswordSecretPrototype JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'



class UsernamePasswordSecretVersion(SecretVersion):
    """
    Your user credentials secret version.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    :param str username: The username that is assigned to an `username_password`
          secret.
    :param str password: The password that is assigned to an `username_password`
          secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        username: str,
        password: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param str username: The username that is assigned to an
               `username_password` secret.
        :param str password: The password that is assigned to an
               `username_password` secret.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.username = username
        self.password = password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretVersion':
        """Initialize a UsernamePasswordSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in UsernamePasswordSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in UsernamePasswordSecretVersion JSON')
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        else:
            raise ValueError('Required property \'username\' not present in UsernamePasswordSecretVersion JSON')
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        else:
            raise ValueError('Required property \'password\' not present in UsernamePasswordSecretVersion JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class UsernamePasswordSecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your user credentials secret.

    :param bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :param str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :param datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :param bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :param str id: A v4 UUID identifier.
    :param str secret_name: (optional) The human-readable name of your secret.
    :param str secret_type: The secret type. Supported types are arbitrary,
          imported_cert, public_cert, private_cert, iam_credentials, service_credentials,
          kv, and username_password.
    :param str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :param bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :param str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :param str secret_id: A v4 UUID identifier.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: Optional[bool] = None,
        downloaded: Optional[bool] = None,
        secret_name: Optional[str] = None,
        alias: Optional[str] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               imported_cert, public_cert, private_cert, iam_credentials,
               service_credentials, kv, and username_password.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretVersionMetadata':
        """Initialize a UsernamePasswordSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in UsernamePasswordSecretVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, imported_cert, public_cert,
        private_cert, iam_credentials, service_credentials, kv, and username_password.
        """

        ARBITRARY = 'arbitrary'
        IAM_CREDENTIALS = 'iam_credentials'
        IMPORTED_CERT = 'imported_cert'
        KV = 'kv'
        PRIVATE_CERT = 'private_cert'
        PUBLIC_CERT = 'public_cert'
        SERVICE_CREDENTIALS = 'service_credentials'
        USERNAME_PASSWORD = 'username_password'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class UsernamePasswordSecretVersionPrototype(SecretVersionPrototype):
    """
    UsernamePasswordSecretVersionPrototype.

    :param str password: (optional) The password that is assigned to an
          `username_password` secret.
    :param dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :param dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        password: Optional[str] = None,
        custom_metadata: Optional[dict] = None,
        version_custom_metadata: Optional[dict] = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretVersionPrototype object.

        :param str password: (optional) The password that is assigned to an
               `username_password` secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.password = password
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretVersionPrototype':
        """Initialize a UsernamePasswordSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

##############################################################################
# Pagers
##############################################################################


class SecretsPager:
    """
    SecretsPager can be used to simplify the use of the "list_secrets" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        limit: int = None,
        sort: str = None,
        search: str = None,
        groups: List[str] = None,
    ) -> None:
        """
        Initialize a SecretsPager object.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of secrets by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** id | created_at | updated_at | expiration_date |
               secret_type | name
               **Usage:** To sort a list of secrets by their creation date, use
               `../secrets?sort=created_at`.
        :param str search: (optional) Obtain a collection of secrets that contain
               the specified string in one or more of the fields: `id`, `name`,
               `description`,
               `labels`, `secret_type`.
               **Usage:** If you want to list only the secrets that contain the string
               `text`, use
               `../secrets?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._limit = limit
        self._sort = sort
        self._search = search
        self._groups = groups

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretMetadata.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secrets(
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            groups=self._groups,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('secrets')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretMetadata.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class SecretsLocksPager:
    """
    SecretsLocksPager can be used to simplify the use of the "list_secrets_locks" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        limit: int = None,
        search: str = None,
        groups: List[str] = None,
    ) -> None:
        """
        Initialize a SecretsLocksPager object.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._limit = limit
        self._search = search
        self._groups = groups

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLocks.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secrets_locks(
            limit=self._limit,
            search=self._search,
            groups=self._groups,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('secrets_locks')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLocks.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class SecretLocksPager:
    """
    SecretLocksPager can be used to simplify the use of the "list_secret_locks" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        id: str,
        limit: int = None,
        sort: str = None,
        search: str = None,
    ) -> None:
        """
        Initialize a SecretLocksPager object.
        :param str id: The v4 UUID that uniquely identifies your secret.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._id = id
        self._limit = limit
        self._sort = sort
        self._search = search

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secret_locks(
            id=self._id,
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('locks')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class SecretVersionLocksPager:
    """
    SecretVersionLocksPager can be used to simplify the use of the "list_secret_version_locks" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        secret_id: str,
        id: str,
        limit: int = None,
        sort: str = None,
        search: str = None,
    ) -> None:
        """
        Initialize a SecretVersionLocksPager object.
        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._secret_id = secret_id
        self._id = id
        self._limit = limit
        self._sort = sort
        self._search = search

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secret_version_locks(
            secret_id=self._secret_id,
            id=self._id,
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('locks')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class ConfigurationsPager:
    """
    ConfigurationsPager can be used to simplify the use of the "list_configurations" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        limit: int = None,
        sort: str = None,
        search: str = None,
    ) -> None:
        """
        Initialize a ConfigurationsPager object.
        :param int limit: (optional) The number of configurations to retrieve. By
               default, list operations return the first 200 items. To retrieve a
               different set of items, use `limit` with `offset` to page through your
               available resources. Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 configurations in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of configurations by the
               specified field in ascending order. To sort in descending order use the `-`
               character
               **Available values:**  config_type | secret_type | name
               **Usage:** To sort a list of configurations by their creation date, use
               `../configurations?sort=config_type`.
        :param str search: (optional) Obtain a collection of configurations that
               contain the specified string in one or more of the fields: `name`,
               `config_type`, `secret_type`.
               **Usage:** If you want to list only the configurations that contain the
               string `text`, use
               `../configurations?search=text`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._limit = limit
        self._sort = sort
        self._search = search

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of ConfigurationMetadata.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_configurations(
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('configurations')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of ConfigurationMetadata.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results

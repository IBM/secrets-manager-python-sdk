# coding: utf-8

# (C) Copyright IBM Corp. 2023.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.77.0-42417df0-20230811-192318

"""
With IBM CloudÂ® Secrets Manager, you can create, lease, and centrally manage secrets that
are used in IBM Cloud services or your custom-built applications.

API Version: 2.0.0
See: https://cloud.ibm.com/docs/secrets-manager
"""

from datetime import datetime
from enum import Enum
from typing import Dict, List
import json
import sys

from ibm_cloud_sdk_core import BaseService, DetailedResponse, get_query_param
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_list, convert_model, datetime_to_string, string_to_datetime

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################


class SecretsManagerV2(BaseService):
    """The secrets-manager V2 service."""

    DEFAULT_SERVICE_URL = 'https://provide-here-your-smgr-instanceuuid.us-south.secrets-manager.appdomain.cloud'
    DEFAULT_SERVICE_NAME = 'secrets_manager'

    PARAMETERIZED_SERVICE_URL = 'https://{instance_id}.{region}.secrets-manager.appdomain.cloud'

    @classmethod
    def new_instance(
        cls,
        service_name: str = DEFAULT_SERVICE_NAME,
    ) -> 'SecretsManagerV2':
        """
        Return a new client for the secrets-manager service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            authenticator
            )
        service.configure_service(service_name)
        return service

    @classmethod
    def construct_service_url(
        cls,
        instance_id: str = 'provide-here-your-smgr-instanceuuid',
        region: str = 'us-south',
    ) -> str:
        """
        Construct a service URL by formatting the parameterized service URL.

        The parameterized service URL is:
        'https://{instance_id}.{region}.secrets-manager.appdomain.cloud'

        :param str instance_id: (optional) The Secrets Manager Instance ID assigned by the service provider
            (default 'provide-here-your-smgr-instanceuuid')
        :param str region: (optional) The region where you provisioned your Secrets Manager Instance. Available values: us-south, us-east, au-syd, jp-osa, jp-tok, eu-de, eu-gb, ca-tor, br-sao
            (default 'us-south')
        :return: The formatted URL with all variable placeholders replaced by values.
        :rtype: str
        """
        return cls.PARAMETERIZED_SERVICE_URL.format(
            instance_id=instance_id,
            region=region,
        )

    def __init__(
        self,
        authenticator: Authenticator = None,
    ) -> None:
        """
        Construct a new client for the secrets-manager service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/main/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self, service_url=self.DEFAULT_SERVICE_URL, authenticator=authenticator)

    #########################
    # Secret groups
    #########################

    def create_secret_group(
        self,
        name: str,
        *,
        description: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new secret group.

        Create a secret group that you can use to organize secrets and control who can
        access them.
        A successful request returns the ID value of the secret group, along with other
        properties. To learn more about secret groups, check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-secret-groups).

        :param str name: The name of your secret group.
        :param str description: (optional) An extended description of your secret
               group.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroup` object
        """

        if name is None:
            raise ValueError('name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_group',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secret_groups'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_groups(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secret groups.

        List the secret groups that are available in your Secrets Manager instance.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroupCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_groups',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secret_groups'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_group(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a secret group.

        Get the properties of an existing secret group by specifying the ID of the group.

        :param str id: The v4 UUID that uniquely identifies your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroup` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_group',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_secret_group(
        self,
        id: str,
        secret_group_patch: 'SecretGroupPatch',
        **kwargs,
    ) -> DetailedResponse:
        """
        Update a secret group.

        Update the properties of an existing secret group, such as its name or
        description.

        :param str id: The v4 UUID that uniquely identifies your secret group.
        :param SecretGroupPatch secret_group_patch: The request body to update a
               secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretGroup` object
        """

        if not id:
            raise ValueError('id must be provided')
        if secret_group_patch is None:
            raise ValueError('secret_group_patch must be provided')
        if isinstance(secret_group_patch, SecretGroupPatch):
            secret_group_patch = convert_model(secret_group_patch)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_secret_group',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_group_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_group(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a secret group.

        Delete a secret group by specifying the ID of the secret group.
        **Note:** To delete a secret group, it must be empty. If you need to remove a
        secret group that contains secrets, you must first [delete the
        secrets](#delete-secret) that are associated with the group.

        :param str id: The v4 UUID that uniquely identifies your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_group',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Secrets
    #########################

    def create_secret(
        self,
        secret_prototype: 'SecretPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new secret.

        Create a secret or import an existing value that you can use to access or
        authenticate to a protected resource.
        Use this operation to either generate or import an existing secret, such as a TLS
        certificate, that you can manage in your Secrets Manager service instance. A
        successful request stores the secret in your dedicated instance, based on the
        secret type and data that you specify. The response returns the ID value of the
        secret, along with other metadata.
        To learn more about the types of secrets that you can create with Secrets Manager,
        check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-what-is-secret).

        :param SecretPrototype secret_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Secret` object
        """

        if secret_prototype is None:
            raise ValueError('secret_prototype must be provided')
        if isinstance(secret_prototype, SecretPrototype):
            secret_prototype = convert_model(secret_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secrets'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secrets(
        self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        search: str = None,
        groups: List[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secrets.

        List the secrets that are available in your Secrets Manager instance.

        :param int offset: (optional) The number of secrets to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 secrets in your instance, and you want to
               retrieve secrets 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of secrets by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** id | created_at | updated_at | expiration_date |
               secret_type | name
               **Usage:** To sort a list of secrets by their creation date, use
               `../secrets?sort=created_at`.
        :param str search: (optional) Obtain a collection of secrets that contain
               the specified string in one or more of the fields: `id`, `name`,
               `description`,
               `labels`, `secret_type`.
               **Usage:** If you want to list only the secrets that contain the string
               `text`, use
               `../secrets?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretMetadataPaginatedCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secrets',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
            'groups': convert_list(groups),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secrets'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a secret.

        Get a secret and its details by specifying the ID of the secret.
        A successful request returns the secret data that is associated with your secret,
        along with other metadata. To view only the details of a specified secret without
        retrieving its value, use the [Get secret metadata](#get-secret-metadata)
        operation.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Secret` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a secret.

        Delete a secret by specifying the ID of the secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_metadata(
        self,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get the metadata of a secret.

        Get the metadata of a secret by specifying the ID of the secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretMetadata` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_metadata',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_secret_metadata(
        self,
        id: str,
        secret_metadata_patch: 'SecretMetadataPatch',
        **kwargs,
    ) -> DetailedResponse:
        """
        Update the metadata of a secret.

        Update the metadata of a secret, such as its name or description.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param SecretMetadataPatch secret_metadata_patch:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretMetadata` object
        """

        if not id:
            raise ValueError('id must be provided')
        if secret_metadata_patch is None:
            raise ValueError('secret_metadata_patch must be provided')
        if isinstance(secret_metadata_patch, SecretMetadataPatch):
            secret_metadata_patch = convert_model(secret_metadata_patch)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_secret_metadata',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_metadata_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_action(
        self,
        id: str,
        secret_action_prototype: 'SecretActionPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a secret action.

        Create a secret action. This operation supports the following actions:.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param SecretActionPrototype secret_action_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretAction` object
        """

        if not id:
            raise ValueError('id must be provided')
        if secret_action_prototype is None:
            raise ValueError('secret_action_prototype must be provided')
        if isinstance(secret_action_prototype, SecretActionPrototype):
            secret_action_prototype = convert_model(secret_action_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_action',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_action_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_by_name_type(
        self,
        secret_type: str,
        name: str,
        secret_group_name: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a secret by name.

        Get a secret and its details by specifying the Name and Type of the secret.
        A successful request returns the secret data that is associated with your secret,
        along with other metadata. To view only the details of a specified secret without
        retrieving its value, use the [Get secret metadata](#get-secret-metadata)
        operation.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret. To protect
               your privacy, do not use personal data, such as your name or location, as a
               name for your secret.
        :param str secret_group_name: The name of your secret group.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Secret` object
        """

        if not secret_type:
            raise ValueError('secret_type must be provided')
        if not name:
            raise ValueError('name must be provided')
        if not secret_group_name:
            raise ValueError('secret_group_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_by_name_type',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_type', 'name', 'secret_group_name']
        path_param_values = self.encode_path_vars(secret_type, name, secret_group_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secret_groups/{secret_group_name}/secret_types/{secret_type}/secrets/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Secret versions
    #########################

    def create_secret_version(
        self,
        secret_id: str,
        secret_version_prototype: 'SecretVersionPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new secret version.

        Create a new secret version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param SecretVersionPrototype secret_version_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersion` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if secret_version_prototype is None:
            raise ValueError('secret_version_prototype must be provided')
        if isinstance(secret_version_prototype, SecretVersionPrototype):
            secret_version_prototype = convert_model(secret_version_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_version',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_version_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id']
        path_param_values = self.encode_path_vars(secret_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_versions(
        self,
        secret_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        List versions of a secret.

        List the versions of a secret.
        A successful request returns the list of versions of a secret, along with the
        metadata of each version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionMetadataCollection` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_versions',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id']
        path_param_values = self.encode_path_vars(secret_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_version(
        self,
        secret_id: str,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a version of a secret.

        Get a version of a secret by specifying the ID of the version. You can use the
        `current` or `previous` aliases to refer to the current or previous secret
        version.
        A successful request returns the secret data that is associated with the specified
        version of your secret, along with other metadata.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersion` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_version',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_version_data(
        self,
        secret_id: str,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete the data of a secret version.

        Delete the data of a secret version by specifying the ID of the version.
        This operation is available for secret type: iam_credentials current version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_version_data',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/secret_data'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_secret_version_metadata(
        self,
        secret_id: str,
        id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get the metadata of a secret version.

        Get the metadata of a secret version by specifying the ID of the version. You can
        use the `current` or `previous` aliases to refer to the current or previous secret
        version.
        A successful request returns the metadata that is associated with the specified
        version of your secret.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionMetadata` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_secret_version_metadata',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_secret_version_metadata(
        self,
        secret_id: str,
        id: str,
        secret_version_metadata_patch: 'SecretVersionMetadataPatch',
        **kwargs,
    ) -> DetailedResponse:
        """
        Update the metadata of a secret version.

        Update the custom metadata of a secret version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param SecretVersionMetadataPatch secret_version_metadata_patch:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionMetadata` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        if secret_version_metadata_patch is None:
            raise ValueError('secret_version_metadata_patch must be provided')
        if isinstance(secret_version_metadata_patch, SecretVersionMetadataPatch):
            secret_version_metadata_patch = convert_model(secret_version_metadata_patch)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_secret_version_metadata',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_version_metadata_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_version_action(
        self,
        secret_id: str,
        id: str,
        secret_version_action_prototype: 'SecretVersionActionPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a version action.

        Create a secret version action. This operation supports the following actions:
        - `private_cert_action_revoke_certificate`: Revoke a version of a private
        certificate.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param SecretVersionActionPrototype secret_version_action_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VersionAction` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        if secret_version_action_prototype is None:
            raise ValueError('secret_version_action_prototype must be provided')
        if isinstance(secret_version_action_prototype, SecretVersionActionPrototype):
            secret_version_action_prototype = convert_model(secret_version_action_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_version_action',
        )
        headers.update(sdk_headers)

        data = json.dumps(secret_version_action_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Secret locks
    #########################

    def list_secrets_locks(
        self,
        *,
        offset: int = None,
        limit: int = None,
        search: str = None,
        groups: List[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secrets and their locks.

        List the secrets and their locks in your Secrets Manager instance.

        :param int offset: (optional) The number of secrets to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 secrets in your instance, and you want to
               retrieve secrets 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretsLocksPaginatedCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secrets_locks',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'search': search,
            'groups': convert_list(groups),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/secrets_locks'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_locks(
        self,
        id: str,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        search: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secret locks.

        List the locks that are associated with a specified secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param int offset: (optional) The number of locks to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 locks on your secret, and you want to retrieve
               locks 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocksPaginatedCollection` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_locks',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/locks'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_locks_bulk(
        self,
        id: str,
        locks: List['SecretLockPrototype'],
        *,
        mode: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create secret locks.

        Create a lock on the current version of a secret.
        A lock can be used to prevent a secret from being deleted or modified while it's
        in use by your applications. A successful request attaches a new lock to your
        secret, or replaces a lock of the same name if it already exists. Additionally,
        you can use this operation to clear any matching locks on a secret by using one of
        the following optional lock modes:
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret.\n
        - `remove_previous_and_delete`: Carries out the same function as
        `remove_previous`, but also permanently deletes the data of the previous secret
        version if it doesn't have any locks.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param List[SecretLockPrototype] locks: The locks data to be attached to a
               secret version.
        :param str mode: (optional) An optional lock mode. When you create a lock,
               you can set one of the following modes to clear any matching locks on a
               secret version.
               - `remove_previous`: Removes any other locks with matching names if they
               are found in the previous version of the secret. -
               `remove_previous_and_delete`: Completes the same action as
               `remove_previous`, but also permanently deletes the data of the previous
               secret version if it doesn't have any locks.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not id:
            raise ValueError('id must be provided')
        if locks is None:
            raise ValueError('locks must be provided')
        locks = [convert_model(x) for x in locks]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'mode': mode,
        }

        data = {
            'locks': locks,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            params=params,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_locks_bulk(
        self,
        id: str,
        *,
        name: List[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete secret locks.

        Delete all the locks or a subset of the locks that are associated with a version
        of a secret.
        To delete only a subset of the locks, add a query param with a comma to separate
        the list of lock names:
        Example: `?name=lock-example-1,lock-example-2`.
        **Note:** A secret is considered unlocked and able to be deleted only after you
        remove all of its locks. To determine whether a secret contains locks, check the
        `locks_total` field that is returned as part of the metadata of your secret.

        :param str id: The v4 UUID that uniquely identifies your secret.
        :param List[str] name: (optional) Specify the names of the secret locks to
               be deleted.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'name': convert_list(name),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['id']
        path_param_values = self.encode_path_vars(id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def list_secret_version_locks(
        self,
        secret_id: str,
        id: str,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        search: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List secret version locks.

        List the locks that are associated with a specified secret version.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param int offset: (optional) The number of locks to skip. By specifying
               `offset`, you retrieve a subset of items that starts with the `offset`
               value. Use `offset` with `limit` to page through your available resources.
               **Usage:** If you have 100 locks on your secret, and you want to retrieve
               locks 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretVersionLocksPaginatedCollection` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_secret_version_locks',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/locks'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_secret_version_locks_bulk(
        self,
        secret_id: str,
        id: str,
        locks: List['SecretLockPrototype'],
        *,
        mode: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create secret version locks.

        Create a lock on the specified version of a secret.
        A lock can be used to prevent a secret from being deleted or modified while it's
        in use by your applications. A successful request attaches a new lock to your
        secret, or replaces a lock of the same name if it already exists. Additionally,
        you can use this operation to clear any matching locks on a secret by using one of
        the following optional lock modes:
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret.
        - `remove_previous_and_delete`: Carries out the same function as
        `remove_previous`, but also permanently deletes the data of the previous secret
        version if it doesn't have any locks.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param List[SecretLockPrototype] locks: The locks data to be attached to a
               secret version.
        :param str mode: (optional) An optional lock mode. When you create a lock,
               you can set one of the following modes to clear any matching locks on a
               secret version.
               - `remove_previous`: Removes any other locks with matching names if they
               are found in the previous version of the secret. -
               `remove_previous_and_delete`: Completes the same action as
               `remove_previous`, but also permanently deletes the data of the previous
               secret version if it doesn't have any locks.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        if locks is None:
            raise ValueError('locks must be provided')
        locks = [convert_model(x) for x in locks]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_secret_version_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'mode': mode,
        }

        data = {
            'locks': locks,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            params=params,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_secret_version_locks_bulk(
        self,
        secret_id: str,
        id: str,
        *,
        name: List[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete locks on a secret version.

        Delete all the locks or a subset of the locks that are associated with the
        specified version of a secret.
        To delete only a subset of the locks, add a query param with a comma to separate
        the list of lock names:
        Example: `?name=lock-example-1,lock-example-2`.
        **Note:** A secret is considered unlocked and able to be deleted only after all of
        its locks are removed. To determine whether a secret contains locks, check the
        `locks_total` field that is returned as part of the metadata of your secret.

        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param List[str] name: (optional) Specify the names of the secret locks to
               be deleted.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SecretLocks` object
        """

        if not secret_id:
            raise ValueError('secret_id must be provided')
        if not id:
            raise ValueError('id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_secret_version_locks_bulk',
        )
        headers.update(sdk_headers)

        params = {
            'name': convert_list(name),
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['secret_id', 'id']
        path_param_values = self.encode_path_vars(secret_id, id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/secrets/{secret_id}/versions/{id}/locks_bulk'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Configurations
    #########################

    def create_configuration(
        self,
        configuration_prototype: 'ConfigurationPrototype',
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a new configuration.

        Add a configuration to the specified secret type.
        Use this operation to define the configurations that are required to create public
        certificates (`public_cert`), private certificates (`private_cert`) and IAM
        Credentials secrets (`iam_credentials`).
        You can add multiple configurations for your instance as follows:
        - A single configuration for IAM Credentials.
        - Up to 10 CA configurations for public certificates.
        - Up to 10 DNS configurations for public certificates.
        - Up to 10 Root CA configurations for private certificates.
        - Up to 10 Intermediate CA configurations for private certificates.
        - Up to 10 Certificate Template configurations for private certificates.

        :param ConfigurationPrototype configuration_prototype:
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Configuration` object
        """

        if configuration_prototype is None:
            raise ValueError('configuration_prototype must be provided')
        if isinstance(configuration_prototype, ConfigurationPrototype):
            configuration_prototype = convert_model(configuration_prototype)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_configuration',
        )
        headers.update(sdk_headers)

        data = json.dumps(configuration_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/configurations'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_configurations(
        self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        search: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List configurations.

        List the configurations that are available in your Secrets Manager instance.

        :param int offset: (optional) The number of configurations to skip. By
               specifying `offset`, you retrieve a subset of items that starts with the
               `offset` value. Use `offset` with `limit` to page through your available
               resources.
               **Usage:** If you have 100 configurations in your instance, and you want to
               retrieve configurations 26 through 50, use
               `..?offset=25&limit=25`.
        :param int limit: (optional) The number of configurations to retrieve. By
               default, list operations return the first 200 items. To retrieve a
               different set of items, use `limit` with `offset` to page through your
               available resources. Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 configurations in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of configurations by the
               specified field in ascending order. To sort in descending order use the `-`
               character
               **Available values:**  config_type | secret_type | name
               **Usage:** To sort a list of configurations by their creation date, use
               `../configurations?sort=config_type`.
        :param str search: (optional) Obtain a collection of configurations that
               contain the specified string in one or more of the fields: `name`,
               `config_type`, `secret_type`.
               **Usage:** If you want to list only the configurations that contain the
               string `text`, use
               `../configurations?search=text`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ConfigurationMetadataPaginatedCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='list_configurations',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'search': search,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/configurations'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_configuration(
        self,
        name: str,
        *,
        x_sm_accept_configuration_type: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a configuration.

        Get a configuration by specifying its name.
        A successful request returns the details of your configuration.

        :param str name: The name that uniquely identifies a configuration.
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Configuration` object
        """

        if not name:
            raise ValueError('name must be provided')
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_configuration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_configuration(
        self,
        name: str,
        configuration_patch: 'ConfigurationPatch',
        *,
        x_sm_accept_configuration_type: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update configuration.

        Update a configuration.

        :param str name: The name that uniquely identifies a configuration.
        :param ConfigurationPatch configuration_patch:
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Configuration` object
        """

        if not name:
            raise ValueError('name must be provided')
        if configuration_patch is None:
            raise ValueError('configuration_patch must be provided')
        if isinstance(configuration_patch, ConfigurationPatch):
            configuration_patch = convert_model(configuration_patch)
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='update_configuration',
        )
        headers.update(sdk_headers)

        data = json.dumps(configuration_patch)
        headers['content-type'] = 'application/merge-patch+json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_configuration(
        self,
        name: str,
        *,
        x_sm_accept_configuration_type: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a configuration.

        Delete a configuration by specifying its name.

        :param str name: The name that uniquely identifies a configuration.
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not name:
            raise ValueError('name must be provided')
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_configuration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def create_configuration_action(
        self,
        name: str,
        config_action_prototype: 'ConfigurationActionPrototype',
        *,
        x_sm_accept_configuration_type: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a configuration action.

        Create a configuration action. This operation supports the following actions:
        - `private_cert_configuration_action_sign_intermediate`: Sign an intermediate
        certificate authority.
        - `private_cert_configuration_action_sign_csr`: Sign a certificate signing
        request.
        - `private_cert_configuration_action_set_signed`: Set a signed intermediate
        certificate authority.
        - `private_cert_configuration_action_revoke_ca_certificate`: Revoke an internally
        signed intermediate certificate authority certificate.
        - `private_cert_configuration_action_rotate_crl`: Rotate the certificate
        revocation list (CRL) of an intermediate certificate authority.

        :param str name: The name that uniquely identifies a configuration.
        :param ConfigurationActionPrototype config_action_prototype:
        :param str x_sm_accept_configuration_type: (optional) The configuration
               type of this configuration - use this header to resolve 300 error
               responses.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ConfigurationAction` object
        """

        if not name:
            raise ValueError('name must be provided')
        if config_action_prototype is None:
            raise ValueError('config_action_prototype must be provided')
        if isinstance(config_action_prototype, ConfigurationActionPrototype):
            config_action_prototype = convert_model(config_action_prototype)
        headers = {
            'X-Sm-Accept-Configuration-Type': x_sm_accept_configuration_type,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_configuration_action',
        )
        headers.update(sdk_headers)

        data = json.dumps(config_action_prototype)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['name']
        path_param_values = self.encode_path_vars(name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/api/v2/configurations/{name}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # Notifications
    #########################

    def create_notifications_registration(
        self,
        event_notifications_instance_crn: str,
        event_notifications_source_name: str,
        *,
        event_notifications_source_description: str = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Register with Event Notifications instance.

        Create a registration between a Secrets Manager instance and [Event
        Notifications](https://cloud.ibm.com/apidocs/event-notifications).
        A successful request adds Secrets Manager as a source that you can reference from
        your Event Notifications instance. For more information about enabling
        notifications for Secrets Manager, check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).

        :param str event_notifications_instance_crn: A CRN that uniquely identifies
               an IBM Cloud resource.
        :param str event_notifications_source_name: The name that is displayed as a
               source that is in your Event Notifications instance.
        :param str event_notifications_source_description: (optional) An optional
               description for the source that is in your Event Notifications instance.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `NotificationsRegistration` object
        """

        if event_notifications_instance_crn is None:
            raise ValueError('event_notifications_instance_crn must be provided')
        if event_notifications_source_name is None:
            raise ValueError('event_notifications_source_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='create_notifications_registration',
        )
        headers.update(sdk_headers)

        data = {
            'event_notifications_instance_crn': event_notifications_instance_crn,
            'event_notifications_source_name': event_notifications_source_name,
            'event_notifications_source_description': event_notifications_source_description,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/notifications/registration'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_notifications_registration(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get Event Notifications registration details.

        Get the details of the registration between your Secrets Manager instance and
        Event Notifications.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `NotificationsRegistration` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_notifications_registration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/api/v2/notifications/registration'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_notifications_registration(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Unregister from Event Notifications instance.

        Delete the registration between your Secrets Manager instance and Event
        Notifications.
        A successful request removes your Secrets Manager instance as a source in Event
        Notifications.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='delete_notifications_registration',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        url = '/api/v2/notifications/registration'
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_notifications_registration_test(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Send a test event for Event Notifications registrations.

        Send a test event from a Secrets Manager instance to a configured [Event
        Notifications](https://cloud.ibm.com/apidocs/event-notifications) instance.
        A successful request sends a test event to the Event Notifications instance. For
        more information about enabling notifications for Secrets Manager, check out the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V2',
            operation_id='get_notifications_registration_test',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        url = '/api/v2/notifications/registration/test'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response


class GetSecretByNameTypeEnums:
    """
    Enums for get_secret_by_name_type parameters.
    """

    class SecretType(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


class CreateSecretLocksBulkEnums:
    """
    Enums for create_secret_locks_bulk parameters.
    """

    class Mode(str, Enum):
        """
        An optional lock mode. When you create a lock, you can set one of the following
        modes to clear any matching locks on a secret version.
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret. - `remove_previous_and_delete`: Completes
        the same action as `remove_previous`, but also permanently deletes the data of the
        previous secret version if it doesn't have any locks.
        """

        REMOVE_PREVIOUS = 'remove_previous'
        REMOVE_PREVIOUS_AND_DELETE = 'remove_previous_and_delete'


class CreateSecretVersionLocksBulkEnums:
    """
    Enums for create_secret_version_locks_bulk parameters.
    """

    class Mode(str, Enum):
        """
        An optional lock mode. When you create a lock, you can set one of the following
        modes to clear any matching locks on a secret version.
        - `remove_previous`: Removes any other locks with matching names if they are found
        in the previous version of the secret. - `remove_previous_and_delete`: Completes
        the same action as `remove_previous`, but also permanently deletes the data of the
        previous secret version if it doesn't have any locks.
        """

        REMOVE_PREVIOUS = 'remove_previous'
        REMOVE_PREVIOUS_AND_DELETE = 'remove_previous_and_delete'


class GetConfigurationEnums:
    """
    Enums for get_configuration parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


class UpdateConfigurationEnums:
    """
    Enums for update_configuration parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


class DeleteConfigurationEnums:
    """
    Enums for delete_configuration parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


class CreateConfigurationActionEnums:
    """
    Enums for create_configuration_action parameters.
    """

    class XSmAcceptConfigurationType(str, Enum):
        """
        The configuration type of this configuration - use this header to resolve 300
        error responses.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


##############################################################################
# Models
##############################################################################


class CertificateIssuanceInfo:
    """
    Issuance information that is associated with your certificate.

    :attr bool auto_rotated: (optional) This parameter indicates whether the issued
          certificate is configured with an automatic rotation policy.
    :attr List[ChallengeResource] challenges: (optional) The set of challenges. It
          is returned only when ordering public certificates by using manual DNS
          configuration.
    :attr datetime dns_challenge_validation_time: (optional) The date that a user
          requests to validate DNS challenges for certificates that are ordered with a
          manual DNS provider. The date format follows `RFC 3339`.
    :attr str error_code: (optional) A code that identifies an issuance error.
          This field, along with `error_message`, is returned when Secrets Manager
          successfully processes your request, but the certificate authority is unable to
          issue a certificate.
    :attr str error_message: (optional) A human-readable message that provides
          details about the issuance error.
    :attr datetime ordered_on: (optional) The date when the certificate is ordered.
          The date format follows `RFC 3339`.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    """

    def __init__(
        self,
        *,
        auto_rotated: bool = None,
        challenges: List['ChallengeResource'] = None,
        dns_challenge_validation_time: datetime = None,
        error_code: str = None,
        error_message: str = None,
        ordered_on: datetime = None,
        state: int = None,
        state_description: str = None,
    ) -> None:
        """
        Initialize a CertificateIssuanceInfo object.

        """
        self.auto_rotated = auto_rotated
        self.challenges = challenges
        self.dns_challenge_validation_time = dns_challenge_validation_time
        self.error_code = error_code
        self.error_message = error_message
        self.ordered_on = ordered_on
        self.state = state
        self.state_description = state_description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CertificateIssuanceInfo':
        """Initialize a CertificateIssuanceInfo object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'challenges' in _dict:
            args['challenges'] = [ChallengeResource.from_dict(v) for v in _dict.get('challenges')]
        if 'dns_challenge_validation_time' in _dict:
            args['dns_challenge_validation_time'] = string_to_datetime(_dict.get('dns_challenge_validation_time'))
        if 'error_code' in _dict:
            args['error_code'] = _dict.get('error_code')
        if 'error_message' in _dict:
            args['error_message'] = _dict.get('error_message')
        if 'ordered_on' in _dict:
            args['ordered_on'] = string_to_datetime(_dict.get('ordered_on'))
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CertificateIssuanceInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and getattr(self, 'auto_rotated') is not None:
            _dict['auto_rotated'] = getattr(self, 'auto_rotated')
        if hasattr(self, 'challenges') and getattr(self, 'challenges') is not None:
            challenges_list = []
            for v in getattr(self, 'challenges'):
                if isinstance(v, dict):
                    challenges_list.append(v)
                else:
                    challenges_list.append(v.to_dict())
            _dict['challenges'] = challenges_list
        if hasattr(self, 'dns_challenge_validation_time') and getattr(self, 'dns_challenge_validation_time') is not None:
            _dict['dns_challenge_validation_time'] = datetime_to_string(getattr(self, 'dns_challenge_validation_time'))
        if hasattr(self, 'error_code') and getattr(self, 'error_code') is not None:
            _dict['error_code'] = getattr(self, 'error_code')
        if hasattr(self, 'error_message') and getattr(self, 'error_message') is not None:
            _dict['error_message'] = getattr(self, 'error_message')
        if hasattr(self, 'ordered_on') and getattr(self, 'ordered_on') is not None:
            _dict['ordered_on'] = datetime_to_string(getattr(self, 'ordered_on'))
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CertificateIssuanceInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CertificateIssuanceInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CertificateIssuanceInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class CertificateValidity:
    """
    The date and time that the certificate validity period begins and ends.

    :attr datetime not_before: The date-time format follows `RFC 3339`.
    :attr datetime not_after: The date-time format follows `RFC 3339`.
    """

    def __init__(
        self,
        not_before: datetime,
        not_after: datetime,
    ) -> None:
        """
        Initialize a CertificateValidity object.

        :param datetime not_before: The date-time format follows `RFC 3339`.
        :param datetime not_after: The date-time format follows `RFC 3339`.
        """
        self.not_before = not_before
        self.not_after = not_after

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CertificateValidity':
        """Initialize a CertificateValidity object from a json dictionary."""
        args = {}
        if 'not_before' in _dict:
            args['not_before'] = string_to_datetime(_dict.get('not_before'))
        else:
            raise ValueError('Required property \'not_before\' not present in CertificateValidity JSON')
        if 'not_after' in _dict:
            args['not_after'] = string_to_datetime(_dict.get('not_after'))
        else:
            raise ValueError('Required property \'not_after\' not present in CertificateValidity JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CertificateValidity object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'not_before') and self.not_before is not None:
            _dict['not_before'] = datetime_to_string(self.not_before)
        if hasattr(self, 'not_after') and self.not_after is not None:
            _dict['not_after'] = datetime_to_string(self.not_after)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CertificateValidity object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CertificateValidity') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CertificateValidity') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ChallengeResource:
    """
    Properties that describe a challenge.

    :attr str domain: (optional) The challenge domain.
    :attr datetime expiration: (optional) The challenge expiration date. The date
          format follows `RFC 3339`.
    :attr str status: (optional) The challenge status.
    :attr str txt_record_name: (optional) The TXT record name.
    :attr str txt_record_value: (optional) The TXT record value.
    """

    def __init__(
        self,
        *,
        domain: str = None,
        expiration: datetime = None,
        status: str = None,
        txt_record_name: str = None,
        txt_record_value: str = None,
    ) -> None:
        """
        Initialize a ChallengeResource object.

        """
        self.domain = domain
        self.expiration = expiration
        self.status = status
        self.txt_record_name = txt_record_name
        self.txt_record_value = txt_record_value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ChallengeResource':
        """Initialize a ChallengeResource object from a json dictionary."""
        args = {}
        if 'domain' in _dict:
            args['domain'] = _dict.get('domain')
        if 'expiration' in _dict:
            args['expiration'] = string_to_datetime(_dict.get('expiration'))
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'txt_record_name' in _dict:
            args['txt_record_name'] = _dict.get('txt_record_name')
        if 'txt_record_value' in _dict:
            args['txt_record_value'] = _dict.get('txt_record_value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ChallengeResource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'domain') and getattr(self, 'domain') is not None:
            _dict['domain'] = getattr(self, 'domain')
        if hasattr(self, 'expiration') and getattr(self, 'expiration') is not None:
            _dict['expiration'] = datetime_to_string(getattr(self, 'expiration'))
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        if hasattr(self, 'txt_record_name') and getattr(self, 'txt_record_name') is not None:
            _dict['txt_record_name'] = getattr(self, 'txt_record_name')
        if hasattr(self, 'txt_record_value') and getattr(self, 'txt_record_value') is not None:
            _dict['txt_record_value'] = getattr(self, 'txt_record_value')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ChallengeResource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ChallengeResource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ChallengeResource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Configuration:
    """
    Your configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a Configuration object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PublicCertificateConfigurationCALetsEncrypt', 'PublicCertificateConfigurationDNSCloudInternetServices', 'PublicCertificateConfigurationDNSClassicInfrastructure', 'IAMCredentialsConfiguration', 'PrivateCertificateConfigurationRootCA', 'PrivateCertificateConfigurationIntermediateCA', 'PrivateCertificateConfigurationTemplate'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Configuration':
        """Initialize a Configuration object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'Configuration'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PublicCertificateConfigurationCALetsEncrypt', 'PublicCertificateConfigurationDNSCloudInternetServices', 'PublicCertificateConfigurationDNSClassicInfrastructure', 'IAMCredentialsConfiguration', 'PrivateCertificateConfigurationRootCA', 'PrivateCertificateConfigurationIntermediateCA', 'PrivateCertificateConfigurationTemplate'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a Configuration object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['public_cert_configuration_ca_lets_encrypt'] = 'PublicCertificateConfigurationCALetsEncrypt'
        mapping['public_cert_configuration_dns_cloud_internet_services'] = 'PublicCertificateConfigurationDNSCloudInternetServices'
        mapping['public_cert_configuration_dns_classic_infrastructure'] = 'PublicCertificateConfigurationDNSClassicInfrastructure'
        mapping['iam_credentials_configuration'] = 'IAMCredentialsConfiguration'
        mapping['private_cert_configuration_root_ca'] = 'PrivateCertificateConfigurationRootCA'
        mapping['private_cert_configuration_intermediate_ca'] = 'PrivateCertificateConfigurationIntermediateCA'
        mapping['private_cert_configuration_template'] = 'PrivateCertificateConfigurationTemplate'
        disc_value = _dict.get('config_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'config_type\' not found in Configuration JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationAction:
    """
    The response body to specify the properties of the action to create a configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationAction object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationActionRevoke', 'PrivateCertificateConfigurationActionSignCSR', 'PrivateCertificateConfigurationActionSignIntermediate', 'PrivateCertificateConfigurationActionSetSigned', 'PrivateCertificateConfigurationActionRotateCRL'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationAction':
        """Initialize a ConfigurationAction object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationAction'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateConfigurationActionRevoke', 'PrivateCertificateConfigurationActionSignCSR', 'PrivateCertificateConfigurationActionSignIntermediate', 'PrivateCertificateConfigurationActionSetSigned', 'PrivateCertificateConfigurationActionRotateCRL'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationAction object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_configuration_action_revoke_ca_certificate'] = 'PrivateCertificateConfigurationActionRevoke'
        mapping['private_cert_configuration_action_sign_csr'] = 'PrivateCertificateConfigurationActionSignCSR'
        mapping['private_cert_configuration_action_sign_intermediate'] = 'PrivateCertificateConfigurationActionSignIntermediate'
        mapping['private_cert_configuration_action_set_signed'] = 'PrivateCertificateConfigurationActionSetSigned'
        mapping['private_cert_configuration_action_rotate_crl'] = 'PrivateCertificateConfigurationActionRotateCRL'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in ConfigurationAction JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationActionPrototype:
    """
    The request body to specify the properties of the action to create a configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationActionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationActionRotateCRLPrototype', 'PrivateCertificateConfigurationActionRevokePrototype', 'PrivateCertificateConfigurationActionSignCSRPrototype', 'PrivateCertificateConfigurationActionSignIntermediatePrototype', 'PrivateCertificateConfigurationActionSetSignedPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationActionPrototype':
        """Initialize a ConfigurationActionPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationActionPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateConfigurationActionRotateCRLPrototype', 'PrivateCertificateConfigurationActionRevokePrototype', 'PrivateCertificateConfigurationActionSignCSRPrototype', 'PrivateCertificateConfigurationActionSignIntermediatePrototype', 'PrivateCertificateConfigurationActionSetSignedPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationActionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_configuration_action_rotate_crl'] = 'PrivateCertificateConfigurationActionRotateCRLPrototype'
        mapping['private_cert_configuration_action_revoke_ca_certificate'] = 'PrivateCertificateConfigurationActionRevokePrototype'
        mapping['private_cert_configuration_action_sign_csr'] = 'PrivateCertificateConfigurationActionSignCSRPrototype'
        mapping['private_cert_configuration_action_sign_intermediate'] = 'PrivateCertificateConfigurationActionSignIntermediatePrototype'
        mapping['private_cert_configuration_action_set_signed'] = 'PrivateCertificateConfigurationActionSetSignedPrototype'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in ConfigurationActionPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationMetadata:
    """
    Your configuration metadata properties.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationMetadata object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['IAMCredentialsConfigurationMetadata', 'PublicCertificateConfigurationCALetsEncryptMetadata', 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata', 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata', 'PrivateCertificateConfigurationRootCAMetadata', 'PrivateCertificateConfigurationIntermediateCAMetadata', 'PrivateCertificateConfigurationTemplateMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationMetadata':
        """Initialize a ConfigurationMetadata object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationMetadata'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['IAMCredentialsConfigurationMetadata', 'PublicCertificateConfigurationCALetsEncryptMetadata', 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata', 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata', 'PrivateCertificateConfigurationRootCAMetadata', 'PrivateCertificateConfigurationIntermediateCAMetadata', 'PrivateCertificateConfigurationTemplateMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['iam_credentials_configuration'] = 'IAMCredentialsConfigurationMetadata'
        mapping['public_cert_configuration_ca_lets_encrypt'] = 'PublicCertificateConfigurationCALetsEncryptMetadata'
        mapping['public_cert_configuration_dns_cloud_internet_services'] = 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata'
        mapping['public_cert_configuration_dns_classic_infrastructure'] = 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata'
        mapping['private_cert_configuration_root_ca'] = 'PrivateCertificateConfigurationRootCAMetadata'
        mapping['private_cert_configuration_intermediate_ca'] = 'PrivateCertificateConfigurationIntermediateCAMetadata'
        mapping['private_cert_configuration_template'] = 'PrivateCertificateConfigurationTemplateMetadata'
        disc_value = _dict.get('config_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'config_type\' not found in ConfigurationMetadata JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ConfigurationMetadataPaginatedCollection:
    """
    Properties that describe a paginated collection of secret locks.

    :attr int total_count: The total number of resources in a collection.
    :attr int limit: The number of items that are retrieved in a collection.
    :attr int offset: The number of items that are skipped in a collection.
    :attr PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :attr PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :attr PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :attr PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :attr List[ConfigurationMetadata] configurations: A collection of configuration
          metadata.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        configurations: List['ConfigurationMetadata'],
        *,
        next: 'PaginatedCollectionNext' = None,
        previous: 'PaginatedCollectionPrevious' = None,
    ) -> None:
        """
        Initialize a ConfigurationMetadataPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[ConfigurationMetadata] configurations: A collection of
               configuration metadata.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.configurations = configurations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationMetadataPaginatedCollection':
        """Initialize a ConfigurationMetadataPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in ConfigurationMetadataPaginatedCollection JSON')
        if 'configurations' in _dict:
            args['configurations'] = [ConfigurationMetadata.from_dict(v) for v in _dict.get('configurations')]
        else:
            raise ValueError('Required property \'configurations\' not present in ConfigurationMetadataPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ConfigurationMetadataPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'configurations') and self.configurations is not None:
            configurations_list = []
            for v in self.configurations:
                if isinstance(v, dict):
                    configurations_list.append(v)
                else:
                    configurations_list.append(v.to_dict())
            _dict['configurations'] = configurations_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ConfigurationMetadataPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ConfigurationMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ConfigurationMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ConfigurationPatch:
    """
    Your configuration update data.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationPatch object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['IAMCredentialsConfigurationPatch', 'PrivateCertificateConfigurationRootCAPatch', 'PrivateCertificateConfigurationIntermediateCAPatch', 'PrivateCertificateConfigurationTemplatePatch', 'PublicCertificateConfigurationCALetsEncryptPatch', 'PublicCertificateConfigurationDNSCloudInternetServicesPatch', 'PublicCertificateConfigurationDNSClassicInfrastructurePatch'])
        )
        raise Exception(msg)


class ConfigurationPrototype:
    """
    The details of your configuration.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a ConfigurationPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationRootCAPrototype', 'PrivateCertificateConfigurationIntermediateCAPrototype', 'PrivateCertificateConfigurationTemplatePrototype', 'PublicCertificateConfigurationCALetsEncryptPrototype', 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype', 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype', 'IAMCredentialsConfigurationPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConfigurationPrototype':
        """Initialize a ConfigurationPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'ConfigurationPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateConfigurationRootCAPrototype', 'PrivateCertificateConfigurationIntermediateCAPrototype', 'PrivateCertificateConfigurationTemplatePrototype', 'PublicCertificateConfigurationCALetsEncryptPrototype', 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype', 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype', 'IAMCredentialsConfigurationPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a ConfigurationPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_configuration_root_ca'] = 'PrivateCertificateConfigurationRootCAPrototype'
        mapping['private_cert_configuration_intermediate_ca'] = 'PrivateCertificateConfigurationIntermediateCAPrototype'
        mapping['private_cert_configuration_template'] = 'PrivateCertificateConfigurationTemplatePrototype'
        mapping['public_cert_configuration_ca_lets_encrypt'] = 'PublicCertificateConfigurationCALetsEncryptPrototype'
        mapping['public_cert_configuration_dns_cloud_internet_services'] = 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype'
        mapping['public_cert_configuration_dns_classic_infrastructure'] = 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype'
        mapping['iam_credentials_configuration'] = 'IAMCredentialsConfigurationPrototype'
        disc_value = _dict.get('config_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'config_type\' not found in ConfigurationPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class NotificationsRegistration:
    """
    The details of the Event Notifications registration.

    :attr str event_notifications_instance_crn: A CRN that uniquely identifies an
          IBM Cloud resource.
    """

    def __init__(
        self,
        event_notifications_instance_crn: str,
    ) -> None:
        """
        Initialize a NotificationsRegistration object.

        :param str event_notifications_instance_crn: A CRN that uniquely identifies
               an IBM Cloud resource.
        """
        self.event_notifications_instance_crn = event_notifications_instance_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'NotificationsRegistration':
        """Initialize a NotificationsRegistration object from a json dictionary."""
        args = {}
        if 'event_notifications_instance_crn' in _dict:
            args['event_notifications_instance_crn'] = _dict.get('event_notifications_instance_crn')
        else:
            raise ValueError('Required property \'event_notifications_instance_crn\' not present in NotificationsRegistration JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a NotificationsRegistration object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'event_notifications_instance_crn') and self.event_notifications_instance_crn is not None:
            _dict['event_notifications_instance_crn'] = self.event_notifications_instance_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this NotificationsRegistration object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'NotificationsRegistration') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'NotificationsRegistration') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionFirst:
    """
    A URL that points to the first page in a collection.

    :attr str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionFirst object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionFirst':
        """Initialize a PaginatedCollectionFirst object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionFirst JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionFirst object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionFirst object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionFirst') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionFirst') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionLast:
    """
    A URL that points to the last page in a collection.

    :attr str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionLast object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionLast':
        """Initialize a PaginatedCollectionLast object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionLast JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionLast object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionLast object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionLast') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionLast') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionNext:
    """
    A URL that points to the next page in a collection.

    :attr str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionNext object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionNext':
        """Initialize a PaginatedCollectionNext object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionNext JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionNext object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionNext object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionNext') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionNext') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginatedCollectionPrevious:
    """
    A URL that points to the previous page in a collection.

    :attr str href: A URL that points to a page in a collection.
    """

    def __init__(
        self,
        href: str,
    ) -> None:
        """
        Initialize a PaginatedCollectionPrevious object.

        :param str href: A URL that points to a page in a collection.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginatedCollectionPrevious':
        """Initialize a PaginatedCollectionPrevious object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        else:
            raise ValueError('Required property \'href\' not present in PaginatedCollectionPrevious JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginatedCollectionPrevious object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginatedCollectionPrevious object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginatedCollectionPrevious') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginatedCollectionPrevious') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateCAData:
    """
    The configuration data of your Private Certificate.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a PrivateCertificateCAData object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateConfigurationIntermediateCACSR', 'PrivateCertificateConfigurationCACertificate'])
        )
        raise Exception(msg)


class PublicCertificateRotationObject:
    """
    Defines the rotation object that is used to manually rotate public certificates.

    :attr bool rotate_keys: (optional) This field indicates whether Secrets Manager
          rotates the private key for your public certificate automatically.
          The default is `false`. If it is set to `true`, the service generates and stores
          a new private key for your rotated certificate.
    """

    def __init__(
        self,
        *,
        rotate_keys: bool = None,
    ) -> None:
        """
        Initialize a PublicCertificateRotationObject object.

        :param bool rotate_keys: (optional) This field indicates whether Secrets
               Manager rotates the private key for your public certificate automatically.
               The default is `false`. If it is set to `true`, the service generates and
               stores a new private key for your rotated certificate.
        """
        self.rotate_keys = rotate_keys

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateRotationObject':
        """Initialize a PublicCertificateRotationObject object from a json dictionary."""
        args = {}
        if 'rotate_keys' in _dict:
            args['rotate_keys'] = _dict.get('rotate_keys')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateRotationObject object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'rotate_keys') and self.rotate_keys is not None:
            _dict['rotate_keys'] = self.rotate_keys
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateRotationObject object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateRotationObject') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateRotationObject') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class RotationPolicy:
    """
    This field indicates whether Secrets Manager rotates your secrets automatically.
    Supported secret types: username_password, private_cert, public_cert, iam_credentials.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a RotationPolicy object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['CommonRotationPolicy', 'PublicCertificateRotationPolicy'])
        )
        raise Exception(msg)


class Secret:
    """
    Your secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a Secret object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecret', 'ImportedCertificate', 'PublicCertificate', 'PrivateCertificate', 'KVSecret', 'IAMCredentialsSecret', 'UsernamePasswordSecret'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Secret':
        """Initialize a Secret object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'Secret'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecret', 'ImportedCertificate', 'PublicCertificate', 'PrivateCertificate', 'KVSecret', 'IAMCredentialsSecret', 'UsernamePasswordSecret'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a Secret object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecret'
        mapping['imported_cert'] = 'ImportedCertificate'
        mapping['public_cert'] = 'PublicCertificate'
        mapping['private_cert'] = 'PrivateCertificate'
        mapping['kv'] = 'KVSecret'
        mapping['iam_credentials'] = 'IAMCredentialsSecret'
        mapping['username_password'] = 'UsernamePasswordSecret'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in Secret JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretAction:
    """
    The response body to specify the properties of the action to create a secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretAction object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PublicCertificateActionValidateManualDNS', 'PrivateCertificateActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretAction':
        """Initialize a SecretAction object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretAction'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PublicCertificateActionValidateManualDNS', 'PrivateCertificateActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretAction object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateActionRevoke'
        mapping['public_cert_action_validate_dns_challenge'] = 'PublicCertificateActionValidateManualDNS'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in SecretAction JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretActionPrototype:
    """
    The request body to specify the properties for your secret action.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretActionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateActionRevokePrototype', 'PublicCertificateActionValidateManualDNSPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretActionPrototype':
        """Initialize a SecretActionPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretActionPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateActionRevokePrototype', 'PublicCertificateActionValidateManualDNSPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretActionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['public_cert_action_validate_dns_challenge'] = 'PublicCertificateActionValidateManualDNSPrototype'
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateActionRevokePrototype'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in SecretActionPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretGroup:
    """
    Properties that describe a secret group.

    :attr str id: A v4 UUID identifier, or `default` secret group.
    :attr str name: (optional) The name of your existing secret group.
    :attr str description: An extended description of your secret group.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        id: str,
        description: str,
        created_at: datetime,
        created_by: str,
        updated_at: datetime,
        *,
        name: str = None,
    ) -> None:
        """
        Initialize a SecretGroup object.

        :param str id: A v4 UUID identifier, or `default` secret group.
        :param str description: An extended description of your secret group.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        self.id = id
        self.name = name
        self.description = description
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretGroup':
        """Initialize a SecretGroup object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in SecretGroup JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in SecretGroup JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in SecretGroup JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in SecretGroup JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in SecretGroup JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretGroup object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretGroup object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretGroup') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretGroup') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretGroupCollection:
    """
    Properties that describe a collection of secret groups.

    :attr List[SecretGroup] secret_groups: A collection of secret groups.
    :attr int total_count: The total number of resources in a collection.
    """

    def __init__(
        self,
        secret_groups: List['SecretGroup'],
        total_count: int,
    ) -> None:
        """
        Initialize a SecretGroupCollection object.

        :param List[SecretGroup] secret_groups: A collection of secret groups.
        :param int total_count: The total number of resources in a collection.
        """
        self.secret_groups = secret_groups
        self.total_count = total_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretGroupCollection':
        """Initialize a SecretGroupCollection object from a json dictionary."""
        args = {}
        if 'secret_groups' in _dict:
            args['secret_groups'] = [SecretGroup.from_dict(v) for v in _dict.get('secret_groups')]
        else:
            raise ValueError('Required property \'secret_groups\' not present in SecretGroupCollection JSON')
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretGroupCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretGroupCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_groups') and self.secret_groups is not None:
            secret_groups_list = []
            for v in self.secret_groups:
                if isinstance(v, dict):
                    secret_groups_list.append(v)
                else:
                    secret_groups_list.append(v.to_dict())
            _dict['secret_groups'] = secret_groups_list
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretGroupCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretGroupCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretGroupCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretGroupPatch:
    """
    Update the name or description of your secret group.

    :attr str name: (optional) The name of your secret group.
    :attr str description: (optional) An extended description of your secret group.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
    ) -> None:
        """
        Initialize a SecretGroupPatch object.

        :param str name: (optional) The name of your secret group.
        :param str description: (optional) An extended description of your secret
               group.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        """
        self.name = name
        self.description = description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretGroupPatch':
        """Initialize a SecretGroupPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretGroupPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretGroupPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretGroupPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretGroupPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretLock:
    """
    SecretLock.

    :attr str name: A human-readable name to assign to the lock. The lock name must
          be unique per secret version.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret lock.
    :attr str description: (optional) An extended description of the lock.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret lock.
    :attr dict attributes: (optional) Optional information to associate with a lock,
          such as resources CRNs to be used by automation.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_id: A v4 UUID identifier.
    :attr str secret_version_id: A v4 UUID identifier.
    :attr str secret_version_alias: A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    """

    def __init__(
        self,
        name: str,
        created_at: datetime,
        updated_at: datetime,
        created_by: str,
        secret_group_id: str,
        secret_id: str,
        secret_version_id: str,
        secret_version_alias: str,
        *,
        description: str = None,
        attributes: dict = None,
    ) -> None:
        """
        Initialize a SecretLock object.

        :param str name: A human-readable name to assign to the lock. The lock name
               must be unique per secret version.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret lock.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_id: A v4 UUID identifier.
        :param str secret_version_id: A v4 UUID identifier.
        :param str secret_version_alias: A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param str description: (optional) An extended description of the lock.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret lock.
        :param dict attributes: (optional) Optional information to associate with a
               lock, such as resources CRNs to be used by automation.
        """
        self.name = name
        self.description = description
        self.attributes = attributes
        self.created_at = created_at
        self.updated_at = updated_at
        self.created_by = created_by
        self.secret_group_id = secret_group_id
        self.secret_id = secret_id
        self.secret_version_id = secret_version_id
        self.secret_version_alias = secret_version_alias

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLock':
        """Initialize a SecretLock object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in SecretLock JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'attributes' in _dict:
            args['attributes'] = _dict.get('attributes')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in SecretLock JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in SecretLock JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in SecretLock JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in SecretLock JSON')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in SecretLock JSON')
        if 'secret_version_id' in _dict:
            args['secret_version_id'] = _dict.get('secret_version_id')
        else:
            raise ValueError('Required property \'secret_version_id\' not present in SecretLock JSON')
        if 'secret_version_alias' in _dict:
            args['secret_version_alias'] = _dict.get('secret_version_alias')
        else:
            raise ValueError('Required property \'secret_version_alias\' not present in SecretLock JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLock object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'attributes') and self.attributes is not None:
            _dict['attributes'] = self.attributes
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'secret_version_id') and self.secret_version_id is not None:
            _dict['secret_version_id'] = self.secret_version_id
        if hasattr(self, 'secret_version_alias') and self.secret_version_alias is not None:
            _dict['secret_version_alias'] = self.secret_version_alias
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLock object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLock') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLock') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretVersionAliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class SecretLockPrototype:
    """
    SecretLockPrototype.

    :attr str name: A human-readable name to assign to the lock. The lock name must
          be unique per secret version.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret lock.
    :attr str description: (optional) An extended description of the lock.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret lock.
    :attr dict attributes: (optional) Optional information to associate with a lock,
          such as resources CRNs to be used by automation.
    """

    def __init__(
        self,
        name: str,
        *,
        description: str = None,
        attributes: dict = None,
    ) -> None:
        """
        Initialize a SecretLockPrototype object.

        :param str name: A human-readable name to assign to the lock. The lock name
               must be unique per secret version.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret lock.
        :param str description: (optional) An extended description of the lock.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret lock.
        :param dict attributes: (optional) Optional information to associate with a
               lock, such as resources CRNs to be used by automation.
        """
        self.name = name
        self.description = description
        self.attributes = attributes

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLockPrototype':
        """Initialize a SecretLockPrototype object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in SecretLockPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'attributes' in _dict:
            args['attributes'] = _dict.get('attributes')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLockPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'attributes') and self.attributes is not None:
            _dict['attributes'] = self.attributes
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLockPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLockPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLockPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretLocks:
    """
    Create locks response body containing a collection of locks that are attached to a
    secret.

    :attr str secret_id: A v4 UUID identifier.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: (optional) The secret type. Supported types are
          arbitrary, certificates (imported, public, and private), IAM credentials,
          key-value, and user credentials.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr List[SecretVersionLocks] versions: A collection of locks that are attached
          to a secret.
    """

    def __init__(
        self,
        secret_id: str,
        secret_group_id: str,
        versions: List['SecretVersionLocks'],
        *,
        secret_type: str = None,
        secret_name: str = None,
    ) -> None:
        """
        Initialize a SecretLocks object.

        :param str secret_id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param List[SecretVersionLocks] versions: A collection of locks that are
               attached to a secret.
        :param str secret_type: (optional) The secret type. Supported types are
               arbitrary, certificates (imported, public, and private), IAM credentials,
               key-value, and user credentials.
        """
        self.secret_id = secret_id
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.secret_name = secret_name
        self.versions = versions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLocks':
        """Initialize a SecretLocks object from a json dictionary."""
        args = {}
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in SecretLocks JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in SecretLocks JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'versions' in _dict:
            args['versions'] = [SecretVersionLocks.from_dict(v) for v in _dict.get('versions')]
        else:
            raise ValueError('Required property \'versions\' not present in SecretLocks JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLocks object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'versions') and self.versions is not None:
            versions_list = []
            for v in self.versions:
                if isinstance(v, dict):
                    versions_list.append(v)
                else:
                    versions_list.append(v.to_dict())
            _dict['versions'] = versions_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLocks object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLocks') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLocks') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class SecretLocksPaginatedCollection:
    """
    Properties that describe a paginated collection of your secret locks.

    :attr int total_count: The total number of resources in a collection.
    :attr int limit: The number of items that are retrieved in a collection.
    :attr int offset: The number of items that are skipped in a collection.
    :attr PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :attr PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :attr PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :attr PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :attr List[SecretLock] locks: A collection of secret locks.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        locks: List['SecretLock'],
        *,
        next: 'PaginatedCollectionNext' = None,
        previous: 'PaginatedCollectionPrevious' = None,
    ) -> None:
        """
        Initialize a SecretLocksPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretLock] locks: A collection of secret locks.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.locks = locks

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretLocksPaginatedCollection':
        """Initialize a SecretLocksPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretLocksPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretLocksPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretLocksPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretLocksPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretLocksPaginatedCollection JSON')
        if 'locks' in _dict:
            args['locks'] = [SecretLock.from_dict(v) for v in _dict.get('locks')]
        else:
            raise ValueError('Required property \'locks\' not present in SecretLocksPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretLocksPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'locks') and self.locks is not None:
            locks_list = []
            for v in self.locks:
                if isinstance(v, dict):
                    locks_list.append(v)
                else:
                    locks_list.append(v.to_dict())
            _dict['locks'] = locks_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretLocksPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretMetadata:
    """
    Properties of your secret metadata.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretMetadata object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretMetadata', 'ImportedCertificateMetadata', 'PublicCertificateMetadata', 'KVSecretMetadata', 'UsernamePasswordSecretMetadata', 'IAMCredentialsSecretMetadata', 'PrivateCertificateMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretMetadata':
        """Initialize a SecretMetadata object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretMetadata'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretMetadata', 'ImportedCertificateMetadata', 'PublicCertificateMetadata', 'KVSecretMetadata', 'UsernamePasswordSecretMetadata', 'IAMCredentialsSecretMetadata', 'PrivateCertificateMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['imported_cert'] = 'ImportedCertificateMetadata'
        mapping['public_cert'] = 'PublicCertificateMetadata'
        mapping['kv'] = 'KVSecretMetadata'
        mapping['username_password'] = 'UsernamePasswordSecretMetadata'
        mapping['iam_credentials'] = 'IAMCredentialsSecretMetadata'
        mapping['arbitrary'] = 'ArbitrarySecretMetadata'
        mapping['private_cert'] = 'PrivateCertificateMetadata'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretMetadata JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretMetadataPaginatedCollection:
    """
    Properties that describe a paginated collection of your secret metadata.

    :attr int total_count: The total number of resources in a collection.
    :attr int limit: The number of items that are retrieved in a collection.
    :attr int offset: The number of items that are skipped in a collection.
    :attr PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :attr PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :attr PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :attr PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :attr List[SecretMetadata] secrets: A collection of secret metadata.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        secrets: List['SecretMetadata'],
        *,
        next: 'PaginatedCollectionNext' = None,
        previous: 'PaginatedCollectionPrevious' = None,
    ) -> None:
        """
        Initialize a SecretMetadataPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretMetadata] secrets: A collection of secret metadata.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.secrets = secrets

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretMetadataPaginatedCollection':
        """Initialize a SecretMetadataPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretMetadataPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretMetadataPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretMetadataPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretMetadataPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretMetadataPaginatedCollection JSON')
        if 'secrets' in _dict:
            args['secrets'] = [SecretMetadata.from_dict(v) for v in _dict.get('secrets')]
        else:
            raise ValueError('Required property \'secrets\' not present in SecretMetadataPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretMetadataPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'secrets') and self.secrets is not None:
            secrets_list = []
            for v in self.secrets:
                if isinstance(v, dict):
                    secrets_list.append(v)
                else:
                    secrets_list.append(v.to_dict())
            _dict['secrets'] = secrets_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretMetadataPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretMetadataPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretMetadataPatch:
    """
    Update your secret metadata.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretMetadataPatch object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretMetadataPatch', 'IAMCredentialsSecretMetadataPatch', 'ImportedCertificateMetadataPatch', 'KVSecretMetadataPatch', 'PrivateCertificateMetadataPatch', 'PublicCertificateMetadataPatch', 'UsernamePasswordSecretMetadataPatch'])
        )
        raise Exception(msg)


class SecretPrototype:
    """
    Specify the properties for your secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretPrototype', 'IAMCredentialsSecretPrototype', 'ImportedCertificatePrototype', 'KVSecretPrototype', 'PrivateCertificatePrototype', 'PublicCertificatePrototype', 'UsernamePasswordSecretPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretPrototype':
        """Initialize a SecretPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretPrototype', 'IAMCredentialsSecretPrototype', 'ImportedCertificatePrototype', 'KVSecretPrototype', 'PrivateCertificatePrototype', 'PublicCertificatePrototype', 'UsernamePasswordSecretPrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretPrototype'
        mapping['iam_credentials'] = 'IAMCredentialsSecretPrototype'
        mapping['imported_cert'] = 'ImportedCertificatePrototype'
        mapping['kv'] = 'KVSecretPrototype'
        mapping['private_cert'] = 'PrivateCertificatePrototype'
        mapping['public_cert'] = 'PublicCertificatePrototype'
        mapping['username_password'] = 'UsernamePasswordSecretPrototype'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersion:
    """
    Your secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersion object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretVersion', 'ImportedCertificateVersion', 'PublicCertificateVersion', 'KVSecretVersion', 'UsernamePasswordSecretVersion', 'IAMCredentialsSecretVersion', 'PrivateCertificateVersion'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersion':
        """Initialize a SecretVersion object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretVersion'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretVersion', 'ImportedCertificateVersion', 'PublicCertificateVersion', 'KVSecretVersion', 'UsernamePasswordSecretVersion', 'IAMCredentialsSecretVersion', 'PrivateCertificateVersion'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretVersion'
        mapping['imported_cert'] = 'ImportedCertificateVersion'
        mapping['public_cert'] = 'PublicCertificateVersion'
        mapping['kv'] = 'KVSecretVersion'
        mapping['username_password'] = 'UsernamePasswordSecretVersion'
        mapping['iam_credentials'] = 'IAMCredentialsSecretVersion'
        mapping['private_cert'] = 'PrivateCertificateVersion'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretVersion JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersionActionPrototype:
    """
    The request body to specify the properties of the action to create a secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersionActionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateVersionActionRevokePrototype'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionActionPrototype':
        """Initialize a SecretVersionActionPrototype object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretVersionActionPrototype'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateVersionActionRevokePrototype'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretVersionActionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateVersionActionRevokePrototype'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in SecretVersionActionPrototype JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersionLocks:
    """
    SecretVersionLocks.

    :attr str version_id: A v4 UUID identifier.
    :attr str version_alias: A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr List[str] locks: The names of all locks that are associated with this
          secret version.
    :attr bool payload_available: (optional) Indicates whether the secret payload is
          available in this secret version.
    """

    def __init__(
        self,
        version_id: str,
        version_alias: str,
        locks: List[str],
        *,
        payload_available: bool = None,
    ) -> None:
        """
        Initialize a SecretVersionLocks object.

        :param str version_id: A v4 UUID identifier.
        :param str version_alias: A human-readable alias that describes the secret
               version. 'Current' is used for version `n` and 'previous' is used for
               version `n-1`.
        :param List[str] locks: The names of all locks that are associated with
               this secret version.
        :param bool payload_available: (optional) Indicates whether the secret
               payload is available in this secret version.
        """
        self.version_id = version_id
        self.version_alias = version_alias
        self.locks = locks
        self.payload_available = payload_available

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionLocks':
        """Initialize a SecretVersionLocks object from a json dictionary."""
        args = {}
        if 'version_id' in _dict:
            args['version_id'] = _dict.get('version_id')
        else:
            raise ValueError('Required property \'version_id\' not present in SecretVersionLocks JSON')
        if 'version_alias' in _dict:
            args['version_alias'] = _dict.get('version_alias')
        else:
            raise ValueError('Required property \'version_alias\' not present in SecretVersionLocks JSON')
        if 'locks' in _dict:
            args['locks'] = _dict.get('locks')
        else:
            raise ValueError('Required property \'locks\' not present in SecretVersionLocks JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionLocks object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'version_id') and self.version_id is not None:
            _dict['version_id'] = self.version_id
        if hasattr(self, 'version_alias') and self.version_alias is not None:
            _dict['version_alias'] = self.version_alias
        if hasattr(self, 'locks') and self.locks is not None:
            _dict['locks'] = self.locks
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionLocks object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionLocks') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionLocks') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class VersionAliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class SecretVersionLocksPaginatedCollection:
    """
    Properties that describe a paginated collection of your secret version locks.

    :attr int total_count: The total number of resources in a collection.
    :attr int limit: The number of items that are retrieved in a collection.
    :attr int offset: The number of items that are skipped in a collection.
    :attr PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :attr PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :attr PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :attr PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :attr List[SecretLock] locks: A collection of secret version locks.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        locks: List['SecretLock'],
        *,
        next: 'PaginatedCollectionNext' = None,
        previous: 'PaginatedCollectionPrevious' = None,
    ) -> None:
        """
        Initialize a SecretVersionLocksPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretLock] locks: A collection of secret version locks.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.locks = locks

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionLocksPaginatedCollection':
        """Initialize a SecretVersionLocksPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretVersionLocksPaginatedCollection JSON')
        if 'locks' in _dict:
            args['locks'] = [SecretLock.from_dict(v) for v in _dict.get('locks')]
        else:
            raise ValueError('Required property \'locks\' not present in SecretVersionLocksPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionLocksPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'locks') and self.locks is not None:
            locks_list = []
            for v in self.locks:
                if isinstance(v, dict):
                    locks_list.append(v)
                else:
                    locks_list.append(v.to_dict())
            _dict['locks'] = locks_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionLocksPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretVersionMetadata:
    """
    Properties of the version metadata of your secret.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersionMetadata object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretVersionMetadata', 'PublicCertificateVersionMetadata', 'ImportedCertificateVersionMetadata', 'KVSecretVersionMetadata', 'UsernamePasswordSecretVersionMetadata', 'IAMCredentialsSecretVersionMetadata', 'PrivateCertificateVersionMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionMetadata':
        """Initialize a SecretVersionMetadata object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'SecretVersionMetadata'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['ArbitrarySecretVersionMetadata', 'PublicCertificateVersionMetadata', 'ImportedCertificateVersionMetadata', 'KVSecretVersionMetadata', 'UsernamePasswordSecretVersionMetadata', 'IAMCredentialsSecretVersionMetadata', 'PrivateCertificateVersionMetadata'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a SecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['arbitrary'] = 'ArbitrarySecretVersionMetadata'
        mapping['imported_cert'] = 'ImportedCertificateVersionMetadata'
        mapping['public_cert'] = 'PublicCertificateVersionMetadata'
        mapping['kv'] = 'KVSecretVersionMetadata'
        mapping['username_password'] = 'UsernamePasswordSecretVersionMetadata'
        mapping['iam_credentials'] = 'IAMCredentialsSecretVersionMetadata'
        mapping['private_cert'] = 'PrivateCertificateVersionMetadata'
        disc_value = _dict.get('secret_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'secret_type\' not found in SecretVersionMetadata JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class SecretVersionMetadataCollection:
    """
    Properties that describe a collection of your secret version metadata.

    :attr List[SecretVersionMetadata] versions: A collection of secret version
          metadata.
    :attr int total_count: The total number of resources in a collection.
    """

    def __init__(
        self,
        versions: List['SecretVersionMetadata'],
        total_count: int,
    ) -> None:
        """
        Initialize a SecretVersionMetadataCollection object.

        :param List[SecretVersionMetadata] versions: A collection of secret version
               metadata.
        :param int total_count: The total number of resources in a collection.
        """
        self.versions = versions
        self.total_count = total_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionMetadataCollection':
        """Initialize a SecretVersionMetadataCollection object from a json dictionary."""
        args = {}
        if 'versions' in _dict:
            args['versions'] = [SecretVersionMetadata.from_dict(v) for v in _dict.get('versions')]
        else:
            raise ValueError('Required property \'versions\' not present in SecretVersionMetadataCollection JSON')
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretVersionMetadataCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionMetadataCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'versions') and self.versions is not None:
            versions_list = []
            for v in self.versions:
                if isinstance(v, dict):
                    versions_list.append(v)
                else:
                    versions_list.append(v.to_dict())
            _dict['versions'] = versions_list
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionMetadataCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionMetadataCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionMetadataCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretVersionMetadataPatch:
    """
    Update your secret version metadata.

    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a SecretVersionMetadataPatch object.

        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretVersionMetadataPatch':
        """Initialize a SecretVersionMetadataPatch object from a json dictionary."""
        args = {}
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretVersionMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretVersionMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretVersionMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretVersionMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SecretVersionPrototype:
    """
    Specify the properties for your new secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a SecretVersionPrototype object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['ArbitrarySecretVersionPrototype', 'IAMCredentialsSecretRestoreFromVersionPrototype', 'IAMCredentialsSecretVersionPrototype', 'ImportedCertificateVersionPrototype', 'KVSecretVersionPrototype', 'PrivateCertificateVersionPrototype', 'PublicCertificateVersionPrototype', 'UsernamePasswordSecretVersionPrototype'])
        )
        raise Exception(msg)


class SecretsLocksPaginatedCollection:
    """
    Properties that describe a paginated collection of your secrets locks.

    :attr int total_count: The total number of resources in a collection.
    :attr int limit: The number of items that are retrieved in a collection.
    :attr int offset: The number of items that are skipped in a collection.
    :attr PaginatedCollectionFirst first: A URL that points to the first page in a
          collection.
    :attr PaginatedCollectionNext next: (optional) A URL that points to the next
          page in a collection.
    :attr PaginatedCollectionPrevious previous: (optional) A URL that points to the
          previous page in a collection.
    :attr PaginatedCollectionLast last: A URL that points to the last page in a
          collection.
    :attr List[SecretLocks] secrets_locks: A collection of secrets and their locks.
    """

    def __init__(
        self,
        total_count: int,
        limit: int,
        offset: int,
        first: 'PaginatedCollectionFirst',
        last: 'PaginatedCollectionLast',
        secrets_locks: List['SecretLocks'],
        *,
        next: 'PaginatedCollectionNext' = None,
        previous: 'PaginatedCollectionPrevious' = None,
    ) -> None:
        """
        Initialize a SecretsLocksPaginatedCollection object.

        :param int total_count: The total number of resources in a collection.
        :param int limit: The number of items that are retrieved in a collection.
        :param int offset: The number of items that are skipped in a collection.
        :param PaginatedCollectionFirst first: A URL that points to the first page
               in a collection.
        :param PaginatedCollectionLast last: A URL that points to the last page in
               a collection.
        :param List[SecretLocks] secrets_locks: A collection of secrets and their
               locks.
        :param PaginatedCollectionNext next: (optional) A URL that points to the
               next page in a collection.
        :param PaginatedCollectionPrevious previous: (optional) A URL that points
               to the previous page in a collection.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.secrets_locks = secrets_locks

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SecretsLocksPaginatedCollection':
        """Initialize a SecretsLocksPaginatedCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        else:
            raise ValueError('Required property \'total_count\' not present in SecretsLocksPaginatedCollection JSON')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SecretsLocksPaginatedCollection JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SecretsLocksPaginatedCollection JSON')
        if 'first' in _dict:
            args['first'] = PaginatedCollectionFirst.from_dict(_dict.get('first'))
        else:
            raise ValueError('Required property \'first\' not present in SecretsLocksPaginatedCollection JSON')
        if 'next' in _dict:
            args['next'] = PaginatedCollectionNext.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginatedCollectionPrevious.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginatedCollectionLast.from_dict(_dict.get('last'))
        else:
            raise ValueError('Required property \'last\' not present in SecretsLocksPaginatedCollection JSON')
        if 'secrets_locks' in _dict:
            args['secrets_locks'] = [SecretLocks.from_dict(v) for v in _dict.get('secrets_locks')]
        else:
            raise ValueError('Required property \'secrets_locks\' not present in SecretsLocksPaginatedCollection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SecretsLocksPaginatedCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'first') and self.first is not None:
            if isinstance(self.first, dict):
                _dict['first'] = self.first
            else:
                _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            if isinstance(self.next, dict):
                _dict['next'] = self.next
            else:
                _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            if isinstance(self.previous, dict):
                _dict['previous'] = self.previous
            else:
                _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            if isinstance(self.last, dict):
                _dict['last'] = self.last
            else:
                _dict['last'] = self.last.to_dict()
        if hasattr(self, 'secrets_locks') and self.secrets_locks is not None:
            secrets_locks_list = []
            for v in self.secrets_locks:
                if isinstance(v, dict):
                    secrets_locks_list.append(v)
                else:
                    secrets_locks_list.append(v.to_dict())
            _dict['secrets_locks'] = secrets_locks_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SecretsLocksPaginatedCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SecretsLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SecretsLocksPaginatedCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class VersionAction:
    """
    The request body to specify the properties of the action to create a secret version.

    """

    def __init__(
        self,
    ) -> None:
        """
        Initialize a VersionAction object.

        """
        msg = "Cannot instantiate base class. Instead, instantiate one of the defined subclasses: {0}".format(
            ", ".join(['PrivateCertificateVersionActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VersionAction':
        """Initialize a VersionAction object from a json dictionary."""
        disc_class = cls._get_class_by_discriminator(_dict)
        if disc_class != cls:
            return disc_class.from_dict(_dict)
        msg = "Cannot convert dictionary into an instance of base class 'VersionAction'. The discriminator value should map to a valid subclass: {1}".format(
            ", ".join(['PrivateCertificateVersionActionRevoke'])
        )
        raise Exception(msg)

    @classmethod
    def _from_dict(cls, _dict: Dict):
        """Initialize a VersionAction object from a json dictionary."""
        return cls.from_dict(_dict)

    @classmethod
    def _get_class_by_discriminator(cls, _dict: Dict) -> object:
        mapping = {}
        mapping['private_cert_action_revoke_certificate'] = 'PrivateCertificateVersionActionRevoke'
        disc_value = _dict.get('action_type')
        if disc_value is None:
            raise ValueError('Discriminator property \'action_type\' not found in VersionAction JSON')
        class_name = mapping.get(disc_value, disc_value)
        try:
            disc_class = getattr(sys.modules[__name__], class_name)
        except AttributeError:
            disc_class = cls
        if isinstance(disc_class, object):
            return disc_class
        raise TypeError('%s is not a discriminator class' % class_name)


class ArbitrarySecret(Secret):
    """
    Your arbitrary secret.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str payload: (optional) The secret data that is assigned to an `arbitrary`
          secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        expiration_date: datetime = None,
        payload: str = None,
    ) -> None:
        """
        Initialize a ArbitrarySecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str payload: (optional) The secret data that is assigned to an
               `arbitrary` secret.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.expiration_date = expiration_date
        self.payload = payload

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecret':
        """Initialize a ArbitrarySecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ArbitrarySecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ArbitrarySecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ArbitrarySecret JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ArbitrarySecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your arbitrary secret..

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        expiration_date: datetime = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretMetadata':
        """Initialize a ArbitrarySecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ArbitrarySecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ArbitrarySecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ArbitrarySecretMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ArbitrarySecretMetadataPatch(SecretMetadataPatch):
    """
    ArbitrarySecretMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
        expiration_date: datetime = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretMetadataPatch':
        """Initialize a ArbitrarySecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ArbitrarySecretPrototype(SecretPrototype):
    """
    ArbitrarySecretPrototype.

    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str payload: The secret data that is assigned to an `arbitrary` secret.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        name: str,
        secret_type: str,
        payload: str,
        *,
        custom_metadata: dict = None,
        description: str = None,
        expiration_date: datetime = None,
        labels: List[str] = None,
        secret_group_id: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretPrototype object.

        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str payload: The secret data that is assigned to an `arbitrary`
               secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.description = description
        self.expiration_date = expiration_date
        self.labels = labels
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.payload = payload
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretPrototype':
        """Initialize a ArbitrarySecretPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in ArbitrarySecretPrototype JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretPrototype JSON')
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        else:
            raise ValueError('Required property \'payload\' not present in ArbitrarySecretPrototype JSON')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class ArbitrarySecretVersion(SecretVersion):
    """
    Your arbitrary secret version.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str payload: (optional) The secret data that is assigned to an `arbitrary`
          secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        expiration_date: datetime = None,
        payload: str = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str payload: (optional) The secret data that is assigned to an
               `arbitrary` secret.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.payload = payload

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretVersion':
        """Initialize a ArbitrarySecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ArbitrarySecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ArbitrarySecretVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ArbitrarySecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your arbitrary secret.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        expiration_date: datetime = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretVersionMetadata':
        """Initialize a ArbitrarySecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ArbitrarySecretVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ArbitrarySecretVersionPrototype(SecretVersionPrototype):
    """
    ArbitrarySecretVersionPrototype.

    :attr str payload: The secret data that is assigned to an `arbitrary` secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        payload: str,
        *,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a ArbitrarySecretVersionPrototype object.

        :param str payload: The secret data that is assigned to an `arbitrary`
               secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.payload = payload
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ArbitrarySecretVersionPrototype':
        """Initialize a ArbitrarySecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'payload' in _dict:
            args['payload'] = _dict.get('payload')
        else:
            raise ValueError('Required property \'payload\' not present in ArbitrarySecretVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ArbitrarySecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'payload') and self.payload is not None:
            _dict['payload'] = self.payload
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ArbitrarySecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ArbitrarySecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ArbitrarySecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class CommonRotationPolicy(RotationPolicy):
    """
    This field indicates whether Secrets Manager rotates your secrets automatically.

    :attr bool auto_rotate: This field indicates whether Secrets Manager rotates
          your secret automatically.
          The default is `false`. If `auto_rotate` is set to `true` the service rotates
          your secret based on the defined interval.
    :attr int interval: (optional) The length of the secret rotation time interval.
    :attr str unit: (optional) The units for the secret rotation time interval.
    """

    def __init__(
        self,
        auto_rotate: bool,
        *,
        interval: int = None,
        unit: str = None,
    ) -> None:
        """
        Initialize a CommonRotationPolicy object.

        :param bool auto_rotate: This field indicates whether Secrets Manager
               rotates your secret automatically.
               The default is `false`. If `auto_rotate` is set to `true` the service
               rotates your secret based on the defined interval.
        :param int interval: (optional) The length of the secret rotation time
               interval.
        :param str unit: (optional) The units for the secret rotation time
               interval.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotate = auto_rotate
        self.interval = interval
        self.unit = unit

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CommonRotationPolicy':
        """Initialize a CommonRotationPolicy object from a json dictionary."""
        args = {}
        if 'auto_rotate' in _dict:
            args['auto_rotate'] = _dict.get('auto_rotate')
        else:
            raise ValueError('Required property \'auto_rotate\' not present in CommonRotationPolicy JSON')
        if 'interval' in _dict:
            args['interval'] = _dict.get('interval')
        if 'unit' in _dict:
            args['unit'] = _dict.get('unit')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CommonRotationPolicy object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotate') and self.auto_rotate is not None:
            _dict['auto_rotate'] = self.auto_rotate
        if hasattr(self, 'interval') and self.interval is not None:
            _dict['interval'] = self.interval
        if hasattr(self, 'unit') and self.unit is not None:
            _dict['unit'] = self.unit
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CommonRotationPolicy object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CommonRotationPolicy') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CommonRotationPolicy') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class UnitEnum(str, Enum):
        """
        The units for the secret rotation time interval.
        """

        DAY = 'day'
        MONTH = 'month'



class IAMCredentialsConfiguration(Configuration):
    """
    Properties that describe a Classic Infrastructure DNS configuration.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str api_key: (optional) An IBM Cloud API key that can create and manage
          service IDs. The API key must be assigned the Editor platform role on the Access
          Groups Service and the Operator platform role on the IAM Identity Service.  For
          more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-configure-iam-engine).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        *,
        api_key: str = None,
    ) -> None:
        """
        Initialize a IAMCredentialsConfiguration object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfiguration':
        """Initialize a IAMCredentialsConfiguration object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in IAMCredentialsConfiguration JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsConfiguration JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsConfiguration JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsConfiguration JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsConfiguration JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsConfiguration JSON')
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfiguration object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'api_key') and getattr(self, 'api_key') is not None:
            _dict['api_key'] = getattr(self, 'api_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfiguration object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfiguration') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfiguration') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class IAMCredentialsConfigurationMetadata(ConfigurationMetadata):
    """
    Your IAMCredentials Configuration metadata properties.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
    ) -> None:
        """
        Initialize a IAMCredentialsConfigurationMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfigurationMetadata':
        """Initialize a IAMCredentialsConfigurationMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsConfigurationMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsConfigurationMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfigurationMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfigurationMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfigurationMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfigurationMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class IAMCredentialsConfigurationPatch(ConfigurationPatch):
    """
    The configuration update of the IAM Credentials engine.

    :attr str api_key: An IBM Cloud API key that can create and manage service IDs.
          The API key must be assigned the Editor platform role on the Access Groups
          Service and the Operator platform role on the IAM Identity Service.  For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-configure-iam-engine).
    """

    def __init__(
        self,
        api_key: str,
    ) -> None:
        """
        Initialize a IAMCredentialsConfigurationPatch object.

        :param str api_key: An IBM Cloud API key that can create and manage service
               IDs. The API key must be assigned the Editor platform role on the Access
               Groups Service and the Operator platform role on the IAM Identity Service.
               For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-configure-iam-engine).
        """
        # pylint: disable=super-init-not-called
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfigurationPatch':
        """Initialize a IAMCredentialsConfigurationPatch object from a json dictionary."""
        args = {}
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        else:
            raise ValueError('Required property \'api_key\' not present in IAMCredentialsConfigurationPatch JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfigurationPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'api_key') and self.api_key is not None:
            _dict['api_key'] = self.api_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfigurationPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfigurationPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfigurationPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class IAMCredentialsConfigurationPrototype(ConfigurationPrototype):
    """
    IAMCredentialsConfigurationPrototype.

    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str config_type: The configuration type.
    :attr str api_key: The API key that is used to set the iam_credentials engine.
    """

    def __init__(
        self,
        name: str,
        config_type: str,
        api_key: str,
    ) -> None:
        """
        Initialize a IAMCredentialsConfigurationPrototype object.

        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str config_type: The configuration type.
        :param str api_key: The API key that is used to set the iam_credentials
               engine.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.config_type = config_type
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsConfigurationPrototype':
        """Initialize a IAMCredentialsConfigurationPrototype object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsConfigurationPrototype JSON')
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in IAMCredentialsConfigurationPrototype JSON')
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        else:
            raise ValueError('Required property \'api_key\' not present in IAMCredentialsConfigurationPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsConfigurationPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'api_key') and self.api_key is not None:
            _dict['api_key'] = self.api_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsConfigurationPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsConfigurationPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsConfigurationPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'



class IAMCredentialsSecret(Secret):
    """
    Your IAM credentials secret.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str ttl: The time-to-live (TTL) or lease duration to assign to credentials
          that are generated.
          For `iam_credentials` secrets, the TTL defines for how long each generated API
          key remains valid. The value can be either an integer that specifies the number
          of seconds, or the string representation of a duration, such as `120m` or `24h`.
          The minimum duration is 1 minute. The maximum is 90 days.
    :attr List[str] access_groups: (optional) Access Groups that you can use for an
          `iam_credentials` secret.
          Up to 10 Access Groups can be used for each secret.
    :attr str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :attr str service_id: (optional) The service ID under which the API key (see the
          `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :attr bool service_id_is_static: (optional) Indicates whether an
          `iam_credentials` secret was created with a static service ID.
          If it is set to `true`, the service ID for the secret was provided by the user
          at secret creation. If it is set to `false`, the service ID was generated by
          Secrets Manager.
    :attr bool reuse_api_key: (IAM credentials) This parameter indicates whether to
          reuse the service ID and API key for future read operations.
          If it is set to `true`, the service reuses the current credentials. If it is set
          to `false`, a new service ID and API key are generated each time that the secret
          is read or accessed.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :attr str api_key: (optional) The API key that is generated for this secret.
          After the secret reaches the end of its lease (see the `ttl` field), the API key
          is deleted automatically. If you want to continue to use the same API key for
          future read operations, see the `reuse_api_key` field.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        ttl: str,
        reuse_api_key: bool,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        access_groups: List[str] = None,
        api_key_id: str = None,
        service_id: str = None,
        service_id_is_static: bool = None,
        rotation: 'RotationPolicy' = None,
        next_rotation_date: datetime = None,
        api_key: str = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str ttl: The time-to-live (TTL) or lease duration to assign to
               credentials that are generated.
               For `iam_credentials` secrets, the TTL defines for how long each generated
               API key remains valid. The value can be either an integer that specifies
               the number of seconds, or the string representation of a duration, such as
               `120m` or `24h`.
               The minimum duration is 1 minute. The maximum is 90 days.
        :param bool reuse_api_key: (IAM credentials) This parameter indicates
               whether to reuse the service ID and API key for future read operations.
               If it is set to `true`, the service reuses the current credentials. If it
               is set to `false`, a new service ID and API key are generated each time
               that the secret is read or accessed.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] access_groups: (optional) Access Groups that you can use
               for an `iam_credentials` secret.
               Up to 10 Access Groups can be used for each secret.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.ttl = ttl
        self.access_groups = access_groups
        self.api_key_id = api_key_id
        self.service_id = service_id
        self.service_id_is_static = service_id_is_static
        self.reuse_api_key = reuse_api_key
        self.rotation = rotation
        self.next_rotation_date = next_rotation_date
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecret':
        """Initialize a IAMCredentialsSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in IAMCredentialsSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in IAMCredentialsSecret JSON')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        else:
            raise ValueError('Required property \'ttl\' not present in IAMCredentialsSecret JSON')
        if 'access_groups' in _dict:
            args['access_groups'] = _dict.get('access_groups')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'service_id_is_static' in _dict:
            args['service_id_is_static'] = _dict.get('service_id_is_static')
        if 'reuse_api_key' in _dict:
            args['reuse_api_key'] = _dict.get('reuse_api_key')
        else:
            raise ValueError('Required property \'reuse_api_key\' not present in IAMCredentialsSecret JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'access_groups') and self.access_groups is not None:
            _dict['access_groups'] = self.access_groups
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'service_id_is_static') and getattr(self, 'service_id_is_static') is not None:
            _dict['service_id_is_static'] = getattr(self, 'service_id_is_static')
        if hasattr(self, 'reuse_api_key') and self.reuse_api_key is not None:
            _dict['reuse_api_key'] = self.reuse_api_key
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'api_key') and getattr(self, 'api_key') is not None:
            _dict['api_key'] = getattr(self, 'api_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class IAMCredentialsSecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your IAM credentials secret.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str ttl: The time-to-live (TTL) or lease duration to assign to credentials
          that are generated.
          For `iam_credentials` secrets, the TTL defines for how long each generated API
          key remains valid. The value can be either an integer that specifies the number
          of seconds, or the string representation of a duration, such as `120m` or `24h`.
          The minimum duration is 1 minute. The maximum is 90 days.
    :attr List[str] access_groups: (optional) Access Groups that you can use for an
          `iam_credentials` secret.
          Up to 10 Access Groups can be used for each secret.
    :attr str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :attr str service_id: (optional) The service ID under which the API key (see the
          `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :attr bool service_id_is_static: (optional) Indicates whether an
          `iam_credentials` secret was created with a static service ID.
          If it is set to `true`, the service ID for the secret was provided by the user
          at secret creation. If it is set to `false`, the service ID was generated by
          Secrets Manager.
    :attr bool reuse_api_key: (IAM credentials) This parameter indicates whether to
          reuse the service ID and API key for future read operations.
          If it is set to `true`, the service reuses the current credentials. If it is set
          to `false`, a new service ID and API key are generated each time that the secret
          is read or accessed.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        ttl: str,
        reuse_api_key: bool,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        access_groups: List[str] = None,
        api_key_id: str = None,
        service_id: str = None,
        service_id_is_static: bool = None,
        rotation: 'RotationPolicy' = None,
        next_rotation_date: datetime = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str ttl: The time-to-live (TTL) or lease duration to assign to
               credentials that are generated.
               For `iam_credentials` secrets, the TTL defines for how long each generated
               API key remains valid. The value can be either an integer that specifies
               the number of seconds, or the string representation of a duration, such as
               `120m` or `24h`.
               The minimum duration is 1 minute. The maximum is 90 days.
        :param bool reuse_api_key: (IAM credentials) This parameter indicates
               whether to reuse the service ID and API key for future read operations.
               If it is set to `true`, the service reuses the current credentials. If it
               is set to `false`, a new service ID and API key are generated each time
               that the secret is read or accessed.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] access_groups: (optional) Access Groups that you can use
               for an `iam_credentials` secret.
               Up to 10 Access Groups can be used for each secret.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.ttl = ttl
        self.access_groups = access_groups
        self.api_key_id = api_key_id
        self.service_id = service_id
        self.service_id_is_static = service_id_is_static
        self.reuse_api_key = reuse_api_key
        self.rotation = rotation
        self.next_rotation_date = next_rotation_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretMetadata':
        """Initialize a IAMCredentialsSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in IAMCredentialsSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in IAMCredentialsSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in IAMCredentialsSecretMetadata JSON')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        else:
            raise ValueError('Required property \'ttl\' not present in IAMCredentialsSecretMetadata JSON')
        if 'access_groups' in _dict:
            args['access_groups'] = _dict.get('access_groups')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'service_id_is_static' in _dict:
            args['service_id_is_static'] = _dict.get('service_id_is_static')
        if 'reuse_api_key' in _dict:
            args['reuse_api_key'] = _dict.get('reuse_api_key')
        else:
            raise ValueError('Required property \'reuse_api_key\' not present in IAMCredentialsSecretMetadata JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'access_groups') and self.access_groups is not None:
            _dict['access_groups'] = self.access_groups
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'service_id_is_static') and getattr(self, 'service_id_is_static') is not None:
            _dict['service_id_is_static'] = getattr(self, 'service_id_is_static')
        if hasattr(self, 'reuse_api_key') and self.reuse_api_key is not None:
            _dict['reuse_api_key'] = self.reuse_api_key
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class IAMCredentialsSecretMetadataPatch(SecretMetadataPatch):
    """
    IAMCredentialsSecretMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str ttl: (optional) The time-to-live (TTL) or lease duration to assign to
          credentials that are generated.
          For `iam_credentials` secrets, the TTL defines for how long each generated API
          key remains valid. The value can be either an integer that specifies the number
          of seconds, or the string representation of a duration, such as `120m` or `24h`.
          The minimum duration is 1 minute. The maximum is 90 days.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
        ttl: str = None,
        rotation: 'RotationPolicy' = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str ttl: (optional) The time-to-live (TTL) or lease duration to
               assign to credentials that are generated.
               For `iam_credentials` secrets, the TTL defines for how long each generated
               API key remains valid. The value can be either an integer that specifies
               the number of seconds, or the string representation of a duration, such as
               `120m` or `24h`.
               The minimum duration is 1 minute. The maximum is 90 days.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.ttl = ttl
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretMetadataPatch':
        """Initialize a IAMCredentialsSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class IAMCredentialsSecretPrototype(SecretPrototype):
    """
    IAMCredentialsSecretPrototype.

    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr str ttl: The time-to-live (TTL) or lease duration to assign to credentials
          that are generated.
          For `iam_credentials` secrets, the TTL defines for how long each generated API
          key remains valid. The value can be either an integer that specifies the number
          of seconds, or the string representation of a duration, such as `120m` or `24h`.
          The minimum duration is 1 minute. The maximum is 90 days.
    :attr List[str] access_groups: (optional) Access Groups that you can use for an
          `iam_credentials` secret.
          Up to 10 Access Groups can be used for each secret.
    :attr str service_id: (optional) The service ID under which the API key (see the
          `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :attr bool reuse_api_key: (IAM credentials) This parameter indicates whether to
          reuse the service ID and API key for future read operations.
          If it is set to `true`, the service reuses the current credentials. If it is set
          to `false`, a new service ID and API key are generated each time that the secret
          is read or accessed.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        ttl: str,
        reuse_api_key: bool,
        *,
        description: str = None,
        secret_group_id: str = None,
        labels: List[str] = None,
        access_groups: List[str] = None,
        service_id: str = None,
        rotation: 'RotationPolicy' = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretPrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str ttl: The time-to-live (TTL) or lease duration to assign to
               credentials that are generated.
               For `iam_credentials` secrets, the TTL defines for how long each generated
               API key remains valid. The value can be either an integer that specifies
               the number of seconds, or the string representation of a duration, such as
               `120m` or `24h`.
               The minimum duration is 1 minute. The maximum is 90 days.
        :param bool reuse_api_key: (IAM credentials) This parameter indicates
               whether to reuse the service ID and API key for future read operations.
               If it is set to `true`, the service reuses the current credentials. If it
               is set to `false`, a new service ID and API key are generated each time
               that the secret is read or accessed.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] access_groups: (optional) Access Groups that you can use
               for an `iam_credentials` secret.
               Up to 10 Access Groups can be used for each secret.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.ttl = ttl
        self.access_groups = access_groups
        self.service_id = service_id
        self.reuse_api_key = reuse_api_key
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretPrototype':
        """Initialize a IAMCredentialsSecretPrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in IAMCredentialsSecretPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        else:
            raise ValueError('Required property \'ttl\' not present in IAMCredentialsSecretPrototype JSON')
        if 'access_groups' in _dict:
            args['access_groups'] = _dict.get('access_groups')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'reuse_api_key' in _dict:
            args['reuse_api_key'] = _dict.get('reuse_api_key')
        else:
            raise ValueError('Required property \'reuse_api_key\' not present in IAMCredentialsSecretPrototype JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'access_groups') and self.access_groups is not None:
            _dict['access_groups'] = self.access_groups
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'reuse_api_key') and self.reuse_api_key is not None:
            _dict['reuse_api_key'] = self.reuse_api_key
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class IAMCredentialsSecretRestoreFromVersionPrototype(SecretVersionPrototype):
    """
    IAMCredentialsSecretRestoreFromVersionPrototype.

    :attr str restore_from_version: A v4 UUID identifier, or `current` or `previous`
          secret version aliases.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        restore_from_version: str,
        *,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretRestoreFromVersionPrototype object.

        :param str restore_from_version: A v4 UUID identifier, or `current` or
               `previous` secret version aliases.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.restore_from_version = restore_from_version
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretRestoreFromVersionPrototype':
        """Initialize a IAMCredentialsSecretRestoreFromVersionPrototype object from a json dictionary."""
        args = {}
        if 'restore_from_version' in _dict:
            args['restore_from_version'] = _dict.get('restore_from_version')
        else:
            raise ValueError('Required property \'restore_from_version\' not present in IAMCredentialsSecretRestoreFromVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretRestoreFromVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'restore_from_version') and self.restore_from_version is not None:
            _dict['restore_from_version'] = self.restore_from_version
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretRestoreFromVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretRestoreFromVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretRestoreFromVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class IAMCredentialsSecretVersion(SecretVersion):
    """
    Your IAM credentials version.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :attr str service_id: (optional) The service ID under which the API key (see the
          `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    :attr str api_key: (optional) The API key that is generated for this secret.
          After the secret reaches the end of its lease (see the `ttl` field), the API key
          is deleted automatically. If you want to continue to use the same API key for
          future read operations, see the `reuse_api_key` field.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        api_key_id: str = None,
        service_id: str = None,
        api_key: str = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.api_key_id = api_key_id
        self.service_id = service_id
        self.api_key = api_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretVersion':
        """Initialize a IAMCredentialsSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in IAMCredentialsSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in IAMCredentialsSecretVersion JSON')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'api_key' in _dict:
            args['api_key'] = _dict.get('api_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'api_key') and getattr(self, 'api_key') is not None:
            _dict['api_key'] = getattr(self, 'api_key')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class IAMCredentialsSecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your IAM credentials secret.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr str api_key_id: (optional) The ID of the API key that is generated for
          this secret.
    :attr str service_id: (optional) The service ID under which the API key (see the
          `api_key` field) is created.
          If you omit this parameter, Secrets Manager generates a new service ID for your
          secret at its creation, and adds it to the access groups that you assign.
          Optionally, you can use this field to provide your own service ID if you prefer
          to manage its access directly or retain the service ID after your secret
          expires, is rotated, or deleted. If you provide a service ID, do not include the
          `access_groups` parameter.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        api_key_id: str = None,
        service_id: str = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str service_id: (optional) The service ID under which the API key
               (see the `api_key` field) is created.
               If you omit this parameter, Secrets Manager generates a new service ID for
               your secret at its creation, and adds it to the access groups that you
               assign.
               Optionally, you can use this field to provide your own service ID if you
               prefer to manage its access directly or retain the service ID after your
               secret expires, is rotated, or deleted. If you provide a service ID, do not
               include the `access_groups` parameter.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.api_key_id = api_key_id
        self.service_id = service_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretVersionMetadata':
        """Initialize a IAMCredentialsSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in IAMCredentialsSecretVersionMetadata JSON')
        if 'api_key_id' in _dict:
            args['api_key_id'] = _dict.get('api_key_id')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'api_key_id') and getattr(self, 'api_key_id') is not None:
            _dict['api_key_id'] = getattr(self, 'api_key_id')
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class IAMCredentialsSecretVersionPrototype(SecretVersionPrototype):
    """
    IAMCredentialsSecretVersionPrototype.

    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a IAMCredentialsSecretVersionPrototype object.

        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'IAMCredentialsSecretVersionPrototype':
        """Initialize a IAMCredentialsSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a IAMCredentialsSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this IAMCredentialsSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'IAMCredentialsSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'IAMCredentialsSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ImportedCertificate(Secret):
    """
    Your imported certificate.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str signing_algorithm: The identifier for the cryptographic algorithm that
          is used by the issuing certificate authority to sign a certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str common_name: (optional) The Common Name (CN) represents the server
          name protected by the SSL certificate.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr bool intermediate_included: Indicates whether the certificate was imported
          with an associated intermediate certificate.
    :attr str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :attr str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :attr bool private_key_included: Indicates whether the certificate was imported
          with an associated private key.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str intermediate: (optional) The PEM-encoded intermediate certificate that
          is associated with the root certificate. The data must be formatted on a single
          line with embedded newline characters.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        expiration_date: datetime,
        intermediate_included: bool,
        issuer: str,
        private_key_included: bool,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        alt_names: List[str] = None,
        common_name: str = None,
        key_algorithm: str = None,
        intermediate: str = None,
        private_key: str = None,
    ) -> None:
        """
        Initialize a ImportedCertificate object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param bool intermediate_included: Indicates whether the certificate was
               imported with an associated intermediate certificate.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param bool private_key_included: Indicates whether the certificate was
               imported with an associated private key.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name protected by the SSL certificate.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.intermediate_included = intermediate_included
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.private_key_included = private_key_included
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificate':
        """Initialize a ImportedCertificate object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificate JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ImportedCertificate JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificate JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificate JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ImportedCertificate JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ImportedCertificate JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in ImportedCertificate JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificate JSON')
        if 'intermediate_included' in _dict:
            args['intermediate_included'] = _dict.get('intermediate_included')
        else:
            raise ValueError('Required property \'intermediate_included\' not present in ImportedCertificate JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in ImportedCertificate JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'private_key_included' in _dict:
            args['private_key_included'] = _dict.get('private_key_included')
        else:
            raise ValueError('Required property \'private_key_included\' not present in ImportedCertificate JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificate JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificate JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificate JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'intermediate_included') and self.intermediate_included is not None:
            _dict['intermediate_included'] = self.intermediate_included
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'private_key_included') and self.private_key_included is not None:
            _dict['private_key_included'] = self.private_key_included
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ImportedCertificateMetadata(SecretMetadata):
    """
    Properties of the secret metadata of your imported certificate.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str signing_algorithm: The identifier for the cryptographic algorithm that
          is used by the issuing certificate authority to sign a certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str common_name: (optional) The Common Name (CN) represents the server
          name protected by the SSL certificate.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr bool intermediate_included: Indicates whether the certificate was imported
          with an associated intermediate certificate.
    :attr str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :attr str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :attr bool private_key_included: Indicates whether the certificate was imported
          with an associated private key.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        expiration_date: datetime,
        intermediate_included: bool,
        issuer: str,
        private_key_included: bool,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        alt_names: List[str] = None,
        common_name: str = None,
        key_algorithm: str = None,
    ) -> None:
        """
        Initialize a ImportedCertificateMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param bool intermediate_included: Indicates whether the certificate was
               imported with an associated intermediate certificate.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param bool private_key_included: Indicates whether the certificate was
               imported with an associated private key.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name protected by the SSL certificate.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.intermediate_included = intermediate_included
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.private_key_included = private_key_included
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateMetadata':
        """Initialize a ImportedCertificateMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificateMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in ImportedCertificateMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificateMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificateMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in ImportedCertificateMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in ImportedCertificateMetadata JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in ImportedCertificateMetadata JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificateMetadata JSON')
        if 'intermediate_included' in _dict:
            args['intermediate_included'] = _dict.get('intermediate_included')
        else:
            raise ValueError('Required property \'intermediate_included\' not present in ImportedCertificateMetadata JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in ImportedCertificateMetadata JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'private_key_included' in _dict:
            args['private_key_included'] = _dict.get('private_key_included')
        else:
            raise ValueError('Required property \'private_key_included\' not present in ImportedCertificateMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificateMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificateMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'intermediate_included') and self.intermediate_included is not None:
            _dict['intermediate_included'] = self.intermediate_included
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'private_key_included') and self.private_key_included is not None:
            _dict['private_key_included'] = self.private_key_included
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class ImportedCertificateMetadataPatch(SecretMetadataPatch):
    """
    ImportedCertificateMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a ImportedCertificateMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateMetadataPatch':
        """Initialize a ImportedCertificateMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ImportedCertificatePrototype(SecretPrototype):
    """
    ImportedCertificatePrototype.

    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str intermediate: (optional) The PEM-encoded intermediate certificate that
          is associated with the root certificate. The data must be formatted on a single
          line with embedded newline characters.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        certificate: str,
        *,
        description: str = None,
        secret_group_id: str = None,
        labels: List[str] = None,
        intermediate: str = None,
        private_key: str = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a ImportedCertificatePrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificatePrototype':
        """Initialize a ImportedCertificatePrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in ImportedCertificatePrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificatePrototype JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class ImportedCertificateVersion(SecretVersion):
    """
    Versions of your imported certificate.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str intermediate: (optional) The PEM-encoded intermediate certificate that
          is associated with the root certificate. The data must be formatted on a single
          line with embedded newline characters.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        intermediate: str = None,
        private_key: str = None,
    ) -> None:
        """
        Initialize a ImportedCertificateVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateVersion':
        """Initialize a ImportedCertificateVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificateVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificateVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificateVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificateVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificateVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ImportedCertificateVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ImportedCertificateVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificateVersion JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificateVersion JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificateVersion JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificateVersion JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ImportedCertificateVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your imported certificate.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a ImportedCertificateVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateVersionMetadata':
        """Initialize a ImportedCertificateVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in ImportedCertificateVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in ImportedCertificateVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in ImportedCertificateVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in ImportedCertificateVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in ImportedCertificateVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in ImportedCertificateVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in ImportedCertificateVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in ImportedCertificateVersionMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in ImportedCertificateVersionMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in ImportedCertificateVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class ImportedCertificateVersionPrototype(SecretVersionPrototype):
    """
    ImportedCertificateVersionPrototype.

    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str intermediate: (optional) The PEM-encoded intermediate certificate that
          is associated with the root certificate. The data must be formatted on a single
          line with embedded newline characters.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        certificate: str,
        *,
        intermediate: str = None,
        private_key: str = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a ImportedCertificateVersionPrototype object.

        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ImportedCertificateVersionPrototype':
        """Initialize a ImportedCertificateVersionPrototype object from a json dictionary."""
        args = {}
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in ImportedCertificateVersionPrototype JSON')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ImportedCertificateVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ImportedCertificateVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ImportedCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ImportedCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KVSecret(Secret):
    """
    Your key-value secret.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr dict data: The payload data of a key-value secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        data: dict,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
    ) -> None:
        """
        Initialize a KVSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict data: The payload data of a key-value secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecret':
        """Initialize a KVSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in KVSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in KVSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in KVSecret JSON')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecret JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class KVSecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your key-value secret metadata.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
    ) -> None:
        """
        Initialize a KVSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretMetadata':
        """Initialize a KVSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in KVSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in KVSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in KVSecretMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class KVSecretMetadataPatch(SecretMetadataPatch):
    """
    KVSecretMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a KVSecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretMetadataPatch':
        """Initialize a KVSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KVSecretPrototype(SecretPrototype):
    """
    KVSecretPrototype.

    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict data: The payload data of a key-value secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        data: dict,
        *,
        description: str = None,
        secret_group_id: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a KVSecretPrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param dict data: The payload data of a key-value secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.data = data
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretPrototype':
        """Initialize a KVSecretPrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in KVSecretPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecretPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class KVSecretVersion(SecretVersion):
    """
    Your key-value secret version.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr dict data: The payload data of a key-value secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        data: dict,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a KVSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param dict data: The payload data of a key-value secret.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretVersion':
        """Initialize a KVSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in KVSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in KVSecretVersion JSON')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecretVersion JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class KVSecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your key-value secret.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a KVSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretVersionMetadata':
        """Initialize a KVSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in KVSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in KVSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in KVSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in KVSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in KVSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in KVSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in KVSecretVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class KVSecretVersionPrototype(SecretVersionPrototype):
    """
    KVSecretVersionPrototype.

    :attr dict data: The payload data of a key-value secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        data: dict,
        *,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a KVSecretVersionPrototype object.

        :param dict data: The payload data of a key-value secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.data = data
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KVSecretVersionPrototype':
        """Initialize a KVSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        else:
            raise ValueError('Required property \'data\' not present in KVSecretVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KVSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KVSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KVSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KVSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificate(Secret):
    """
    Your private certificate.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str signing_algorithm: The identifier for the cryptographic algorithm that
          is used by the issuing certificate authority to sign a certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str certificate_authority: (optional) The intermediate certificate
          authority that signed this certificate.
    :attr str certificate_template: The name of the certificate template.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :attr str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :attr datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :attr int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    :attr datetime revocation_time_rfc3339: (optional) The date and time that the
          certificate was revoked. The date format follows `RFC 3339`.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str private_key: The PEM-encoded private key that is associated with the
          certificate. The data must be formatted on a single line with embedded newline
          characters.
    :attr str issuing_ca: (optional) The PEM-encoded certificate of the certificate
          authority that signed and issued this certificate.
    :attr List[str] ca_chain: (optional) The chain of certificate authorities that
          are associated with the certificate.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        certificate_template: str,
        common_name: str,
        expiration_date: datetime,
        issuer: str,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        private_key: str,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        alt_names: List[str] = None,
        certificate_authority: str = None,
        key_algorithm: str = None,
        next_rotation_date: datetime = None,
        rotation: 'RotationPolicy' = None,
        revocation_time_seconds: int = None,
        revocation_time_rfc3339: datetime = None,
        issuing_ca: str = None,
        ca_chain: List[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificate object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param str certificate_template: The name of the certificate template.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: The PEM-encoded private key that is associated with
               the certificate. The data must be formatted on a single line with embedded
               newline characters.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.certificate_authority = certificate_authority
        self.certificate_template = certificate_template
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.next_rotation_date = next_rotation_date
        self.rotation = rotation
        self.serial_number = serial_number
        self.validity = validity
        self.revocation_time_seconds = revocation_time_seconds
        self.revocation_time_rfc3339 = revocation_time_rfc3339
        self.certificate = certificate
        self.private_key = private_key
        self.issuing_ca = issuing_ca
        self.ca_chain = ca_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificate':
        """Initialize a PrivateCertificate object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificate JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PrivateCertificate JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificate JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificate JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificate JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PrivateCertificate JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in PrivateCertificate JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        if 'certificate_template' in _dict:
            args['certificate_template'] = _dict.get('certificate_template')
        else:
            raise ValueError('Required property \'certificate_template\' not present in PrivateCertificate JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificate JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificate JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in PrivateCertificate JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificate JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificate JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        if 'revocation_time_rfc3339' in _dict:
            args['revocation_time_rfc3339'] = string_to_datetime(_dict.get('revocation_time_rfc3339'))
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificate JSON')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        else:
            raise ValueError('Required property \'private_key\' not present in PrivateCertificate JSON')
        if 'issuing_ca' in _dict:
            args['issuing_ca'] = _dict.get('issuing_ca')
        if 'ca_chain' in _dict:
            args['ca_chain'] = _dict.get('ca_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'certificate_authority') and getattr(self, 'certificate_authority') is not None:
            _dict['certificate_authority'] = getattr(self, 'certificate_authority')
        if hasattr(self, 'certificate_template') and self.certificate_template is not None:
            _dict['certificate_template'] = self.certificate_template
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        if hasattr(self, 'revocation_time_rfc3339') and getattr(self, 'revocation_time_rfc3339') is not None:
            _dict['revocation_time_rfc3339'] = datetime_to_string(getattr(self, 'revocation_time_rfc3339'))
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'issuing_ca') and getattr(self, 'issuing_ca') is not None:
            _dict['issuing_ca'] = getattr(self, 'issuing_ca')
        if hasattr(self, 'ca_chain') and getattr(self, 'ca_chain') is not None:
            _dict['ca_chain'] = getattr(self, 'ca_chain')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PrivateCertificateActionRevoke(SecretAction):
    """
    The response body of the action to revoke the private certificate.

    :attr str action_type: The type of secret action.
    :attr int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    """

    def __init__(
        self,
        action_type: str,
        *,
        revocation_time_seconds: int = None,
    ) -> None:
        """
        Initialize a PrivateCertificateActionRevoke object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.revocation_time_seconds = revocation_time_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateActionRevoke':
        """Initialize a PrivateCertificateActionRevoke object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateActionRevoke JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateActionRevoke object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateActionRevoke object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateActionRevoke') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateActionRevoke') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateActionRevokePrototype(SecretActionPrototype):
    """
    The request body to specify the properties of the action to revoke the private
    certificate.

    :attr str action_type: The type of secret action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateActionRevokePrototype object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateActionRevokePrototype':
        """Initialize a PrivateCertificateActionRevokePrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateActionRevokePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateActionRevokePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateActionRevokePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateActionRevokePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateActionRevokePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateConfigurationActionRevoke(ConfigurationAction):
    """
    The response body to specify the properties of the action to revoke the private
    certificate.

    :attr str action_type: The type of configuration action.
    :attr int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    """

    def __init__(
        self,
        action_type: str,
        *,
        revocation_time_seconds: int = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRevoke object.

        :param str action_type: The type of configuration action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.revocation_time_seconds = revocation_time_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRevoke':
        """Initialize a PrivateCertificateConfigurationActionRevoke object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRevoke JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRevoke object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRevoke object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRevoke') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRevoke') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionRevokePrototype(ConfigurationActionPrototype):
    """
    The request body to specify the properties of the action to revoke the private
    certificate configuration.

    :attr str action_type: The type of configuration action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRevokePrototype object.

        :param str action_type: The type of configuration action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRevokePrototype':
        """Initialize a PrivateCertificateConfigurationActionRevokePrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRevokePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRevokePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRevokePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRevokePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRevokePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionRotateCRL(ConfigurationAction):
    """
    The response body of the action to rotate the CRL of an intermediate certificate
    authority for the private certificate configuration.

    :attr str action_type: The type of configuration action.
    :attr bool success: This field indicates whether the request to rotate the CRL
          for the private certificate configuration was successful.
    """

    def __init__(
        self,
        action_type: str,
        success: bool,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRotateCRL object.

        :param str action_type: The type of configuration action.
        :param bool success: This field indicates whether the request to rotate the
               CRL for the private certificate configuration was successful.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.success = success

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRotateCRL':
        """Initialize a PrivateCertificateConfigurationActionRotateCRL object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRotateCRL JSON')
        if 'success' in _dict:
            args['success'] = _dict.get('success')
        else:
            raise ValueError('Required property \'success\' not present in PrivateCertificateConfigurationActionRotateCRL JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRotateCRL object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'success') and self.success is not None:
            _dict['success'] = self.success
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRotateCRL object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRotateCRL') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRotateCRL') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionRotateCRLPrototype(ConfigurationActionPrototype):
    """
    The request body of the action to rotate the CRL of an intermediate certificate
    authority for the private certificate configuration.

    :attr str action_type: The type of configuration action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionRotateCRLPrototype object.

        :param str action_type: The type of configuration action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionRotateCRLPrototype':
        """Initialize a PrivateCertificateConfigurationActionRotateCRLPrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionRotateCRLPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionRotateCRLPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionRotateCRLPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionRotateCRLPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionRotateCRLPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSetSigned(ConfigurationAction):
    """
    The response body of the action to set a signed intermediate certificate authority for
    the private certificate configuration.

    :attr str action_type: The type of configuration action.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    """

    def __init__(
        self,
        action_type: str,
        certificate: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSetSigned object.

        :param str action_type: The type of configuration action.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.certificate = certificate

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSetSigned':
        """Initialize a PrivateCertificateConfigurationActionSetSigned object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSetSigned JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateConfigurationActionSetSigned JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSetSigned object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSetSigned object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSetSigned') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSetSigned') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSetSignedPrototype(ConfigurationActionPrototype):
    """
    The request body of the action to set a signed intermediate certificate authority for
    the private certificate consideration.

    :attr str action_type: The type of configuration action.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    """

    def __init__(
        self,
        action_type: str,
        certificate: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSetSignedPrototype object.

        :param str action_type: The type of configuration action.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.certificate = certificate

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSetSignedPrototype':
        """Initialize a PrivateCertificateConfigurationActionSetSignedPrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSetSignedPrototype JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateConfigurationActionSetSignedPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSetSignedPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSetSignedPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSetSignedPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSetSignedPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignCSR(ConfigurationAction):
    """
    The response body of the action to sign the CSR for the private certificate
    configuration.

    :attr str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :attr str format: (optional) The format of the returned data.
    :attr int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :attr bool use_csr_values: (optional) This field indicates whether to use values
          from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :attr str action_type: The type of configuration action.
    :attr str csr: The certificate signing request.
    :attr PrivateCertificateConfigurationCACertificate data: (optional) The data
          that is associated with the root certificate authority.
    """

    def __init__(
        self,
        action_type: str,
        csr: str,
        *,
        common_name: str = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        ttl: str = None,
        format: str = None,
        max_path_length: int = None,
        exclude_cn_from_sans: bool = None,
        permitted_dns_domains: List[str] = None,
        use_csr_values: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
        data: 'PrivateCertificateConfigurationCACertificate' = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignCSR object.

        :param str action_type: The type of configuration action.
        :param str csr: The certificate signing request.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.csr = csr
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignCSR':
        """Initialize a PrivateCertificateConfigurationActionSignCSR object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignCSR JSON')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        else:
            raise ValueError('Required property \'csr\' not present in PrivateCertificateConfigurationActionSignCSR JSON')
        if 'data' in _dict:
            args['data'] = PrivateCertificateConfigurationCACertificate.from_dict(_dict.get('data'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignCSR object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        if hasattr(self, 'data') and getattr(self, 'data') is not None:
            if isinstance(getattr(self, 'data'), dict):
                _dict['data'] = getattr(self, 'data')
            else:
                _dict['data'] = getattr(self, 'data').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignCSR object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignCSR') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignCSR') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignCSRPrototype(ConfigurationActionPrototype):
    """
    The request body to specify the properties of the action to sign a CSR for the private
    certificate configuration.

    :attr str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :attr str format: (optional) The format of the returned data.
    :attr int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :attr bool use_csr_values: (optional) This field indicates whether to use values
          from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :attr str action_type: The type of configuration action.
    :attr str csr: The certificate signing request.
    """

    def __init__(
        self,
        action_type: str,
        csr: str,
        *,
        common_name: str = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        ttl: str = None,
        format: str = None,
        max_path_length: int = None,
        exclude_cn_from_sans: bool = None,
        permitted_dns_domains: List[str] = None,
        use_csr_values: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignCSRPrototype object.

        :param str action_type: The type of configuration action.
        :param str csr: The certificate signing request.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.csr = csr

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignCSRPrototype':
        """Initialize a PrivateCertificateConfigurationActionSignCSRPrototype object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignCSRPrototype JSON')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        else:
            raise ValueError('Required property \'csr\' not present in PrivateCertificateConfigurationActionSignCSRPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignCSRPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignCSRPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignCSRPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignCSRPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignIntermediate(ConfigurationAction):
    """
    The response body of the action to sign the intermediate certificate authority for the
    private certificate configuration.

    :attr str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :attr str format: (optional) The format of the returned data.
    :attr int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :attr bool use_csr_values: (optional) This field indicates whether to use values
          from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :attr str action_type: The type of configuration action.
    :attr str intermediate_certificate_authority: The unique name of your
          configuration.
    """

    def __init__(
        self,
        action_type: str,
        intermediate_certificate_authority: str,
        *,
        common_name: str = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        ttl: str = None,
        format: str = None,
        max_path_length: int = None,
        exclude_cn_from_sans: bool = None,
        permitted_dns_domains: List[str] = None,
        use_csr_values: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignIntermediate object.

        :param str action_type: The type of configuration action.
        :param str intermediate_certificate_authority: The unique name of your
               configuration.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.intermediate_certificate_authority = intermediate_certificate_authority

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignIntermediate':
        """Initialize a PrivateCertificateConfigurationActionSignIntermediate object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignIntermediate JSON')
        if 'intermediate_certificate_authority' in _dict:
            args['intermediate_certificate_authority'] = _dict.get('intermediate_certificate_authority')
        else:
            raise ValueError('Required property \'intermediate_certificate_authority\' not present in PrivateCertificateConfigurationActionSignIntermediate JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignIntermediate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'intermediate_certificate_authority') and self.intermediate_certificate_authority is not None:
            _dict['intermediate_certificate_authority'] = self.intermediate_certificate_authority
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignIntermediate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignIntermediate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignIntermediate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationActionSignIntermediatePrototype(ConfigurationActionPrototype):
    """
    The request body to specify the properties of the action to sign an intermediate
    certificate authority for the private certificate configuration.

    :attr str common_name: (optional) The Common Name (CN) represents the server
          name that is protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :attr str format: (optional) The format of the returned data.
    :attr int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :attr bool use_csr_values: (optional) This field indicates whether to use values
          from a certificate signing request (CSR) to complete a
          `private_cert_configuration_action_sign_csr` action. If it is set to `true`,
          then:
          1) Subject information, including names and alternate names, are preserved from
          the CSR rather than by using the values that are provided in the other
          parameters to this operation.
          2) Any key usage, for example, non-repudiation, that is requested in the CSR are
          added to the basic set of key usages used for CA certificates that are signed by
          the intermediate authority.
          3) Extensions that are requested in the CSR are copied into the issued private
          certificate.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    :attr str action_type: The type of configuration action.
    :attr str intermediate_certificate_authority: The unique name of your
          configuration.
    """

    def __init__(
        self,
        action_type: str,
        intermediate_certificate_authority: str,
        *,
        common_name: str = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        ttl: str = None,
        format: str = None,
        max_path_length: int = None,
        exclude_cn_from_sans: bool = None,
        permitted_dns_domains: List[str] = None,
        use_csr_values: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationActionSignIntermediatePrototype object.

        :param str action_type: The type of configuration action.
        :param str intermediate_certificate_authority: The unique name of your
               configuration.
        :param str common_name: (optional) The Common Name (CN) represents the
               server name that is protected by the SSL certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param str format: (optional) The format of the returned data.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param bool use_csr_values: (optional) This field indicates whether to use
               values from a certificate signing request (CSR) to complete a
               `private_cert_configuration_action_sign_csr` action. If it is set to
               `true`, then:
               1) Subject information, including names and alternate names, are preserved
               from the CSR rather than by using the values that are provided in the other
               parameters to this operation.
               2) Any key usage, for example, non-repudiation, that is requested in the
               CSR are added to the basic set of key usages used for CA certificates that
               are signed by the intermediate authority.
               3) Extensions that are requested in the CSR are copied into the issued
               private certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.use_csr_values = use_csr_values
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.action_type = action_type
        self.intermediate_certificate_authority = intermediate_certificate_authority

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationActionSignIntermediatePrototype':
        """Initialize a PrivateCertificateConfigurationActionSignIntermediatePrototype object from a json dictionary."""
        args = {}
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'use_csr_values' in _dict:
            args['use_csr_values'] = _dict.get('use_csr_values')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateConfigurationActionSignIntermediatePrototype JSON')
        if 'intermediate_certificate_authority' in _dict:
            args['intermediate_certificate_authority'] = _dict.get('intermediate_certificate_authority')
        else:
            raise ValueError('Required property \'intermediate_certificate_authority\' not present in PrivateCertificateConfigurationActionSignIntermediatePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationActionSignIntermediatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'use_csr_values') and self.use_csr_values is not None:
            _dict['use_csr_values'] = self.use_csr_values
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'intermediate_certificate_authority') and self.intermediate_certificate_authority is not None:
            _dict['intermediate_certificate_authority'] = self.intermediate_certificate_authority
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationActionSignIntermediatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationActionSignIntermediatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationActionSignIntermediatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class ActionTypeEnum(str, Enum):
        """
        The type of configuration action.
        """

        PRIVATE_CERT_CONFIGURATION_ACTION_ROTATE_CRL = 'private_cert_configuration_action_rotate_crl'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_INTERMEDIATE = 'private_cert_configuration_action_sign_intermediate'
        PRIVATE_CERT_CONFIGURATION_ACTION_SIGN_CSR = 'private_cert_configuration_action_sign_csr'
        PRIVATE_CERT_CONFIGURATION_ACTION_SET_SIGNED = 'private_cert_configuration_action_set_signed'
        PRIVATE_CERT_CONFIGURATION_ACTION_REVOKE_CA_CERTIFICATE = 'private_cert_configuration_action_revoke_ca_certificate'



class PrivateCertificateConfigurationCACertificate(PrivateCertificateCAData):
    """
    The data that is associated with the root certificate authority.

    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str issuing_ca: (optional) The PEM-encoded certificate of the certificate
          authority that signed and issued this certificate.
    :attr List[str] ca_chain: (optional) The chain of certificate authorities that
          are associated with the certificate.
    :attr int expiration: (optional) The certificate expiration time.
    """

    def __init__(
        self,
        certificate: str,
        *,
        issuing_ca: str = None,
        ca_chain: List[str] = None,
        expiration: int = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationCACertificate object.

        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.certificate = certificate
        self.issuing_ca = issuing_ca
        self.ca_chain = ca_chain
        self.expiration = expiration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationCACertificate':
        """Initialize a PrivateCertificateConfigurationCACertificate object from a json dictionary."""
        args = {}
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateConfigurationCACertificate JSON')
        if 'issuing_ca' in _dict:
            args['issuing_ca'] = _dict.get('issuing_ca')
        if 'ca_chain' in _dict:
            args['ca_chain'] = _dict.get('ca_chain')
        if 'expiration' in _dict:
            args['expiration'] = _dict.get('expiration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationCACertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'issuing_ca') and getattr(self, 'issuing_ca') is not None:
            _dict['issuing_ca'] = getattr(self, 'issuing_ca')
        if hasattr(self, 'ca_chain') and getattr(self, 'ca_chain') is not None:
            _dict['ca_chain'] = getattr(self, 'ca_chain')
        if hasattr(self, 'expiration') and getattr(self, 'expiration') is not None:
            _dict['expiration'] = getattr(self, 'expiration')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationCACertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationCACertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationCACertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateConfigurationIntermediateCA(Configuration):
    """
    The configuration of the root certificate authority.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr str signing_method: The signing method to use with this certificate
          authority to generate private certificates.
          You can choose between internal or externally signed options. For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
    :attr str status: (optional) The status of the certificate authority. The status
          of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    :attr int max_ttl_seconds: (optional) The maximum time-to-live (TTL) for
          certificates that are created by this CA in seconds.
    :attr int crl_expiry_seconds: (optional) The time until the certificate
          revocation list (CRL) expires, in seconds.
    :attr bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :attr bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str format: (optional) The format of the returned data.
    :attr str private_key_format: (optional) The format of the generated private
          key.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :attr PrivateCertificateCAData data: (optional) The configuration data of your
          Private Certificate.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        signing_method: str,
        *,
        crl_distribution_points_encoded: bool = None,
        expiration_date: datetime = None,
        issuer: str = None,
        key_type: str = None,
        key_bits: int = None,
        status: str = None,
        max_ttl_seconds: int = None,
        crl_expiry_seconds: int = None,
        crl_disable: bool = None,
        issuing_certificates_urls_encoded: bool = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        format: str = None,
        private_key_format: str = None,
        exclude_cn_from_sans: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
        data: 'PrivateCertificateCAData' = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCA object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str signing_method: The signing method to use with this certificate
               authority to generate private certificates.
               You can choose between internal or externally signed options. For more
               information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param PrivateCertificateCAData data: (optional) The configuration data of
               your Private Certificate.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_type = key_type
        self.key_bits = key_bits
        self.signing_method = signing_method
        self.status = status
        self.max_ttl_seconds = max_ttl_seconds
        self.crl_expiry_seconds = crl_expiry_seconds
        self.crl_disable = crl_disable
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.format = format
        self.private_key_format = private_key_format
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCA':
        """Initialize a PrivateCertificateConfigurationIntermediateCA object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'signing_method' in _dict:
            args['signing_method'] = _dict.get('signing_method')
        else:
            raise ValueError('Required property \'signing_method\' not present in PrivateCertificateConfigurationIntermediateCA JSON')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'max_ttl_seconds' in _dict:
            args['max_ttl_seconds'] = _dict.get('max_ttl_seconds')
        if 'crl_expiry_seconds' in _dict:
            args['crl_expiry_seconds'] = _dict.get('crl_expiry_seconds')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCA object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'signing_method') and self.signing_method is not None:
            _dict['signing_method'] = self.signing_method
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        if hasattr(self, 'max_ttl_seconds') and getattr(self, 'max_ttl_seconds') is not None:
            _dict['max_ttl_seconds'] = getattr(self, 'max_ttl_seconds')
        if hasattr(self, 'crl_expiry_seconds') and getattr(self, 'crl_expiry_seconds') is not None:
            _dict['crl_expiry_seconds'] = getattr(self, 'crl_expiry_seconds')
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'data') and self.data is not None:
            if isinstance(self.data, dict):
                _dict['data'] = self.data
            else:
                _dict['data'] = self.data.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCA object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCA') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCA') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class SigningMethodEnum(str, Enum):
        """
        The signing method to use with this certificate authority to generate private
        certificates.
        You can choose between internal or externally signed options. For more
        information, see the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        """

        INTERNAL = 'internal'
        EXTERNAL = 'external'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'



class PrivateCertificateConfigurationIntermediateCACSR(PrivateCertificateCAData):
    """
    The data that is associated with the intermediate certificate authority.

    :attr str csr: (optional) The certificate signing request.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    :attr str private_key_type: (optional) The type of private key to generate.
    :attr int expiration: (optional) The certificate expiration time.
    """

    def __init__(
        self,
        *,
        csr: str = None,
        private_key: str = None,
        private_key_type: str = None,
        expiration: int = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCACSR object.

        :param str csr: (optional) The certificate signing request.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        :param str private_key_type: (optional) The type of private key to
               generate.
        """
        # pylint: disable=super-init-not-called
        self.csr = csr
        self.private_key = private_key
        self.private_key_type = private_key_type
        self.expiration = expiration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCACSR':
        """Initialize a PrivateCertificateConfigurationIntermediateCACSR object from a json dictionary."""
        args = {}
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        if 'private_key_type' in _dict:
            args['private_key_type'] = _dict.get('private_key_type')
        if 'expiration' in _dict:
            args['expiration'] = _dict.get('expiration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCACSR object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'private_key_type') and self.private_key_type is not None:
            _dict['private_key_type'] = self.private_key_type
        if hasattr(self, 'expiration') and getattr(self, 'expiration') is not None:
            _dict['expiration'] = getattr(self, 'expiration')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCACSR object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCACSR') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCACSR') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class PrivateKeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationIntermediateCAMetadata(ConfigurationMetadata):
    """
    The configuration of the metadata properties of the intermediate certificate
    authority.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr str signing_method: The signing method to use with this certificate
          authority to generate private certificates.
          You can choose between internal or externally signed options. For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
    :attr str status: (optional) The status of the certificate authority. The status
          of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        signing_method: str,
        *,
        crl_distribution_points_encoded: bool = None,
        expiration_date: datetime = None,
        issuer: str = None,
        key_type: str = None,
        key_bits: int = None,
        status: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCAMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str signing_method: The signing method to use with this certificate
               authority to generate private certificates.
               You can choose between internal or externally signed options. For more
               information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_type = key_type
        self.key_bits = key_bits
        self.signing_method = signing_method
        self.status = status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCAMetadata':
        """Initialize a PrivateCertificateConfigurationIntermediateCAMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'signing_method' in _dict:
            args['signing_method'] = _dict.get('signing_method')
        else:
            raise ValueError('Required property \'signing_method\' not present in PrivateCertificateConfigurationIntermediateCAMetadata JSON')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCAMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'signing_method') and self.signing_method is not None:
            _dict['signing_method'] = self.signing_method
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCAMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCAMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCAMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class SigningMethodEnum(str, Enum):
        """
        The signing method to use with this certificate authority to generate private
        certificates.
        You can choose between internal or externally signed options. For more
        information, see the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        """

        INTERNAL = 'internal'
        EXTERNAL = 'external'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'



class PrivateCertificateConfigurationIntermediateCAPatch(ConfigurationPatch):
    """
    The configuration patch of the intermediate certificate authority.

    :attr str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :attr str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :attr bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    """

    def __init__(
        self,
        *,
        max_ttl: str = None,
        crl_expiry: str = None,
        crl_disable: bool = None,
        crl_distribution_points_encoded: bool = None,
        issuing_certificates_urls_encoded: bool = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCAPatch object.

        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        """
        # pylint: disable=super-init-not-called
        self.max_ttl = max_ttl
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCAPatch':
        """Initialize a PrivateCertificateConfigurationIntermediateCAPatch object from a json dictionary."""
        args = {}
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCAPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCAPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCAPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCAPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateConfigurationIntermediateCAPrototype(ConfigurationPrototype):
    """
    The configuration of the intermediate certificate authority.

    :attr str config_type: The configuration type.
    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str max_ttl: The maximum time-to-live (TTL) for certificates that are
          created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :attr str signing_method: The signing method to use with this certificate
          authority to generate private certificates.
          You can choose between internal or externally signed options. For more
          information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
    :attr str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :attr str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :attr bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str format: (optional) The format of the returned data.
    :attr str private_key_format: (optional) The format of the generated private
          key.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        max_ttl: str,
        signing_method: str,
        common_name: str,
        *,
        issuer: str = None,
        crl_expiry: str = None,
        crl_disable: bool = None,
        crl_distribution_points_encoded: bool = None,
        issuing_certificates_urls_encoded: bool = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        format: str = None,
        private_key_format: str = None,
        key_type: str = None,
        key_bits: int = None,
        exclude_cn_from_sans: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationIntermediateCAPrototype object.

        :param str config_type: The configuration type.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str max_ttl: The maximum time-to-live (TTL) for certificates that
               are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str signing_method: The signing method to use with this certificate
               authority to generate private certificates.
               You can choose between internal or externally signed options. For more
               information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.max_ttl = max_ttl
        self.signing_method = signing_method
        self.issuer = issuer
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.format = format
        self.private_key_format = private_key_format
        self.key_type = key_type
        self.key_bits = key_bits
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationIntermediateCAPrototype':
        """Initialize a PrivateCertificateConfigurationIntermediateCAPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        else:
            raise ValueError('Required property \'max_ttl\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'signing_method' in _dict:
            args['signing_method'] = _dict.get('signing_method')
        else:
            raise ValueError('Required property \'signing_method\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationIntermediateCAPrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationIntermediateCAPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'signing_method') and self.signing_method is not None:
            _dict['signing_method'] = self.signing_method
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationIntermediateCAPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationIntermediateCAPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationIntermediateCAPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SigningMethodEnum(str, Enum):
        """
        The signing method to use with this certificate authority to generate private
        certificates.
        You can choose between internal or externally signed options. For more
        information, see the
        [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-intermediate-certificate-authorities).
        """

        INTERNAL = 'internal'
        EXTERNAL = 'external'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationRootCA(Configuration):
    """
    The root certificate authority .

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr str status: (optional) The status of the certificate authority. The status
          of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    :attr int max_ttl_seconds: (optional) The maximum time-to-live (TTL) for
          certificates that are created by this CA in seconds.
    :attr int crl_expiry_seconds: (optional) The time until the certificate
          revocation list (CRL) expires, in seconds.
    :attr bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :attr bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr int ttl_seconds: (optional) he requested TTL, after which the certificate
          expires.
    :attr str format: (optional) The format of the returned data.
    :attr str private_key_format: (optional) The format of the generated private
          key.
    :attr int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :attr PrivateCertificateCAData data: (optional) The configuration data of your
          Private Certificate.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        *,
        crl_distribution_points_encoded: bool = None,
        expiration_date: datetime = None,
        key_type: str = None,
        key_bits: int = None,
        status: str = None,
        max_ttl_seconds: int = None,
        crl_expiry_seconds: int = None,
        crl_disable: bool = None,
        issuing_certificates_urls_encoded: bool = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        ttl_seconds: int = None,
        format: str = None,
        private_key_format: str = None,
        max_path_length: int = None,
        exclude_cn_from_sans: bool = None,
        permitted_dns_domains: List[str] = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
        data: 'PrivateCertificateCAData' = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCA object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param PrivateCertificateCAData data: (optional) The configuration data of
               your Private Certificate.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.key_type = key_type
        self.key_bits = key_bits
        self.status = status
        self.max_ttl_seconds = max_ttl_seconds
        self.crl_expiry_seconds = crl_expiry_seconds
        self.crl_disable = crl_disable
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl_seconds = ttl_seconds
        self.format = format
        self.private_key_format = private_key_format
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.data = data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCA':
        """Initialize a PrivateCertificateConfigurationRootCA object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationRootCA JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'max_ttl_seconds' in _dict:
            args['max_ttl_seconds'] = _dict.get('max_ttl_seconds')
        if 'crl_expiry_seconds' in _dict:
            args['crl_expiry_seconds'] = _dict.get('crl_expiry_seconds')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl_seconds' in _dict:
            args['ttl_seconds'] = _dict.get('ttl_seconds')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'data' in _dict:
            args['data'] = _dict.get('data')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCA object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        if hasattr(self, 'max_ttl_seconds') and getattr(self, 'max_ttl_seconds') is not None:
            _dict['max_ttl_seconds'] = getattr(self, 'max_ttl_seconds')
        if hasattr(self, 'crl_expiry_seconds') and getattr(self, 'crl_expiry_seconds') is not None:
            _dict['crl_expiry_seconds'] = getattr(self, 'crl_expiry_seconds')
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl_seconds') and getattr(self, 'ttl_seconds') is not None:
            _dict['ttl_seconds'] = getattr(self, 'ttl_seconds')
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'data') and self.data is not None:
            if isinstance(self.data, dict):
                _dict['data'] = self.data
            else:
                _dict['data'] = self.data.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCA object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCA') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCA') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'



class PrivateCertificateConfigurationRootCAMetadata(ConfigurationMetadata):
    """
    The configuration of the metadata properties of the root certificate authority.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr str status: (optional) The status of the certificate authority. The status
          of a root certificate authority is either `configured` or `expired`. For
          intermediate certificate authorities, possible statuses include
          `signing_required`,
          `signed_certificate_required`, `certificate_template_required`, `configured`,
          `expired` or `revoked`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        common_name: str,
        *,
        crl_distribution_points_encoded: bool = None,
        expiration_date: datetime = None,
        key_type: str = None,
        key_bits: int = None,
        status: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCAMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.common_name = common_name
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.expiration_date = expiration_date
        self.key_type = key_type
        self.key_bits = key_bits
        self.status = status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCAMetadata':
        """Initialize a PrivateCertificateConfigurationRootCAMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationRootCAMetadata JSON')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCAMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'status') and getattr(self, 'status') is not None:
            _dict['status'] = getattr(self, 'status')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCAMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCAMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCAMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'


    class StatusEnum(str, Enum):
        """
        The status of the certificate authority. The status of a root certificate
        authority is either `configured` or `expired`. For intermediate certificate
        authorities, possible statuses include `signing_required`,
        `signed_certificate_required`, `certificate_template_required`, `configured`,
        `expired` or `revoked`.
        """

        SIGNING_REQUIRED = 'signing_required'
        SIGNED_CERTIFICATE_REQUIRED = 'signed_certificate_required'
        CERTIFICATE_TEMPLATE_REQUIRED = 'certificate_template_required'
        CONFIGURED = 'configured'
        EXPIRED = 'expired'
        REVOKED = 'revoked'



class PrivateCertificateConfigurationRootCAPatch(ConfigurationPatch):
    """
    The configuration of the metadata patch for the root certificate authority.

    :attr str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :attr str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :attr bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    """

    def __init__(
        self,
        *,
        max_ttl: str = None,
        crl_expiry: str = None,
        crl_disable: bool = None,
        crl_distribution_points_encoded: bool = None,
        issuing_certificates_urls_encoded: bool = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCAPatch object.

        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        """
        # pylint: disable=super-init-not-called
        self.max_ttl = max_ttl
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCAPatch':
        """Initialize a PrivateCertificateConfigurationRootCAPatch object from a json dictionary."""
        args = {}
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCAPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCAPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCAPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCAPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificateConfigurationRootCAPrototype(ConfigurationPrototype):
    """
    The configuration of the root certificate authority.

    :attr str config_type: The configuration type.
    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str max_ttl: The maximum time-to-live (TTL) for certificates that are
          created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :attr str crl_expiry: (optional) The time until the certificate revocation list
          (CRL) expires.
          The value can be supplied as a string representation of a duration in hours,
          such as `48h`. The default is 72 hours. In the API response, this value is
          returned in seconds (integer).
          **Note:** The CRL is rotated automatically before it expires.
    :attr bool crl_disable: (optional) This field disables or enables certificate
          revocation list (CRL) building.
          If CRL building is disabled, a signed but zero-length CRL is returned when
          you're downloading the CRL. If CRL building is enabled, it rebuilds the CRL.
    :attr bool crl_distribution_points_encoded: (optional) This field determines
          whether to encode the certificate revocation list (CRL) distribution points in
          the certificates that are issued by this certificate authority.
    :attr bool issuing_certificates_urls_encoded: (optional) This field determines
          whether to encode the URL of the issuing certificate in the certificates that
          are issued by this certificate authority.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str ttl: (optional) The requested time-to-live (TTL) for certificates that
          are created by this CA. This field's value can't be longer than the `max_ttl`
          limit.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
    :attr str format: (optional) The format of the returned data.
    :attr str private_key_format: (optional) The format of the generated private
          key.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr int max_path_length: (optional) The maximum path length to encode in the
          generated certificate. `-1` means no limit.
          If the signing certificate has a maximum path length set, the path length is set
          to one less than that of the signing certificate. A limit of `0` means a literal
          path length of zero.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr List[str] permitted_dns_domains: (optional) The allowed DNS domains or
          subdomains for the certificates that are to be signed and issued by this CA
          certificate.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) The requested value for the
          [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
          attribute that is in the certificate's distinguished name (DN).
          **Note:** This field is not related to the `serial_number` field that is
          returned in the API response. The `serial_number` field represents the
          certificate's randomly assigned serial number.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        max_ttl: str,
        common_name: str,
        *,
        crl_expiry: str = None,
        crl_disable: bool = None,
        crl_distribution_points_encoded: bool = None,
        issuing_certificates_urls_encoded: bool = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        ttl: str = None,
        format: str = None,
        private_key_format: str = None,
        key_type: str = None,
        key_bits: int = None,
        max_path_length: int = None,
        exclude_cn_from_sans: bool = None,
        permitted_dns_domains: List[str] = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationRootCAPrototype object.

        :param str config_type: The configuration type.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str max_ttl: The maximum time-to-live (TTL) for certificates that
               are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str crl_expiry: (optional) The time until the certificate revocation
               list (CRL) expires.
               The value can be supplied as a string representation of a duration in
               hours, such as `48h`. The default is 72 hours. In the API response, this
               value is returned in seconds (integer).
               **Note:** The CRL is rotated automatically before it expires.
        :param bool crl_disable: (optional) This field disables or enables
               certificate revocation list (CRL) building.
               If CRL building is disabled, a signed but zero-length CRL is returned when
               you're downloading the CRL. If CRL building is enabled, it rebuilds the
               CRL.
        :param bool crl_distribution_points_encoded: (optional) This field
               determines whether to encode the certificate revocation list (CRL)
               distribution points in the certificates that are issued by this certificate
               authority.
        :param bool issuing_certificates_urls_encoded: (optional) This field
               determines whether to encode the URL of the issuing certificate in the
               certificates that are issued by this certificate authority.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str ttl: (optional) The requested time-to-live (TTL) for
               certificates that are created by this CA. This field's value can't be
               longer than the `max_ttl` limit.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param int max_path_length: (optional) The maximum path length to encode in
               the generated certificate. `-1` means no limit.
               If the signing certificate has a maximum path length set, the path length
               is set to one less than that of the signing certificate. A limit of `0`
               means a literal path length of zero.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param List[str] permitted_dns_domains: (optional) The allowed DNS domains
               or subdomains for the certificates that are to be signed and issued by this
               CA certificate.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) The requested value for the
               [`serialNumber`](https://datatracker.ietf.org/doc/html/rfc4519#section-2.31)
               attribute that is in the certificate's distinguished name (DN).
               **Note:** This field is not related to the `serial_number` field that is
               returned in the API response. The `serial_number` field represents the
               certificate's randomly assigned serial number.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.max_ttl = max_ttl
        self.crl_expiry = crl_expiry
        self.crl_disable = crl_disable
        self.crl_distribution_points_encoded = crl_distribution_points_encoded
        self.issuing_certificates_urls_encoded = issuing_certificates_urls_encoded
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.ttl = ttl
        self.format = format
        self.private_key_format = private_key_format
        self.key_type = key_type
        self.key_bits = key_bits
        self.max_path_length = max_path_length
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.permitted_dns_domains = permitted_dns_domains
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationRootCAPrototype':
        """Initialize a PrivateCertificateConfigurationRootCAPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        else:
            raise ValueError('Required property \'max_ttl\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'crl_expiry' in _dict:
            args['crl_expiry'] = _dict.get('crl_expiry')
        if 'crl_disable' in _dict:
            args['crl_disable'] = _dict.get('crl_disable')
        if 'crl_distribution_points_encoded' in _dict:
            args['crl_distribution_points_encoded'] = _dict.get('crl_distribution_points_encoded')
        if 'issuing_certificates_urls_encoded' in _dict:
            args['issuing_certificates_urls_encoded'] = _dict.get('issuing_certificates_urls_encoded')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateConfigurationRootCAPrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'max_path_length' in _dict:
            args['max_path_length'] = _dict.get('max_path_length')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'permitted_dns_domains' in _dict:
            args['permitted_dns_domains'] = _dict.get('permitted_dns_domains')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationRootCAPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'crl_expiry') and self.crl_expiry is not None:
            _dict['crl_expiry'] = self.crl_expiry
        if hasattr(self, 'crl_disable') and self.crl_disable is not None:
            _dict['crl_disable'] = self.crl_disable
        if hasattr(self, 'crl_distribution_points_encoded') and self.crl_distribution_points_encoded is not None:
            _dict['crl_distribution_points_encoded'] = self.crl_distribution_points_encoded
        if hasattr(self, 'issuing_certificates_urls_encoded') and self.issuing_certificates_urls_encoded is not None:
            _dict['issuing_certificates_urls_encoded'] = self.issuing_certificates_urls_encoded
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'max_path_length') and self.max_path_length is not None:
            _dict['max_path_length'] = self.max_path_length
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'permitted_dns_domains') and self.permitted_dns_domains is not None:
            _dict['permitted_dns_domains'] = self.permitted_dns_domains
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationRootCAPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationRootCAPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationRootCAPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationTemplate(Configuration):
    """
    The configuration of the private certificate template.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str certificate_authority: The name of the intermediate certificate
          authority.
    :attr str allowed_secret_groups: (optional) This field scopes the creation of
          private certificates to only the secret groups that you specify.
          This field can be supplied as a comma-delimited list of secret group IDs.
    :attr int max_ttl_seconds: (optional) The maximum time-to-live (TTL) for
          certificates that are created by this CA in seconds.
    :attr int ttl_seconds: (optional) he requested TTL, after which the certificate
          expires.
    :attr bool allow_localhost: (optional) This field indicates whether to allow
          `localhost` to be included as one of the requested common names.
    :attr List[str] allowed_domains: (optional) The domains to define for the
          certificate template. This property is used along with the `allow_bare_domains`
          and `allow_subdomains` options.
    :attr bool allowed_domains_template: (optional) This field indicates whether to
          allow the domains that are supplied in the `allowed_domains` field to contain
          access control list (ACL) templates.
    :attr bool allow_bare_domains: (optional) This field indicates whether to allow
          clients to request private certificates that match the value of the actual
          domains on the final certificate.
          For example, if you specify `example.com` in the `allowed_domains` field, you
          grant clients the ability to request a certificate that contains the name
          `example.com` as one of the DNS values on the final certificate.
          **Important:** In some scenarios, allowing bare domains can be considered a
          security risk.
    :attr bool allow_subdomains: (optional) This field indicates whether to allow
          clients to request private certificates with common names (CN) that are
          subdomains of the CNs that are allowed by the other certificate template
          options. This includes wildcard subdomains.
          For example, if `allowed_domains` has a value of `example.com` and
          `allow_subdomains`is set to `true`, then the following subdomains are allowed:
          `foo.example.com`, `bar.example.com`, `*.example.com`.
          **Note:** This field is redundant if you use the `allow_any_name` option.
    :attr bool allow_glob_domains: (optional) This field indicates whether to allow
          glob patterns, for example, `ftp*.example.com`, in the names that are specified
          in the `allowed_domains` field.
          If set to `true`, clients are allowed to request private certificates with names
          that match the glob patterns.
    :attr bool allow_any_name: (optional) This field indicates whether to allow
          clients to request a private certificate that matches any common name.
    :attr bool enforce_hostnames: (optional) This field indicates whether to enforce
          only valid hostnames for common names, DNS Subject Alternative Names, and the
          host section of email addresses.
    :attr bool allow_ip_sans: (optional) This field indicates whether to allow
          clients to request a private certificate with IP Subject Alternative Names.
    :attr List[str] allowed_uri_sans: (optional) The URI Subject Alternative Names
          to allow for private certificates.
          Values can contain glob patterns, for example `spiffe://hostname/*`.
    :attr List[str] allowed_other_sans: (optional) The custom Object Identifier
          (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private
          certificates.
          The format for each element in the list is the same as OpenSSL:
          `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
          value for an OID, use `*` as its value. Alternatively, specify a single `*` to
          allow any `other_sans` input.
    :attr bool server_flag: (optional) This field indicates whether private
          certificates are flagged for server use.
    :attr bool client_flag: (optional) This field indicates whether private
          certificates are flagged for client use.
    :attr bool code_signing_flag: (optional) This field indicates whether private
          certificates are flagged for code signing use.
    :attr bool email_protection_flag: (optional) This field indicates whether
          private certificates are flagged for email protection use.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr List[str] key_usage: (optional) The allowed key usage constraint to define
          for private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage`
          part of the value. Values are not case-sensitive. To specify no key usage
          constraints, set this field to an empty list.
    :attr List[str] ext_key_usage: (optional) The allowed extended key usage
          constraint on private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
          `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no
          key usage constraints, set this field to an empty list.
    :attr List[str] ext_key_usage_oids: (optional) A list of extended key usage
          Object Identifiers (OIDs).
    :attr bool use_csr_common_name: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the common name (CN) from a certificate signing request (CSR)
          instead of the CN that is included in the data of the certificate.
          Does not include any requested Subject Alternative Names (SANs) in the CSR. To
          use the alternative names, include the `use_csr_sans` property.
    :attr bool use_csr_sans: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the Subject Alternative Names
          (SANs) from a certificate signing request (CSR) instead of the SANs that are
          included in the data of the certificate.
          This field does not include the common name in the CSR. To use the common name,
          include the `use_csr_common_name` property.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) This field is deprecated. You can ignore its
          value.
    :attr bool require_cn: (optional) This field indicates whether to require a
          common name to create a private certificate.
          By default, a common name is required to generate a certificate. To make the
          `common_name` field optional, set the `require_cn` option to `false`.
    :attr List[str] policy_identifiers: (optional) A list of policy Object
          Identifiers (OIDs).
    :attr bool basic_constraints_valid_for_non_ca: (optional) This field indicates
          whether to mark the Basic Constraints extension of an issued private certificate
          as valid for non-CA certificates.
    :attr int not_before_duration_seconds: (optional) The duration in seconds by
          which to backdate the `not_before` property of an issued private certificate.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        certificate_authority: str,
        *,
        allowed_secret_groups: str = None,
        max_ttl_seconds: int = None,
        ttl_seconds: int = None,
        allow_localhost: bool = None,
        allowed_domains: List[str] = None,
        allowed_domains_template: bool = None,
        allow_bare_domains: bool = None,
        allow_subdomains: bool = None,
        allow_glob_domains: bool = None,
        allow_any_name: bool = None,
        enforce_hostnames: bool = None,
        allow_ip_sans: bool = None,
        allowed_uri_sans: List[str] = None,
        allowed_other_sans: List[str] = None,
        server_flag: bool = None,
        client_flag: bool = None,
        code_signing_flag: bool = None,
        email_protection_flag: bool = None,
        key_type: str = None,
        key_bits: int = None,
        key_usage: List[str] = None,
        ext_key_usage: List[str] = None,
        ext_key_usage_oids: List[str] = None,
        use_csr_common_name: bool = None,
        use_csr_sans: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
        require_cn: bool = None,
        policy_identifiers: List[str] = None,
        basic_constraints_valid_for_non_ca: bool = None,
        not_before_duration_seconds: int = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplate object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str certificate_authority: The name of the intermediate certificate
               authority.
        :param str allowed_secret_groups: (optional) This field scopes the creation
               of private certificates to only the secret groups that you specify.
               This field can be supplied as a comma-delimited list of secret group IDs.
        :param bool allow_localhost: (optional) This field indicates whether to
               allow `localhost` to be included as one of the requested common names.
        :param List[str] allowed_domains: (optional) The domains to define for the
               certificate template. This property is used along with the
               `allow_bare_domains` and `allow_subdomains` options.
        :param bool allowed_domains_template: (optional) This field indicates
               whether to allow the domains that are supplied in the `allowed_domains`
               field to contain access control list (ACL) templates.
        :param bool allow_bare_domains: (optional) This field indicates whether to
               allow clients to request private certificates that match the value of the
               actual domains on the final certificate.
               For example, if you specify `example.com` in the `allowed_domains` field,
               you grant clients the ability to request a certificate that contains the
               name `example.com` as one of the DNS values on the final certificate.
               **Important:** In some scenarios, allowing bare domains can be considered a
               security risk.
        :param bool allow_subdomains: (optional) This field indicates whether to
               allow clients to request private certificates with common names (CN) that
               are subdomains of the CNs that are allowed by the other certificate
               template options. This includes wildcard subdomains.
               For example, if `allowed_domains` has a value of `example.com` and
               `allow_subdomains`is set to `true`, then the following subdomains are
               allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.
               **Note:** This field is redundant if you use the `allow_any_name` option.
        :param bool allow_glob_domains: (optional) This field indicates whether to
               allow glob patterns, for example, `ftp*.example.com`, in the names that are
               specified in the `allowed_domains` field.
               If set to `true`, clients are allowed to request private certificates with
               names that match the glob patterns.
        :param bool allow_any_name: (optional) This field indicates whether to
               allow clients to request a private certificate that matches any common
               name.
        :param bool enforce_hostnames: (optional) This field indicates whether to
               enforce only valid hostnames for common names, DNS Subject Alternative
               Names, and the host section of email addresses.
        :param bool allow_ip_sans: (optional) This field indicates whether to allow
               clients to request a private certificate with IP Subject Alternative Names.
        :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative
               Names to allow for private certificates.
               Values can contain glob patterns, for example `spiffe://hostname/*`.
        :param List[str] allowed_other_sans: (optional) The custom Object
               Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow
               for private certificates.
               The format for each element in the list is the same as OpenSSL:
               `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
               value for an OID, use `*` as its value. Alternatively, specify a single `*`
               to allow any `other_sans` input.
        :param bool server_flag: (optional) This field indicates whether private
               certificates are flagged for server use.
        :param bool client_flag: (optional) This field indicates whether private
               certificates are flagged for client use.
        :param bool code_signing_flag: (optional) This field indicates whether
               private certificates are flagged for code signing use.
        :param bool email_protection_flag: (optional) This field indicates whether
               private certificates are flagged for email protection use.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param List[str] key_usage: (optional) The allowed key usage constraint to
               define for private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the
               `KeyUsage` part of the value. Values are not case-sensitive. To specify no
               key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage: (optional) The allowed extended key usage
               constraint on private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
               `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify
               no key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage_oids: (optional) A list of extended key
               usage Object Identifiers (OIDs).
        :param bool use_csr_common_name: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the common name (CN) from a certificate signing request
               (CSR) instead of the CN that is included in the data of the certificate.
               Does not include any requested Subject Alternative Names (SANs) in the CSR.
               To use the alternative names, include the `use_csr_sans` property.
        :param bool use_csr_sans: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the Subject Alternative Names
               (SANs) from a certificate signing request (CSR) instead of the SANs that
               are included in the data of the certificate.
               This field does not include the common name in the CSR. To use the common
               name, include the `use_csr_common_name` property.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) This field is deprecated. You can
               ignore its value.
        :param bool require_cn: (optional) This field indicates whether to require
               a common name to create a private certificate.
               By default, a common name is required to generate a certificate. To make
               the `common_name` field optional, set the `require_cn` option to `false`.
        :param List[str] policy_identifiers: (optional) A list of policy Object
               Identifiers (OIDs).
        :param bool basic_constraints_valid_for_non_ca: (optional) This field
               indicates whether to mark the Basic Constraints extension of an issued
               private certificate as valid for non-CA certificates.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.certificate_authority = certificate_authority
        self.allowed_secret_groups = allowed_secret_groups
        self.max_ttl_seconds = max_ttl_seconds
        self.ttl_seconds = ttl_seconds
        self.allow_localhost = allow_localhost
        self.allowed_domains = allowed_domains
        self.allowed_domains_template = allowed_domains_template
        self.allow_bare_domains = allow_bare_domains
        self.allow_subdomains = allow_subdomains
        self.allow_glob_domains = allow_glob_domains
        self.allow_any_name = allow_any_name
        self.enforce_hostnames = enforce_hostnames
        self.allow_ip_sans = allow_ip_sans
        self.allowed_uri_sans = allowed_uri_sans
        self.allowed_other_sans = allowed_other_sans
        self.server_flag = server_flag
        self.client_flag = client_flag
        self.code_signing_flag = code_signing_flag
        self.email_protection_flag = email_protection_flag
        self.key_type = key_type
        self.key_bits = key_bits
        self.key_usage = key_usage
        self.ext_key_usage = ext_key_usage
        self.ext_key_usage_oids = ext_key_usage_oids
        self.use_csr_common_name = use_csr_common_name
        self.use_csr_sans = use_csr_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.require_cn = require_cn
        self.policy_identifiers = policy_identifiers
        self.basic_constraints_valid_for_non_ca = basic_constraints_valid_for_non_ca
        self.not_before_duration_seconds = not_before_duration_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplate':
        """Initialize a PrivateCertificateConfigurationTemplate object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        else:
            raise ValueError('Required property \'certificate_authority\' not present in PrivateCertificateConfigurationTemplate JSON')
        if 'allowed_secret_groups' in _dict:
            args['allowed_secret_groups'] = _dict.get('allowed_secret_groups')
        if 'max_ttl_seconds' in _dict:
            args['max_ttl_seconds'] = _dict.get('max_ttl_seconds')
        if 'ttl_seconds' in _dict:
            args['ttl_seconds'] = _dict.get('ttl_seconds')
        if 'allow_localhost' in _dict:
            args['allow_localhost'] = _dict.get('allow_localhost')
        if 'allowed_domains' in _dict:
            args['allowed_domains'] = _dict.get('allowed_domains')
        if 'allowed_domains_template' in _dict:
            args['allowed_domains_template'] = _dict.get('allowed_domains_template')
        if 'allow_bare_domains' in _dict:
            args['allow_bare_domains'] = _dict.get('allow_bare_domains')
        if 'allow_subdomains' in _dict:
            args['allow_subdomains'] = _dict.get('allow_subdomains')
        if 'allow_glob_domains' in _dict:
            args['allow_glob_domains'] = _dict.get('allow_glob_domains')
        if 'allow_any_name' in _dict:
            args['allow_any_name'] = _dict.get('allow_any_name')
        if 'enforce_hostnames' in _dict:
            args['enforce_hostnames'] = _dict.get('enforce_hostnames')
        if 'allow_ip_sans' in _dict:
            args['allow_ip_sans'] = _dict.get('allow_ip_sans')
        if 'allowed_uri_sans' in _dict:
            args['allowed_uri_sans'] = _dict.get('allowed_uri_sans')
        if 'allowed_other_sans' in _dict:
            args['allowed_other_sans'] = _dict.get('allowed_other_sans')
        if 'server_flag' in _dict:
            args['server_flag'] = _dict.get('server_flag')
        if 'client_flag' in _dict:
            args['client_flag'] = _dict.get('client_flag')
        if 'code_signing_flag' in _dict:
            args['code_signing_flag'] = _dict.get('code_signing_flag')
        if 'email_protection_flag' in _dict:
            args['email_protection_flag'] = _dict.get('email_protection_flag')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'key_usage' in _dict:
            args['key_usage'] = _dict.get('key_usage')
        if 'ext_key_usage' in _dict:
            args['ext_key_usage'] = _dict.get('ext_key_usage')
        if 'ext_key_usage_oids' in _dict:
            args['ext_key_usage_oids'] = _dict.get('ext_key_usage_oids')
        if 'use_csr_common_name' in _dict:
            args['use_csr_common_name'] = _dict.get('use_csr_common_name')
        if 'use_csr_sans' in _dict:
            args['use_csr_sans'] = _dict.get('use_csr_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'require_cn' in _dict:
            args['require_cn'] = _dict.get('require_cn')
        if 'policy_identifiers' in _dict:
            args['policy_identifiers'] = _dict.get('policy_identifiers')
        if 'basic_constraints_valid_for_non_ca' in _dict:
            args['basic_constraints_valid_for_non_ca'] = _dict.get('basic_constraints_valid_for_non_ca')
        if 'not_before_duration_seconds' in _dict:
            args['not_before_duration_seconds'] = _dict.get('not_before_duration_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'certificate_authority') and self.certificate_authority is not None:
            _dict['certificate_authority'] = self.certificate_authority
        if hasattr(self, 'allowed_secret_groups') and self.allowed_secret_groups is not None:
            _dict['allowed_secret_groups'] = self.allowed_secret_groups
        if hasattr(self, 'max_ttl_seconds') and getattr(self, 'max_ttl_seconds') is not None:
            _dict['max_ttl_seconds'] = getattr(self, 'max_ttl_seconds')
        if hasattr(self, 'ttl_seconds') and getattr(self, 'ttl_seconds') is not None:
            _dict['ttl_seconds'] = getattr(self, 'ttl_seconds')
        if hasattr(self, 'allow_localhost') and self.allow_localhost is not None:
            _dict['allow_localhost'] = self.allow_localhost
        if hasattr(self, 'allowed_domains') and self.allowed_domains is not None:
            _dict['allowed_domains'] = self.allowed_domains
        if hasattr(self, 'allowed_domains_template') and self.allowed_domains_template is not None:
            _dict['allowed_domains_template'] = self.allowed_domains_template
        if hasattr(self, 'allow_bare_domains') and self.allow_bare_domains is not None:
            _dict['allow_bare_domains'] = self.allow_bare_domains
        if hasattr(self, 'allow_subdomains') and self.allow_subdomains is not None:
            _dict['allow_subdomains'] = self.allow_subdomains
        if hasattr(self, 'allow_glob_domains') and self.allow_glob_domains is not None:
            _dict['allow_glob_domains'] = self.allow_glob_domains
        if hasattr(self, 'allow_any_name') and self.allow_any_name is not None:
            _dict['allow_any_name'] = self.allow_any_name
        if hasattr(self, 'enforce_hostnames') and self.enforce_hostnames is not None:
            _dict['enforce_hostnames'] = self.enforce_hostnames
        if hasattr(self, 'allow_ip_sans') and self.allow_ip_sans is not None:
            _dict['allow_ip_sans'] = self.allow_ip_sans
        if hasattr(self, 'allowed_uri_sans') and self.allowed_uri_sans is not None:
            _dict['allowed_uri_sans'] = self.allowed_uri_sans
        if hasattr(self, 'allowed_other_sans') and self.allowed_other_sans is not None:
            _dict['allowed_other_sans'] = self.allowed_other_sans
        if hasattr(self, 'server_flag') and self.server_flag is not None:
            _dict['server_flag'] = self.server_flag
        if hasattr(self, 'client_flag') and self.client_flag is not None:
            _dict['client_flag'] = self.client_flag
        if hasattr(self, 'code_signing_flag') and self.code_signing_flag is not None:
            _dict['code_signing_flag'] = self.code_signing_flag
        if hasattr(self, 'email_protection_flag') and self.email_protection_flag is not None:
            _dict['email_protection_flag'] = self.email_protection_flag
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'key_usage') and self.key_usage is not None:
            _dict['key_usage'] = self.key_usage
        if hasattr(self, 'ext_key_usage') and self.ext_key_usage is not None:
            _dict['ext_key_usage'] = self.ext_key_usage
        if hasattr(self, 'ext_key_usage_oids') and self.ext_key_usage_oids is not None:
            _dict['ext_key_usage_oids'] = self.ext_key_usage_oids
        if hasattr(self, 'use_csr_common_name') and self.use_csr_common_name is not None:
            _dict['use_csr_common_name'] = self.use_csr_common_name
        if hasattr(self, 'use_csr_sans') and self.use_csr_sans is not None:
            _dict['use_csr_sans'] = self.use_csr_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'require_cn') and self.require_cn is not None:
            _dict['require_cn'] = self.require_cn
        if hasattr(self, 'policy_identifiers') and self.policy_identifiers is not None:
            _dict['policy_identifiers'] = self.policy_identifiers
        if hasattr(self, 'basic_constraints_valid_for_non_ca') and self.basic_constraints_valid_for_non_ca is not None:
            _dict['basic_constraints_valid_for_non_ca'] = self.basic_constraints_valid_for_non_ca
        if hasattr(self, 'not_before_duration_seconds') and getattr(self, 'not_before_duration_seconds') is not None:
            _dict['not_before_duration_seconds'] = getattr(self, 'not_before_duration_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationTemplateMetadata(ConfigurationMetadata):
    """
    The metadata properties of the configuration of the private certificate template.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str certificate_authority: The name of the intermediate certificate
          authority.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        certificate_authority: str,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplateMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str certificate_authority: The name of the intermediate certificate
               authority.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.certificate_authority = certificate_authority

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplateMetadata':
        """Initialize a PrivateCertificateConfigurationTemplateMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        else:
            raise ValueError('Required property \'certificate_authority\' not present in PrivateCertificateConfigurationTemplateMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'certificate_authority') and self.certificate_authority is not None:
            _dict['certificate_authority'] = self.certificate_authority
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class PrivateCertificateConfigurationTemplatePatch(ConfigurationPatch):
    """
    Properties that describe a certificate template. You can use a certificate template to
    control the parameters that are applied to your issued private certificates. For more
    information, see the
    [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-certificate-templates).

    :attr str allowed_secret_groups: (optional) This field scopes the creation of
          private certificates to only the secret groups that you specify.
          This field can be supplied as a comma-delimited list of secret group IDs.
    :attr str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :attr str ttl: (optional) The requested time-to-live (TTL) for certificates that
          are created by this CA. This field's value can't be longer than the `max_ttl`
          limit.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
    :attr bool allow_localhost: (optional) This field indicates whether to allow
          `localhost` to be included as one of the requested common names.
    :attr List[str] allowed_domains: (optional) The domains to define for the
          certificate template. This property is used along with the `allow_bare_domains`
          and `allow_subdomains` options.
    :attr bool allowed_domains_template: (optional) This field indicates whether to
          allow the domains that are supplied in the `allowed_domains` field to contain
          access control list (ACL) templates.
    :attr bool allow_bare_domains: (optional) This field indicates whether to allow
          clients to request private certificates that match the value of the actual
          domains on the final certificate.
          For example, if you specify `example.com` in the `allowed_domains` field, you
          grant clients the ability to request a certificate that contains the name
          `example.com` as one of the DNS values on the final certificate.
          **Important:** In some scenarios, allowing bare domains can be considered a
          security risk.
    :attr bool allow_subdomains: (optional) This field indicates whether to allow
          clients to request private certificates with common names (CN) that are
          subdomains of the CNs that are allowed by the other certificate template
          options. This includes wildcard subdomains.
          For example, if `allowed_domains` has a value of `example.com` and
          `allow_subdomains`is set to `true`, then the following subdomains are allowed:
          `foo.example.com`, `bar.example.com`, `*.example.com`.
          **Note:** This field is redundant if you use the `allow_any_name` option.
    :attr bool allow_glob_domains: (optional) This field indicates whether to allow
          glob patterns, for example, `ftp*.example.com`, in the names that are specified
          in the `allowed_domains` field.
          If set to `true`, clients are allowed to request private certificates with names
          that match the glob patterns.
    :attr bool allow_any_name: (optional) This field indicates whether to allow
          clients to request a private certificate that matches any common name.
    :attr bool enforce_hostnames: (optional) This field indicates whether to enforce
          only valid hostnames for common names, DNS Subject Alternative Names, and the
          host section of email addresses.
    :attr bool allow_ip_sans: (optional) This field indicates whether to allow
          clients to request a private certificate with IP Subject Alternative Names.
    :attr List[str] allowed_uri_sans: (optional) The URI Subject Alternative Names
          to allow for private certificates.
          Values can contain glob patterns, for example `spiffe://hostname/*`.
    :attr List[str] allowed_other_sans: (optional) The custom Object Identifier
          (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private
          certificates.
          The format for each element in the list is the same as OpenSSL:
          `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
          value for an OID, use `*` as its value. Alternatively, specify a single `*` to
          allow any `other_sans` input.
    :attr bool server_flag: (optional) This field indicates whether private
          certificates are flagged for server use.
    :attr bool client_flag: (optional) This field indicates whether private
          certificates are flagged for client use.
    :attr bool code_signing_flag: (optional) This field indicates whether private
          certificates are flagged for code signing use.
    :attr bool email_protection_flag: (optional) This field indicates whether
          private certificates are flagged for email protection use.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr List[str] key_usage: (optional) The allowed key usage constraint to define
          for private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage`
          part of the value. Values are not case-sensitive. To specify no key usage
          constraints, set this field to an empty list.
    :attr List[str] ext_key_usage: (optional) The allowed extended key usage
          constraint on private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
          `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no
          key usage constraints, set this field to an empty list.
    :attr List[str] ext_key_usage_oids: (optional) A list of extended key usage
          Object Identifiers (OIDs).
    :attr bool use_csr_common_name: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the common name (CN) from a certificate signing request (CSR)
          instead of the CN that is included in the data of the certificate.
          Does not include any requested Subject Alternative Names (SANs) in the CSR. To
          use the alternative names, include the `use_csr_sans` property.
    :attr bool use_csr_sans: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the Subject Alternative Names
          (SANs) from a certificate signing request (CSR) instead of the SANs that are
          included in the data of the certificate.
          This field does not include the common name in the CSR. To use the common name,
          include the `use_csr_common_name` property.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) This field is deprecated. You can ignore its
          value.
    :attr bool require_cn: (optional) This field indicates whether to require a
          common name to create a private certificate.
          By default, a common name is required to generate a certificate. To make the
          `common_name` field optional, set the `require_cn` option to `false`.
    :attr List[str] policy_identifiers: (optional) A list of policy Object
          Identifiers (OIDs).
    :attr bool basic_constraints_valid_for_non_ca: (optional) This field indicates
          whether to mark the Basic Constraints extension of an issued private certificate
          as valid for non-CA certificates.
    :attr str not_before_duration: (optional) The duration in seconds by which to
          backdate the `not_before` property of an issued private certificate.
          The value can be supplied as a string representation of a duration, such as
          `30s`. In the API response, this value is returned in seconds (integer).
    """

    def __init__(
        self,
        *,
        allowed_secret_groups: str = None,
        max_ttl: str = None,
        ttl: str = None,
        allow_localhost: bool = None,
        allowed_domains: List[str] = None,
        allowed_domains_template: bool = None,
        allow_bare_domains: bool = None,
        allow_subdomains: bool = None,
        allow_glob_domains: bool = None,
        allow_any_name: bool = None,
        enforce_hostnames: bool = None,
        allow_ip_sans: bool = None,
        allowed_uri_sans: List[str] = None,
        allowed_other_sans: List[str] = None,
        server_flag: bool = None,
        client_flag: bool = None,
        code_signing_flag: bool = None,
        email_protection_flag: bool = None,
        key_type: str = None,
        key_bits: int = None,
        key_usage: List[str] = None,
        ext_key_usage: List[str] = None,
        ext_key_usage_oids: List[str] = None,
        use_csr_common_name: bool = None,
        use_csr_sans: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
        require_cn: bool = None,
        policy_identifiers: List[str] = None,
        basic_constraints_valid_for_non_ca: bool = None,
        not_before_duration: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplatePatch object.

        :param str allowed_secret_groups: (optional) This field scopes the creation
               of private certificates to only the secret groups that you specify.
               This field can be supplied as a comma-delimited list of secret group IDs.
        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str ttl: (optional) The requested time-to-live (TTL) for
               certificates that are created by this CA. This field's value can't be
               longer than the `max_ttl` limit.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
        :param bool allow_localhost: (optional) This field indicates whether to
               allow `localhost` to be included as one of the requested common names.
        :param List[str] allowed_domains: (optional) The domains to define for the
               certificate template. This property is used along with the
               `allow_bare_domains` and `allow_subdomains` options.
        :param bool allowed_domains_template: (optional) This field indicates
               whether to allow the domains that are supplied in the `allowed_domains`
               field to contain access control list (ACL) templates.
        :param bool allow_bare_domains: (optional) This field indicates whether to
               allow clients to request private certificates that match the value of the
               actual domains on the final certificate.
               For example, if you specify `example.com` in the `allowed_domains` field,
               you grant clients the ability to request a certificate that contains the
               name `example.com` as one of the DNS values on the final certificate.
               **Important:** In some scenarios, allowing bare domains can be considered a
               security risk.
        :param bool allow_subdomains: (optional) This field indicates whether to
               allow clients to request private certificates with common names (CN) that
               are subdomains of the CNs that are allowed by the other certificate
               template options. This includes wildcard subdomains.
               For example, if `allowed_domains` has a value of `example.com` and
               `allow_subdomains`is set to `true`, then the following subdomains are
               allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.
               **Note:** This field is redundant if you use the `allow_any_name` option.
        :param bool allow_glob_domains: (optional) This field indicates whether to
               allow glob patterns, for example, `ftp*.example.com`, in the names that are
               specified in the `allowed_domains` field.
               If set to `true`, clients are allowed to request private certificates with
               names that match the glob patterns.
        :param bool allow_any_name: (optional) This field indicates whether to
               allow clients to request a private certificate that matches any common
               name.
        :param bool enforce_hostnames: (optional) This field indicates whether to
               enforce only valid hostnames for common names, DNS Subject Alternative
               Names, and the host section of email addresses.
        :param bool allow_ip_sans: (optional) This field indicates whether to allow
               clients to request a private certificate with IP Subject Alternative Names.
        :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative
               Names to allow for private certificates.
               Values can contain glob patterns, for example `spiffe://hostname/*`.
        :param List[str] allowed_other_sans: (optional) The custom Object
               Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow
               for private certificates.
               The format for each element in the list is the same as OpenSSL:
               `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
               value for an OID, use `*` as its value. Alternatively, specify a single `*`
               to allow any `other_sans` input.
        :param bool server_flag: (optional) This field indicates whether private
               certificates are flagged for server use.
        :param bool client_flag: (optional) This field indicates whether private
               certificates are flagged for client use.
        :param bool code_signing_flag: (optional) This field indicates whether
               private certificates are flagged for code signing use.
        :param bool email_protection_flag: (optional) This field indicates whether
               private certificates are flagged for email protection use.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param List[str] key_usage: (optional) The allowed key usage constraint to
               define for private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the
               `KeyUsage` part of the value. Values are not case-sensitive. To specify no
               key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage: (optional) The allowed extended key usage
               constraint on private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
               `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify
               no key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage_oids: (optional) A list of extended key
               usage Object Identifiers (OIDs).
        :param bool use_csr_common_name: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the common name (CN) from a certificate signing request
               (CSR) instead of the CN that is included in the data of the certificate.
               Does not include any requested Subject Alternative Names (SANs) in the CSR.
               To use the alternative names, include the `use_csr_sans` property.
        :param bool use_csr_sans: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the Subject Alternative Names
               (SANs) from a certificate signing request (CSR) instead of the SANs that
               are included in the data of the certificate.
               This field does not include the common name in the CSR. To use the common
               name, include the `use_csr_common_name` property.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) This field is deprecated. You can
               ignore its value.
        :param bool require_cn: (optional) This field indicates whether to require
               a common name to create a private certificate.
               By default, a common name is required to generate a certificate. To make
               the `common_name` field optional, set the `require_cn` option to `false`.
        :param List[str] policy_identifiers: (optional) A list of policy Object
               Identifiers (OIDs).
        :param bool basic_constraints_valid_for_non_ca: (optional) This field
               indicates whether to mark the Basic Constraints extension of an issued
               private certificate as valid for non-CA certificates.
        :param str not_before_duration: (optional) The duration in seconds by which
               to backdate the `not_before` property of an issued private certificate.
               The value can be supplied as a string representation of a duration, such as
               `30s`. In the API response, this value is returned in seconds (integer).
        """
        # pylint: disable=super-init-not-called
        self.allowed_secret_groups = allowed_secret_groups
        self.max_ttl = max_ttl
        self.ttl = ttl
        self.allow_localhost = allow_localhost
        self.allowed_domains = allowed_domains
        self.allowed_domains_template = allowed_domains_template
        self.allow_bare_domains = allow_bare_domains
        self.allow_subdomains = allow_subdomains
        self.allow_glob_domains = allow_glob_domains
        self.allow_any_name = allow_any_name
        self.enforce_hostnames = enforce_hostnames
        self.allow_ip_sans = allow_ip_sans
        self.allowed_uri_sans = allowed_uri_sans
        self.allowed_other_sans = allowed_other_sans
        self.server_flag = server_flag
        self.client_flag = client_flag
        self.code_signing_flag = code_signing_flag
        self.email_protection_flag = email_protection_flag
        self.key_type = key_type
        self.key_bits = key_bits
        self.key_usage = key_usage
        self.ext_key_usage = ext_key_usage
        self.ext_key_usage_oids = ext_key_usage_oids
        self.use_csr_common_name = use_csr_common_name
        self.use_csr_sans = use_csr_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.require_cn = require_cn
        self.policy_identifiers = policy_identifiers
        self.basic_constraints_valid_for_non_ca = basic_constraints_valid_for_non_ca
        self.not_before_duration = not_before_duration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplatePatch':
        """Initialize a PrivateCertificateConfigurationTemplatePatch object from a json dictionary."""
        args = {}
        if 'allowed_secret_groups' in _dict:
            args['allowed_secret_groups'] = _dict.get('allowed_secret_groups')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'allow_localhost' in _dict:
            args['allow_localhost'] = _dict.get('allow_localhost')
        if 'allowed_domains' in _dict:
            args['allowed_domains'] = _dict.get('allowed_domains')
        if 'allowed_domains_template' in _dict:
            args['allowed_domains_template'] = _dict.get('allowed_domains_template')
        if 'allow_bare_domains' in _dict:
            args['allow_bare_domains'] = _dict.get('allow_bare_domains')
        if 'allow_subdomains' in _dict:
            args['allow_subdomains'] = _dict.get('allow_subdomains')
        if 'allow_glob_domains' in _dict:
            args['allow_glob_domains'] = _dict.get('allow_glob_domains')
        if 'allow_any_name' in _dict:
            args['allow_any_name'] = _dict.get('allow_any_name')
        if 'enforce_hostnames' in _dict:
            args['enforce_hostnames'] = _dict.get('enforce_hostnames')
        if 'allow_ip_sans' in _dict:
            args['allow_ip_sans'] = _dict.get('allow_ip_sans')
        if 'allowed_uri_sans' in _dict:
            args['allowed_uri_sans'] = _dict.get('allowed_uri_sans')
        if 'allowed_other_sans' in _dict:
            args['allowed_other_sans'] = _dict.get('allowed_other_sans')
        if 'server_flag' in _dict:
            args['server_flag'] = _dict.get('server_flag')
        if 'client_flag' in _dict:
            args['client_flag'] = _dict.get('client_flag')
        if 'code_signing_flag' in _dict:
            args['code_signing_flag'] = _dict.get('code_signing_flag')
        if 'email_protection_flag' in _dict:
            args['email_protection_flag'] = _dict.get('email_protection_flag')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'key_usage' in _dict:
            args['key_usage'] = _dict.get('key_usage')
        if 'ext_key_usage' in _dict:
            args['ext_key_usage'] = _dict.get('ext_key_usage')
        if 'ext_key_usage_oids' in _dict:
            args['ext_key_usage_oids'] = _dict.get('ext_key_usage_oids')
        if 'use_csr_common_name' in _dict:
            args['use_csr_common_name'] = _dict.get('use_csr_common_name')
        if 'use_csr_sans' in _dict:
            args['use_csr_sans'] = _dict.get('use_csr_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'require_cn' in _dict:
            args['require_cn'] = _dict.get('require_cn')
        if 'policy_identifiers' in _dict:
            args['policy_identifiers'] = _dict.get('policy_identifiers')
        if 'basic_constraints_valid_for_non_ca' in _dict:
            args['basic_constraints_valid_for_non_ca'] = _dict.get('basic_constraints_valid_for_non_ca')
        if 'not_before_duration' in _dict:
            args['not_before_duration'] = _dict.get('not_before_duration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplatePatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'allowed_secret_groups') and self.allowed_secret_groups is not None:
            _dict['allowed_secret_groups'] = self.allowed_secret_groups
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'allow_localhost') and self.allow_localhost is not None:
            _dict['allow_localhost'] = self.allow_localhost
        if hasattr(self, 'allowed_domains') and self.allowed_domains is not None:
            _dict['allowed_domains'] = self.allowed_domains
        if hasattr(self, 'allowed_domains_template') and self.allowed_domains_template is not None:
            _dict['allowed_domains_template'] = self.allowed_domains_template
        if hasattr(self, 'allow_bare_domains') and self.allow_bare_domains is not None:
            _dict['allow_bare_domains'] = self.allow_bare_domains
        if hasattr(self, 'allow_subdomains') and self.allow_subdomains is not None:
            _dict['allow_subdomains'] = self.allow_subdomains
        if hasattr(self, 'allow_glob_domains') and self.allow_glob_domains is not None:
            _dict['allow_glob_domains'] = self.allow_glob_domains
        if hasattr(self, 'allow_any_name') and self.allow_any_name is not None:
            _dict['allow_any_name'] = self.allow_any_name
        if hasattr(self, 'enforce_hostnames') and self.enforce_hostnames is not None:
            _dict['enforce_hostnames'] = self.enforce_hostnames
        if hasattr(self, 'allow_ip_sans') and self.allow_ip_sans is not None:
            _dict['allow_ip_sans'] = self.allow_ip_sans
        if hasattr(self, 'allowed_uri_sans') and self.allowed_uri_sans is not None:
            _dict['allowed_uri_sans'] = self.allowed_uri_sans
        if hasattr(self, 'allowed_other_sans') and self.allowed_other_sans is not None:
            _dict['allowed_other_sans'] = self.allowed_other_sans
        if hasattr(self, 'server_flag') and self.server_flag is not None:
            _dict['server_flag'] = self.server_flag
        if hasattr(self, 'client_flag') and self.client_flag is not None:
            _dict['client_flag'] = self.client_flag
        if hasattr(self, 'code_signing_flag') and self.code_signing_flag is not None:
            _dict['code_signing_flag'] = self.code_signing_flag
        if hasattr(self, 'email_protection_flag') and self.email_protection_flag is not None:
            _dict['email_protection_flag'] = self.email_protection_flag
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'key_usage') and self.key_usage is not None:
            _dict['key_usage'] = self.key_usage
        if hasattr(self, 'ext_key_usage') and self.ext_key_usage is not None:
            _dict['ext_key_usage'] = self.ext_key_usage
        if hasattr(self, 'ext_key_usage_oids') and self.ext_key_usage_oids is not None:
            _dict['ext_key_usage_oids'] = self.ext_key_usage_oids
        if hasattr(self, 'use_csr_common_name') and self.use_csr_common_name is not None:
            _dict['use_csr_common_name'] = self.use_csr_common_name
        if hasattr(self, 'use_csr_sans') and self.use_csr_sans is not None:
            _dict['use_csr_sans'] = self.use_csr_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'require_cn') and self.require_cn is not None:
            _dict['require_cn'] = self.require_cn
        if hasattr(self, 'policy_identifiers') and self.policy_identifiers is not None:
            _dict['policy_identifiers'] = self.policy_identifiers
        if hasattr(self, 'basic_constraints_valid_for_non_ca') and self.basic_constraints_valid_for_non_ca is not None:
            _dict['basic_constraints_valid_for_non_ca'] = self.basic_constraints_valid_for_non_ca
        if hasattr(self, 'not_before_duration') and self.not_before_duration is not None:
            _dict['not_before_duration'] = self.not_before_duration
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplatePatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplatePatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplatePatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateConfigurationTemplatePrototype(ConfigurationPrototype):
    """
    Properties that describe a certificate template. You can use a certificate template to
    control the parameters that are applied to your issued private certificates. For more
    information, see the
    [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-certificate-templates).

    :attr str config_type: The configuration type.
    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str certificate_authority: The name of the intermediate certificate
          authority.
    :attr str allowed_secret_groups: (optional) This field scopes the creation of
          private certificates to only the secret groups that you specify.
          This field can be supplied as a comma-delimited list of secret group IDs.
    :attr str max_ttl: (optional) The maximum time-to-live (TTL) for certificates
          that are created by this CA.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
          Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
    :attr str ttl: (optional) The requested time-to-live (TTL) for certificates that
          are created by this CA. This field's value can't be longer than the `max_ttl`
          limit.
          The value can be supplied as a string representation of a duration in hours, for
          example '8760h'. In the API response, this value is returned in seconds
          (integer).
    :attr bool allow_localhost: (optional) This field indicates whether to allow
          `localhost` to be included as one of the requested common names.
    :attr List[str] allowed_domains: (optional) The domains to define for the
          certificate template. This property is used along with the `allow_bare_domains`
          and `allow_subdomains` options.
    :attr bool allowed_domains_template: (optional) This field indicates whether to
          allow the domains that are supplied in the `allowed_domains` field to contain
          access control list (ACL) templates.
    :attr bool allow_bare_domains: (optional) This field indicates whether to allow
          clients to request private certificates that match the value of the actual
          domains on the final certificate.
          For example, if you specify `example.com` in the `allowed_domains` field, you
          grant clients the ability to request a certificate that contains the name
          `example.com` as one of the DNS values on the final certificate.
          **Important:** In some scenarios, allowing bare domains can be considered a
          security risk.
    :attr bool allow_subdomains: (optional) This field indicates whether to allow
          clients to request private certificates with common names (CN) that are
          subdomains of the CNs that are allowed by the other certificate template
          options. This includes wildcard subdomains.
          For example, if `allowed_domains` has a value of `example.com` and
          `allow_subdomains`is set to `true`, then the following subdomains are allowed:
          `foo.example.com`, `bar.example.com`, `*.example.com`.
          **Note:** This field is redundant if you use the `allow_any_name` option.
    :attr bool allow_glob_domains: (optional) This field indicates whether to allow
          glob patterns, for example, `ftp*.example.com`, in the names that are specified
          in the `allowed_domains` field.
          If set to `true`, clients are allowed to request private certificates with names
          that match the glob patterns.
    :attr bool allow_wildcard_certificates: (optional) This field indicates whether
          the issuance of certificates with RFC 6125 wildcards in the CN field.
          When set to false, this field prevents wildcards from being issued even if they
          can be allowed by an option `allow_glob_domains`.
    :attr bool allow_any_name: (optional) This field indicates whether to allow
          clients to request a private certificate that matches any common name.
    :attr bool enforce_hostnames: (optional) This field indicates whether to enforce
          only valid hostnames for common names, DNS Subject Alternative Names, and the
          host section of email addresses.
    :attr bool allow_ip_sans: (optional) This field indicates whether to allow
          clients to request a private certificate with IP Subject Alternative Names.
    :attr List[str] allowed_uri_sans: (optional) The URI Subject Alternative Names
          to allow for private certificates.
          Values can contain glob patterns, for example `spiffe://hostname/*`.
    :attr List[str] allowed_other_sans: (optional) The custom Object Identifier
          (OID) or UTF8-string Subject Alternative Names (SANs) to allow for private
          certificates.
          The format for each element in the list is the same as OpenSSL:
          `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
          value for an OID, use `*` as its value. Alternatively, specify a single `*` to
          allow any `other_sans` input.
    :attr bool server_flag: (optional) This field indicates whether private
          certificates are flagged for server use.
    :attr bool client_flag: (optional) This field indicates whether private
          certificates are flagged for client use.
    :attr bool code_signing_flag: (optional) This field indicates whether private
          certificates are flagged for code signing use.
    :attr bool email_protection_flag: (optional) This field indicates whether
          private certificates are flagged for email protection use.
    :attr str key_type: (optional) The type of private key to generate.
    :attr int key_bits: (optional) The number of bits to use to generate the private
          key.
          Allowable values for RSA keys are: `2048` and `4096`. Allowable values for EC
          keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is `2048`.
          The default for EC keys is `256`.
    :attr List[str] key_usage: (optional) The allowed key usage constraint to define
          for private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the `KeyUsage`
          part of the value. Values are not case-sensitive. To specify no key usage
          constraints, set this field to an empty list.
    :attr List[str] ext_key_usage: (optional) The allowed extended key usage
          constraint on private certificates.
          You can find valid values in the [Go x509 package
          documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
          `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify no
          key usage constraints, set this field to an empty list.
    :attr List[str] ext_key_usage_oids: (optional) A list of extended key usage
          Object Identifiers (OIDs).
    :attr bool use_csr_common_name: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the common name (CN) from a certificate signing request (CSR)
          instead of the CN that is included in the data of the certificate.
          Does not include any requested Subject Alternative Names (SANs) in the CSR. To
          use the alternative names, include the `use_csr_sans` property.
    :attr bool use_csr_sans: (optional) When used with the
          `private_cert_configuration_action_sign_csr` action, this field determines
          whether to use the Subject Alternative Names
          (SANs) from a certificate signing request (CSR) instead of the SANs that are
          included in the data of the certificate.
          This field does not include the common name in the CSR. To use the common name,
          include the `use_csr_common_name` property.
    :attr List[str] ou: (optional) The Organizational Unit (OU) values to define in
          the subject field of the resulting certificate.
    :attr List[str] organization: (optional) The Organization (O) values to define
          in the subject field of the resulting certificate.
    :attr List[str] country: (optional) The Country (C) values to define in the
          subject field of the resulting certificate.
    :attr List[str] locality: (optional) The Locality (L) values to define in the
          subject field of the resulting certificate.
    :attr List[str] province: (optional) The Province (ST) values to define in the
          subject field of the resulting certificate.
    :attr List[str] street_address: (optional) The street address values to define
          in the subject field of the resulting certificate.
    :attr List[str] postal_code: (optional) The postal code values to define in the
          subject field of the resulting certificate.
    :attr str serial_number: (optional) This field is deprecated. You can ignore its
          value.
    :attr bool require_cn: (optional) This field indicates whether to require a
          common name to create a private certificate.
          By default, a common name is required to generate a certificate. To make the
          `common_name` field optional, set the `require_cn` option to `false`.
    :attr List[str] policy_identifiers: (optional) A list of policy Object
          Identifiers (OIDs).
    :attr bool basic_constraints_valid_for_non_ca: (optional) This field indicates
          whether to mark the Basic Constraints extension of an issued private certificate
          as valid for non-CA certificates.
    :attr str not_before_duration: (optional) The duration in seconds by which to
          backdate the `not_before` property of an issued private certificate.
          The value can be supplied as a string representation of a duration, such as
          `30s`. In the API response, this value is returned in seconds (integer).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        certificate_authority: str,
        *,
        allowed_secret_groups: str = None,
        max_ttl: str = None,
        ttl: str = None,
        allow_localhost: bool = None,
        allowed_domains: List[str] = None,
        allowed_domains_template: bool = None,
        allow_bare_domains: bool = None,
        allow_subdomains: bool = None,
        allow_glob_domains: bool = None,
        allow_wildcard_certificates: bool = None,
        allow_any_name: bool = None,
        enforce_hostnames: bool = None,
        allow_ip_sans: bool = None,
        allowed_uri_sans: List[str] = None,
        allowed_other_sans: List[str] = None,
        server_flag: bool = None,
        client_flag: bool = None,
        code_signing_flag: bool = None,
        email_protection_flag: bool = None,
        key_type: str = None,
        key_bits: int = None,
        key_usage: List[str] = None,
        ext_key_usage: List[str] = None,
        ext_key_usage_oids: List[str] = None,
        use_csr_common_name: bool = None,
        use_csr_sans: bool = None,
        ou: List[str] = None,
        organization: List[str] = None,
        country: List[str] = None,
        locality: List[str] = None,
        province: List[str] = None,
        street_address: List[str] = None,
        postal_code: List[str] = None,
        serial_number: str = None,
        require_cn: bool = None,
        policy_identifiers: List[str] = None,
        basic_constraints_valid_for_non_ca: bool = None,
        not_before_duration: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateConfigurationTemplatePrototype object.

        :param str config_type: The configuration type.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str certificate_authority: The name of the intermediate certificate
               authority.
        :param str allowed_secret_groups: (optional) This field scopes the creation
               of private certificates to only the secret groups that you specify.
               This field can be supplied as a comma-delimited list of secret group IDs.
        :param str max_ttl: (optional) The maximum time-to-live (TTL) for
               certificates that are created by this CA.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
               Minimum value is one hour (`1h`). Maximum value is 100 years (`876000h`).
        :param str ttl: (optional) The requested time-to-live (TTL) for
               certificates that are created by this CA. This field's value can't be
               longer than the `max_ttl` limit.
               The value can be supplied as a string representation of a duration in
               hours, for example '8760h'. In the API response, this value is returned in
               seconds (integer).
        :param bool allow_localhost: (optional) This field indicates whether to
               allow `localhost` to be included as one of the requested common names.
        :param List[str] allowed_domains: (optional) The domains to define for the
               certificate template. This property is used along with the
               `allow_bare_domains` and `allow_subdomains` options.
        :param bool allowed_domains_template: (optional) This field indicates
               whether to allow the domains that are supplied in the `allowed_domains`
               field to contain access control list (ACL) templates.
        :param bool allow_bare_domains: (optional) This field indicates whether to
               allow clients to request private certificates that match the value of the
               actual domains on the final certificate.
               For example, if you specify `example.com` in the `allowed_domains` field,
               you grant clients the ability to request a certificate that contains the
               name `example.com` as one of the DNS values on the final certificate.
               **Important:** In some scenarios, allowing bare domains can be considered a
               security risk.
        :param bool allow_subdomains: (optional) This field indicates whether to
               allow clients to request private certificates with common names (CN) that
               are subdomains of the CNs that are allowed by the other certificate
               template options. This includes wildcard subdomains.
               For example, if `allowed_domains` has a value of `example.com` and
               `allow_subdomains`is set to `true`, then the following subdomains are
               allowed: `foo.example.com`, `bar.example.com`, `*.example.com`.
               **Note:** This field is redundant if you use the `allow_any_name` option.
        :param bool allow_glob_domains: (optional) This field indicates whether to
               allow glob patterns, for example, `ftp*.example.com`, in the names that are
               specified in the `allowed_domains` field.
               If set to `true`, clients are allowed to request private certificates with
               names that match the glob patterns.
        :param bool allow_wildcard_certificates: (optional) This field indicates
               whether the issuance of certificates with RFC 6125 wildcards in the CN
               field.
               When set to false, this field prevents wildcards from being issued even if
               they can be allowed by an option `allow_glob_domains`.
        :param bool allow_any_name: (optional) This field indicates whether to
               allow clients to request a private certificate that matches any common
               name.
        :param bool enforce_hostnames: (optional) This field indicates whether to
               enforce only valid hostnames for common names, DNS Subject Alternative
               Names, and the host section of email addresses.
        :param bool allow_ip_sans: (optional) This field indicates whether to allow
               clients to request a private certificate with IP Subject Alternative Names.
        :param List[str] allowed_uri_sans: (optional) The URI Subject Alternative
               Names to allow for private certificates.
               Values can contain glob patterns, for example `spiffe://hostname/*`.
        :param List[str] allowed_other_sans: (optional) The custom Object
               Identifier (OID) or UTF8-string Subject Alternative Names (SANs) to allow
               for private certificates.
               The format for each element in the list is the same as OpenSSL:
               `<oid>:<type>:<value>` where the current valid type is `UTF8`. To allow any
               value for an OID, use `*` as its value. Alternatively, specify a single `*`
               to allow any `other_sans` input.
        :param bool server_flag: (optional) This field indicates whether private
               certificates are flagged for server use.
        :param bool client_flag: (optional) This field indicates whether private
               certificates are flagged for client use.
        :param bool code_signing_flag: (optional) This field indicates whether
               private certificates are flagged for code signing use.
        :param bool email_protection_flag: (optional) This field indicates whether
               private certificates are flagged for email protection use.
        :param str key_type: (optional) The type of private key to generate.
        :param int key_bits: (optional) The number of bits to use to generate the
               private key.
               Allowable values for RSA keys are: `2048` and `4096`. Allowable values for
               EC keys are: `224`, `256`, `384`, and `521`. The default for RSA keys is
               `2048`. The default for EC keys is `256`.
        :param List[str] key_usage: (optional) The allowed key usage constraint to
               define for private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://pkg.go.dev/crypto/x509#KeyUsage). Omit the
               `KeyUsage` part of the value. Values are not case-sensitive. To specify no
               key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage: (optional) The allowed extended key usage
               constraint on private certificates.
               You can find valid values in the [Go x509 package
               documentation](https://golang.org/pkg/crypto/x509/#ExtKeyUsage). Omit the
               `ExtKeyUsage` part of the value. Values are not case-sensitive. To specify
               no key usage constraints, set this field to an empty list.
        :param List[str] ext_key_usage_oids: (optional) A list of extended key
               usage Object Identifiers (OIDs).
        :param bool use_csr_common_name: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the common name (CN) from a certificate signing request
               (CSR) instead of the CN that is included in the data of the certificate.
               Does not include any requested Subject Alternative Names (SANs) in the CSR.
               To use the alternative names, include the `use_csr_sans` property.
        :param bool use_csr_sans: (optional) When used with the
               `private_cert_configuration_action_sign_csr` action, this field determines
               whether to use the Subject Alternative Names
               (SANs) from a certificate signing request (CSR) instead of the SANs that
               are included in the data of the certificate.
               This field does not include the common name in the CSR. To use the common
               name, include the `use_csr_common_name` property.
        :param List[str] ou: (optional) The Organizational Unit (OU) values to
               define in the subject field of the resulting certificate.
        :param List[str] organization: (optional) The Organization (O) values to
               define in the subject field of the resulting certificate.
        :param List[str] country: (optional) The Country (C) values to define in
               the subject field of the resulting certificate.
        :param List[str] locality: (optional) The Locality (L) values to define in
               the subject field of the resulting certificate.
        :param List[str] province: (optional) The Province (ST) values to define in
               the subject field of the resulting certificate.
        :param List[str] street_address: (optional) The street address values to
               define in the subject field of the resulting certificate.
        :param List[str] postal_code: (optional) The postal code values to define
               in the subject field of the resulting certificate.
        :param str serial_number: (optional) This field is deprecated. You can
               ignore its value.
        :param bool require_cn: (optional) This field indicates whether to require
               a common name to create a private certificate.
               By default, a common name is required to generate a certificate. To make
               the `common_name` field optional, set the `require_cn` option to `false`.
        :param List[str] policy_identifiers: (optional) A list of policy Object
               Identifiers (OIDs).
        :param bool basic_constraints_valid_for_non_ca: (optional) This field
               indicates whether to mark the Basic Constraints extension of an issued
               private certificate as valid for non-CA certificates.
        :param str not_before_duration: (optional) The duration in seconds by which
               to backdate the `not_before` property of an issued private certificate.
               The value can be supplied as a string representation of a duration, such as
               `30s`. In the API response, this value is returned in seconds (integer).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.certificate_authority = certificate_authority
        self.allowed_secret_groups = allowed_secret_groups
        self.max_ttl = max_ttl
        self.ttl = ttl
        self.allow_localhost = allow_localhost
        self.allowed_domains = allowed_domains
        self.allowed_domains_template = allowed_domains_template
        self.allow_bare_domains = allow_bare_domains
        self.allow_subdomains = allow_subdomains
        self.allow_glob_domains = allow_glob_domains
        self.allow_wildcard_certificates = allow_wildcard_certificates
        self.allow_any_name = allow_any_name
        self.enforce_hostnames = enforce_hostnames
        self.allow_ip_sans = allow_ip_sans
        self.allowed_uri_sans = allowed_uri_sans
        self.allowed_other_sans = allowed_other_sans
        self.server_flag = server_flag
        self.client_flag = client_flag
        self.code_signing_flag = code_signing_flag
        self.email_protection_flag = email_protection_flag
        self.key_type = key_type
        self.key_bits = key_bits
        self.key_usage = key_usage
        self.ext_key_usage = ext_key_usage
        self.ext_key_usage_oids = ext_key_usage_oids
        self.use_csr_common_name = use_csr_common_name
        self.use_csr_sans = use_csr_sans
        self.ou = ou
        self.organization = organization
        self.country = country
        self.locality = locality
        self.province = province
        self.street_address = street_address
        self.postal_code = postal_code
        self.serial_number = serial_number
        self.require_cn = require_cn
        self.policy_identifiers = policy_identifiers
        self.basic_constraints_valid_for_non_ca = basic_constraints_valid_for_non_ca
        self.not_before_duration = not_before_duration

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateConfigurationTemplatePrototype':
        """Initialize a PrivateCertificateConfigurationTemplatePrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PrivateCertificateConfigurationTemplatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificateConfigurationTemplatePrototype JSON')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        else:
            raise ValueError('Required property \'certificate_authority\' not present in PrivateCertificateConfigurationTemplatePrototype JSON')
        if 'allowed_secret_groups' in _dict:
            args['allowed_secret_groups'] = _dict.get('allowed_secret_groups')
        if 'max_ttl' in _dict:
            args['max_ttl'] = _dict.get('max_ttl')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'allow_localhost' in _dict:
            args['allow_localhost'] = _dict.get('allow_localhost')
        if 'allowed_domains' in _dict:
            args['allowed_domains'] = _dict.get('allowed_domains')
        if 'allowed_domains_template' in _dict:
            args['allowed_domains_template'] = _dict.get('allowed_domains_template')
        if 'allow_bare_domains' in _dict:
            args['allow_bare_domains'] = _dict.get('allow_bare_domains')
        if 'allow_subdomains' in _dict:
            args['allow_subdomains'] = _dict.get('allow_subdomains')
        if 'allow_glob_domains' in _dict:
            args['allow_glob_domains'] = _dict.get('allow_glob_domains')
        if 'allow_wildcard_certificates' in _dict:
            args['allow_wildcard_certificates'] = _dict.get('allow_wildcard_certificates')
        if 'allow_any_name' in _dict:
            args['allow_any_name'] = _dict.get('allow_any_name')
        if 'enforce_hostnames' in _dict:
            args['enforce_hostnames'] = _dict.get('enforce_hostnames')
        if 'allow_ip_sans' in _dict:
            args['allow_ip_sans'] = _dict.get('allow_ip_sans')
        if 'allowed_uri_sans' in _dict:
            args['allowed_uri_sans'] = _dict.get('allowed_uri_sans')
        if 'allowed_other_sans' in _dict:
            args['allowed_other_sans'] = _dict.get('allowed_other_sans')
        if 'server_flag' in _dict:
            args['server_flag'] = _dict.get('server_flag')
        if 'client_flag' in _dict:
            args['client_flag'] = _dict.get('client_flag')
        if 'code_signing_flag' in _dict:
            args['code_signing_flag'] = _dict.get('code_signing_flag')
        if 'email_protection_flag' in _dict:
            args['email_protection_flag'] = _dict.get('email_protection_flag')
        if 'key_type' in _dict:
            args['key_type'] = _dict.get('key_type')
        if 'key_bits' in _dict:
            args['key_bits'] = _dict.get('key_bits')
        if 'key_usage' in _dict:
            args['key_usage'] = _dict.get('key_usage')
        if 'ext_key_usage' in _dict:
            args['ext_key_usage'] = _dict.get('ext_key_usage')
        if 'ext_key_usage_oids' in _dict:
            args['ext_key_usage_oids'] = _dict.get('ext_key_usage_oids')
        if 'use_csr_common_name' in _dict:
            args['use_csr_common_name'] = _dict.get('use_csr_common_name')
        if 'use_csr_sans' in _dict:
            args['use_csr_sans'] = _dict.get('use_csr_sans')
        if 'ou' in _dict:
            args['ou'] = _dict.get('ou')
        if 'organization' in _dict:
            args['organization'] = _dict.get('organization')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'locality' in _dict:
            args['locality'] = _dict.get('locality')
        if 'province' in _dict:
            args['province'] = _dict.get('province')
        if 'street_address' in _dict:
            args['street_address'] = _dict.get('street_address')
        if 'postal_code' in _dict:
            args['postal_code'] = _dict.get('postal_code')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'require_cn' in _dict:
            args['require_cn'] = _dict.get('require_cn')
        if 'policy_identifiers' in _dict:
            args['policy_identifiers'] = _dict.get('policy_identifiers')
        if 'basic_constraints_valid_for_non_ca' in _dict:
            args['basic_constraints_valid_for_non_ca'] = _dict.get('basic_constraints_valid_for_non_ca')
        if 'not_before_duration' in _dict:
            args['not_before_duration'] = _dict.get('not_before_duration')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateConfigurationTemplatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'certificate_authority') and self.certificate_authority is not None:
            _dict['certificate_authority'] = self.certificate_authority
        if hasattr(self, 'allowed_secret_groups') and self.allowed_secret_groups is not None:
            _dict['allowed_secret_groups'] = self.allowed_secret_groups
        if hasattr(self, 'max_ttl') and self.max_ttl is not None:
            _dict['max_ttl'] = self.max_ttl
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'allow_localhost') and self.allow_localhost is not None:
            _dict['allow_localhost'] = self.allow_localhost
        if hasattr(self, 'allowed_domains') and self.allowed_domains is not None:
            _dict['allowed_domains'] = self.allowed_domains
        if hasattr(self, 'allowed_domains_template') and self.allowed_domains_template is not None:
            _dict['allowed_domains_template'] = self.allowed_domains_template
        if hasattr(self, 'allow_bare_domains') and self.allow_bare_domains is not None:
            _dict['allow_bare_domains'] = self.allow_bare_domains
        if hasattr(self, 'allow_subdomains') and self.allow_subdomains is not None:
            _dict['allow_subdomains'] = self.allow_subdomains
        if hasattr(self, 'allow_glob_domains') and self.allow_glob_domains is not None:
            _dict['allow_glob_domains'] = self.allow_glob_domains
        if hasattr(self, 'allow_wildcard_certificates') and self.allow_wildcard_certificates is not None:
            _dict['allow_wildcard_certificates'] = self.allow_wildcard_certificates
        if hasattr(self, 'allow_any_name') and self.allow_any_name is not None:
            _dict['allow_any_name'] = self.allow_any_name
        if hasattr(self, 'enforce_hostnames') and self.enforce_hostnames is not None:
            _dict['enforce_hostnames'] = self.enforce_hostnames
        if hasattr(self, 'allow_ip_sans') and self.allow_ip_sans is not None:
            _dict['allow_ip_sans'] = self.allow_ip_sans
        if hasattr(self, 'allowed_uri_sans') and self.allowed_uri_sans is not None:
            _dict['allowed_uri_sans'] = self.allowed_uri_sans
        if hasattr(self, 'allowed_other_sans') and self.allowed_other_sans is not None:
            _dict['allowed_other_sans'] = self.allowed_other_sans
        if hasattr(self, 'server_flag') and self.server_flag is not None:
            _dict['server_flag'] = self.server_flag
        if hasattr(self, 'client_flag') and self.client_flag is not None:
            _dict['client_flag'] = self.client_flag
        if hasattr(self, 'code_signing_flag') and self.code_signing_flag is not None:
            _dict['code_signing_flag'] = self.code_signing_flag
        if hasattr(self, 'email_protection_flag') and self.email_protection_flag is not None:
            _dict['email_protection_flag'] = self.email_protection_flag
        if hasattr(self, 'key_type') and self.key_type is not None:
            _dict['key_type'] = self.key_type
        if hasattr(self, 'key_bits') and self.key_bits is not None:
            _dict['key_bits'] = self.key_bits
        if hasattr(self, 'key_usage') and self.key_usage is not None:
            _dict['key_usage'] = self.key_usage
        if hasattr(self, 'ext_key_usage') and self.ext_key_usage is not None:
            _dict['ext_key_usage'] = self.ext_key_usage
        if hasattr(self, 'ext_key_usage_oids') and self.ext_key_usage_oids is not None:
            _dict['ext_key_usage_oids'] = self.ext_key_usage_oids
        if hasattr(self, 'use_csr_common_name') and self.use_csr_common_name is not None:
            _dict['use_csr_common_name'] = self.use_csr_common_name
        if hasattr(self, 'use_csr_sans') and self.use_csr_sans is not None:
            _dict['use_csr_sans'] = self.use_csr_sans
        if hasattr(self, 'ou') and self.ou is not None:
            _dict['ou'] = self.ou
        if hasattr(self, 'organization') and self.organization is not None:
            _dict['organization'] = self.organization
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'locality') and self.locality is not None:
            _dict['locality'] = self.locality
        if hasattr(self, 'province') and self.province is not None:
            _dict['province'] = self.province
        if hasattr(self, 'street_address') and self.street_address is not None:
            _dict['street_address'] = self.street_address
        if hasattr(self, 'postal_code') and self.postal_code is not None:
            _dict['postal_code'] = self.postal_code
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'require_cn') and self.require_cn is not None:
            _dict['require_cn'] = self.require_cn
        if hasattr(self, 'policy_identifiers') and self.policy_identifiers is not None:
            _dict['policy_identifiers'] = self.policy_identifiers
        if hasattr(self, 'basic_constraints_valid_for_non_ca') and self.basic_constraints_valid_for_non_ca is not None:
            _dict['basic_constraints_valid_for_non_ca'] = self.basic_constraints_valid_for_non_ca
        if hasattr(self, 'not_before_duration') and self.not_before_duration is not None:
            _dict['not_before_duration'] = self.not_before_duration
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateConfigurationTemplatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateConfigurationTemplatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateConfigurationTemplatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class KeyTypeEnum(str, Enum):
        """
        The type of private key to generate.
        """

        RSA = 'rsa'
        EC = 'ec'



class PrivateCertificateMetadata(SecretMetadata):
    """
    Properties of the metadata of your private certificate.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str signing_algorithm: The identifier for the cryptographic algorithm that
          is used by the issuing certificate authority to sign a certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str certificate_authority: (optional) The intermediate certificate
          authority that signed this certificate.
    :attr str certificate_template: The name of the certificate template.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr str issuer: The distinguished name that identifies the entity that signed
          and issued the certificate.
    :attr str key_algorithm: (optional) The identifier for the cryptographic
          algorithm used to generate the public key that is associated with the
          certificate.
    :attr datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :attr int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    :attr datetime revocation_time_rfc3339: (optional) The date and time that the
          certificate was revoked. The date format follows `RFC 3339`.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        signing_algorithm: str,
        certificate_template: str,
        common_name: str,
        expiration_date: datetime,
        issuer: str,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        alt_names: List[str] = None,
        certificate_authority: str = None,
        key_algorithm: str = None,
        next_rotation_date: datetime = None,
        rotation: 'RotationPolicy' = None,
        revocation_time_seconds: int = None,
        revocation_time_rfc3339: datetime = None,
    ) -> None:
        """
        Initialize a PrivateCertificateMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str signing_algorithm: The identifier for the cryptographic
               algorithm that is used by the issuing certificate authority to sign a
               certificate.
        :param str certificate_template: The name of the certificate template.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str issuer: The distinguished name that identifies the entity that
               signed and issued the certificate.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.certificate_authority = certificate_authority
        self.certificate_template = certificate_template
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.next_rotation_date = next_rotation_date
        self.rotation = rotation
        self.serial_number = serial_number
        self.validity = validity
        self.revocation_time_seconds = revocation_time_seconds
        self.revocation_time_rfc3339 = revocation_time_rfc3339

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateMetadata':
        """Initialize a PrivateCertificateMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PrivateCertificateMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificateMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PrivateCertificateMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PrivateCertificateMetadata JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        else:
            raise ValueError('Required property \'signing_algorithm\' not present in PrivateCertificateMetadata JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'certificate_authority' in _dict:
            args['certificate_authority'] = _dict.get('certificate_authority')
        if 'certificate_template' in _dict:
            args['certificate_template'] = _dict.get('certificate_template')
        else:
            raise ValueError('Required property \'certificate_template\' not present in PrivateCertificateMetadata JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificateMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificateMetadata JSON')
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        else:
            raise ValueError('Required property \'issuer\' not present in PrivateCertificateMetadata JSON')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificateMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificateMetadata JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        if 'revocation_time_rfc3339' in _dict:
            args['revocation_time_rfc3339'] = string_to_datetime(_dict.get('revocation_time_rfc3339'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'certificate_authority') and getattr(self, 'certificate_authority') is not None:
            _dict['certificate_authority'] = getattr(self, 'certificate_authority')
        if hasattr(self, 'certificate_template') and self.certificate_template is not None:
            _dict['certificate_template'] = self.certificate_template
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and getattr(self, 'key_algorithm') is not None:
            _dict['key_algorithm'] = getattr(self, 'key_algorithm')
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        if hasattr(self, 'revocation_time_rfc3339') and getattr(self, 'revocation_time_rfc3339') is not None:
            _dict['revocation_time_rfc3339'] = datetime_to_string(getattr(self, 'revocation_time_rfc3339'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PrivateCertificateMetadataPatch(SecretMetadataPatch):
    """
    PrivateCertificateMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
        rotation: 'RotationPolicy' = None,
    ) -> None:
        """
        Initialize a PrivateCertificateMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateMetadataPatch':
        """Initialize a PrivateCertificateMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PrivateCertificatePrototype(SecretPrototype):
    """
    PrivateCertificatePrototype.

    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr str certificate_template: The name of the certificate template.
    :attr str common_name: The Common Name (CN) represents the server name that is
          protected by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str ip_sans: (optional) The IP Subject Alternative Names to define for the
          CA certificate, in a comma-delimited list.
    :attr str uri_sans: (optional) The URI Subject Alternative Names to define for
          the CA certificate, in a comma-delimited list.
    :attr List[str] other_sans: (optional) The custom Object Identifier (OID) or
          UTF8-string Subject Alternative Names to define for the CA certificate.
          The alternative names must match the values that are specified in the
          `allowed_other_sans` field in the associated certificate template. The format is
          the same as OpenSSL: `<oid>:<type>:<value>` where the current valid type is
          `UTF8`.
    :attr str csr: (optional) The certificate signing request.
    :attr str format: (optional) The format of the returned data.
    :attr str private_key_format: (optional) The format of the generated private
          key.
    :attr bool exclude_cn_from_sans: (optional) This parameter controls whether the
          common name is excluded from Subject Alternative Names (SANs).
          If the common name is set to `true`, it is not included in DNS, or email SANs if
          they apply. This field can be useful if the common name is a human-readable
          identifier, instead of a hostname or an email address.
    :attr str ttl: (optional) The time-to-live (TTL) to assign to a private
          certificate.
          The value can be supplied as a string representation of a duration in hours, for
          example '12h'. The value can't exceed the `max_ttl` that is defined in the
          associated certificate template.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        certificate_template: str,
        common_name: str,
        *,
        description: str = None,
        secret_group_id: str = None,
        labels: List[str] = None,
        alt_names: List[str] = None,
        ip_sans: str = None,
        uri_sans: str = None,
        other_sans: List[str] = None,
        csr: str = None,
        format: str = None,
        private_key_format: str = None,
        exclude_cn_from_sans: bool = None,
        ttl: str = None,
        rotation: 'RotationPolicy' = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a PrivateCertificatePrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str certificate_template: The name of the certificate template.
        :param str common_name: The Common Name (CN) represents the server name
               that is protected by the SSL certificate.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str ip_sans: (optional) The IP Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param str uri_sans: (optional) The URI Subject Alternative Names to define
               for the CA certificate, in a comma-delimited list.
        :param List[str] other_sans: (optional) The custom Object Identifier (OID)
               or UTF8-string Subject Alternative Names to define for the CA certificate.
               The alternative names must match the values that are specified in the
               `allowed_other_sans` field in the associated certificate template. The
               format is the same as OpenSSL: `<oid>:<type>:<value>` where the current
               valid type is `UTF8`.
        :param str csr: (optional) The certificate signing request.
        :param str format: (optional) The format of the returned data.
        :param str private_key_format: (optional) The format of the generated
               private key.
        :param bool exclude_cn_from_sans: (optional) This parameter controls
               whether the common name is excluded from Subject Alternative Names (SANs).
               If the common name is set to `true`, it is not included in DNS, or email
               SANs if they apply. This field can be useful if the common name is a
               human-readable identifier, instead of a hostname or an email address.
        :param str ttl: (optional) The time-to-live (TTL) to assign to a private
               certificate.
               The value can be supplied as a string representation of a duration in
               hours, for example '12h'. The value can't exceed the `max_ttl` that is
               defined in the associated certificate template.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.certificate_template = certificate_template
        self.common_name = common_name
        self.alt_names = alt_names
        self.ip_sans = ip_sans
        self.uri_sans = uri_sans
        self.other_sans = other_sans
        self.csr = csr
        self.format = format
        self.private_key_format = private_key_format
        self.exclude_cn_from_sans = exclude_cn_from_sans
        self.ttl = ttl
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificatePrototype':
        """Initialize a PrivateCertificatePrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PrivateCertificatePrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'certificate_template' in _dict:
            args['certificate_template'] = _dict.get('certificate_template')
        else:
            raise ValueError('Required property \'certificate_template\' not present in PrivateCertificatePrototype JSON')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PrivateCertificatePrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'ip_sans' in _dict:
            args['ip_sans'] = _dict.get('ip_sans')
        if 'uri_sans' in _dict:
            args['uri_sans'] = _dict.get('uri_sans')
        if 'other_sans' in _dict:
            args['other_sans'] = _dict.get('other_sans')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'private_key_format' in _dict:
            args['private_key_format'] = _dict.get('private_key_format')
        if 'exclude_cn_from_sans' in _dict:
            args['exclude_cn_from_sans'] = _dict.get('exclude_cn_from_sans')
        if 'ttl' in _dict:
            args['ttl'] = _dict.get('ttl')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'certificate_template') and self.certificate_template is not None:
            _dict['certificate_template'] = self.certificate_template
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'ip_sans') and self.ip_sans is not None:
            _dict['ip_sans'] = self.ip_sans
        if hasattr(self, 'uri_sans') and self.uri_sans is not None:
            _dict['uri_sans'] = self.uri_sans
        if hasattr(self, 'other_sans') and self.other_sans is not None:
            _dict['other_sans'] = self.other_sans
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'private_key_format') and self.private_key_format is not None:
            _dict['private_key_format'] = self.private_key_format
        if hasattr(self, 'exclude_cn_from_sans') and self.exclude_cn_from_sans is not None:
            _dict['exclude_cn_from_sans'] = self.exclude_cn_from_sans
        if hasattr(self, 'ttl') and self.ttl is not None:
            _dict['ttl'] = self.ttl
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class FormatEnum(str, Enum):
        """
        The format of the returned data.
        """

        PEM = 'pem'
        PEM_BUNDLE = 'pem_bundle'


    class PrivateKeyFormatEnum(str, Enum):
        """
        The format of the generated private key.
        """

        DER = 'der'
        PKCS8 = 'pkcs8'



class PrivateCertificateVersion(SecretVersion):
    """
    Your private certificate version.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    :attr str certificate: Your PEM-encoded certificate. The data must be formatted
          on a single line with embedded newline characters.
    :attr str private_key: The PEM-encoded private key that is associated with the
          certificate. The data must be formatted on a single line with embedded newline
          characters.
    :attr str issuing_ca: (optional) The PEM-encoded certificate of the certificate
          authority that signed and issued this certificate.
    :attr List[str] ca_chain: (optional) The chain of certificate authorities that
          are associated with the certificate.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        certificate: str,
        private_key: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        issuing_ca: str = None,
        ca_chain: List[str] = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param str certificate: Your PEM-encoded certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: The PEM-encoded private key that is associated with
               the certificate. The data must be formatted on a single line with embedded
               newline characters.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.private_key = private_key
        self.issuing_ca = issuing_ca
        self.ca_chain = ca_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersion':
        """Initialize a PrivateCertificateVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificateVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificateVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PrivateCertificateVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PrivateCertificateVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificateVersion JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificateVersion JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificateVersion JSON')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        else:
            raise ValueError('Required property \'certificate\' not present in PrivateCertificateVersion JSON')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        else:
            raise ValueError('Required property \'private_key\' not present in PrivateCertificateVersion JSON')
        if 'issuing_ca' in _dict:
            args['issuing_ca'] = _dict.get('issuing_ca')
        if 'ca_chain' in _dict:
            args['ca_chain'] = _dict.get('ca_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        if hasattr(self, 'issuing_ca') and getattr(self, 'issuing_ca') is not None:
            _dict['issuing_ca'] = getattr(self, 'issuing_ca')
        if hasattr(self, 'ca_chain') and getattr(self, 'ca_chain') is not None:
            _dict['ca_chain'] = getattr(self, 'ca_chain')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PrivateCertificateVersionActionRevoke(VersionAction):
    """
    The response body to specify the properties of the action to revoke the private
    certificate.

    :attr str action_type: The type of secret version action.
    :attr int revocation_time_seconds: (optional) The timestamp of the certificate
          revocation.
    """

    def __init__(
        self,
        action_type: str,
        *,
        revocation_time_seconds: int = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionActionRevoke object.

        :param str action_type: The type of secret version action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type
        self.revocation_time_seconds = revocation_time_seconds

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionActionRevoke':
        """Initialize a PrivateCertificateVersionActionRevoke object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateVersionActionRevoke JSON')
        if 'revocation_time_seconds' in _dict:
            args['revocation_time_seconds'] = _dict.get('revocation_time_seconds')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionActionRevoke object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        if hasattr(self, 'revocation_time_seconds') and getattr(self, 'revocation_time_seconds') is not None:
            _dict['revocation_time_seconds'] = getattr(self, 'revocation_time_seconds')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionActionRevoke object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionActionRevoke') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionActionRevoke') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret version action.
        """

        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateVersionActionRevokePrototype(SecretVersionActionPrototype):
    """
    The request body to specify the properties of the action to revoke the private
    certificate.

    :attr str action_type: The type of secret version action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionActionRevokePrototype object.

        :param str action_type: The type of secret version action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionActionRevokePrototype':
        """Initialize a PrivateCertificateVersionActionRevokePrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PrivateCertificateVersionActionRevokePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionActionRevokePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionActionRevokePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionActionRevokePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionActionRevokePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret version action.
        """

        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PrivateCertificateVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your private certificate.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: The date when the secret material expires. The
          date format follows the `RFC 3339` format. Supported secret types: Arbitrary,
          username_password.
    :attr str serial_number: The unique serial number that was assigned to a
          certificate by the issuing certificate authority.
    :attr CertificateValidity validity: The date and time that the certificate
          validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        expiration_date: datetime,
        serial_number: str,
        validity: 'CertificateValidity',
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param datetime expiration_date: The date when the secret material expires.
               The date format follows the `RFC 3339` format. Supported secret types:
               Arbitrary, username_password.
        :param str serial_number: The unique serial number that was assigned to a
               certificate by the issuing certificate authority.
        :param CertificateValidity validity: The date and time that the certificate
               validity period begins and ends.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionMetadata':
        """Initialize a PrivateCertificateVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PrivateCertificateVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PrivateCertificateVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PrivateCertificateVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PrivateCertificateVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PrivateCertificateVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PrivateCertificateVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PrivateCertificateVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        else:
            raise ValueError('Required property \'expiration_date\' not present in PrivateCertificateVersionMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        else:
            raise ValueError('Required property \'serial_number\' not present in PrivateCertificateVersionMetadata JSON')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        else:
            raise ValueError('Required property \'validity\' not present in PrivateCertificateVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PrivateCertificateVersionPrototype(SecretVersionPrototype):
    """
    PrivateCertificateVersionPrototype.

    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str csr: (optional) The certificate signing request.
    """

    def __init__(
        self,
        *,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
        csr: str = None,
    ) -> None:
        """
        Initialize a PrivateCertificateVersionPrototype object.

        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param str csr: (optional) The certificate signing request.
        """
        # pylint: disable=super-init-not-called
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata
        self.csr = csr

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCertificateVersionPrototype':
        """Initialize a PrivateCertificateVersionPrototype object from a json dictionary."""
        args = {}
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'csr' in _dict:
            args['csr'] = _dict.get('csr')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCertificateVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'csr') and self.csr is not None:
            _dict['csr'] = self.csr
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCertificateVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificate(Secret):
    """
    Your public certificate.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str signing_algorithm: (optional) The identifier for the cryptographic
          algorithm that is used by the issuing certificate authority to sign a
          certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str common_name: The Common Name (CN) represents the server name protected
          by the SSL certificate.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr CertificateIssuanceInfo issuance_info: (optional) Issuance information
          that is associated with your certificate.
    :attr str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :attr str key_algorithm: The identifier for the cryptographic algorithm that is
          used to generate the public key that is associated with the certificate.
          The algorithm that you select determines the encryption algorithm (`RSA` or
          `ECDSA`) and key size to be used to generate keys and sign certificates. For
          longer living certificates, it is recommended to use longer keys to provide more
          encryption protection. Allowed values:  `RSA2048`, `RSA4096`, `ECDSA256`, and
          `ECDSA384`.
    :attr str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :attr CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    :attr RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :attr bool bundle_certs: (optional) Indicates whether the issued certificate is
          bundled with intermediate certificates.
    :attr str ca: (optional) The name of the certificate authority configuration.
    :attr str dns: (optional) The name of the DNS provider configuration.
    :attr str certificate: (optional) Your PEM-encoded certificate. The data must be
          formatted on a single line with embedded newline characters.
    :attr str intermediate: (optional) The PEM-encoded intermediate certificate that
          is associated with the root certificate. The data must be formatted on a single
          line with embedded newline characters.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        common_name: str,
        key_algorithm: str,
        rotation: 'RotationPolicy',
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        signing_algorithm: str = None,
        alt_names: List[str] = None,
        expiration_date: datetime = None,
        issuance_info: 'CertificateIssuanceInfo' = None,
        issuer: str = None,
        serial_number: str = None,
        validity: 'CertificateValidity' = None,
        bundle_certs: bool = None,
        ca: str = None,
        dns: str = None,
        certificate: str = None,
        intermediate: str = None,
        private_key: str = None,
    ) -> None:
        """
        Initialize a PublicCertificate object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str common_name: The Common Name (CN) represents the server name
               protected by the SSL certificate.
        :param str key_algorithm: The identifier for the cryptographic algorithm
               that is used to generate the public key that is associated with the
               certificate.
               The algorithm that you select determines the encryption algorithm (`RSA` or
               `ECDSA`) and key size to be used to generate keys and sign certificates.
               For longer living certificates, it is recommended to use longer keys to
               provide more encryption protection. Allowed values:  `RSA2048`, `RSA4096`,
               `ECDSA256`, and `ECDSA384`.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str signing_algorithm: (optional) The identifier for the
               cryptographic algorithm that is used by the issuing certificate authority
               to sign a certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        :param str certificate: (optional) Your PEM-encoded certificate. The data
               must be formatted on a single line with embedded newline characters.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuance_info = issuance_info
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.serial_number = serial_number
        self.validity = validity
        self.rotation = rotation
        self.bundle_certs = bundle_certs
        self.ca = ca
        self.dns = dns
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificate':
        """Initialize a PublicCertificate object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificate JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificate JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PublicCertificate JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificate JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificate JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificate JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificate JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PublicCertificate JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PublicCertificate JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuance_info' in _dict:
            args['issuance_info'] = CertificateIssuanceInfo.from_dict(_dict.get('issuance_info'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        else:
            raise ValueError('Required property \'key_algorithm\' not present in PublicCertificate JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in PublicCertificate JSON')
        if 'bundle_certs' in _dict:
            args['bundle_certs'] = _dict.get('bundle_certs')
        if 'ca' in _dict:
            args['ca'] = _dict.get('ca')
        if 'dns' in _dict:
            args['dns'] = _dict.get('dns')
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuance_info') and getattr(self, 'issuance_info') is not None:
            if isinstance(getattr(self, 'issuance_info'), dict):
                _dict['issuance_info'] = getattr(self, 'issuance_info')
            else:
                _dict['issuance_info'] = getattr(self, 'issuance_info').to_dict()
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and self.key_algorithm is not None:
            _dict['key_algorithm'] = self.key_algorithm
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'bundle_certs') and getattr(self, 'bundle_certs') is not None:
            _dict['bundle_certs'] = getattr(self, 'bundle_certs')
        if hasattr(self, 'ca') and getattr(self, 'ca') is not None:
            _dict['ca'] = getattr(self, 'ca')
        if hasattr(self, 'dns') and getattr(self, 'dns') is not None:
            _dict['dns'] = getattr(self, 'dns')
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PublicCertificateActionValidateManualDNS(SecretAction):
    """
    The response body of the action to validate manual DNS challenges for the public
    certificate.

    :attr str action_type: The type of secret action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PublicCertificateActionValidateManualDNS object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateActionValidateManualDNS':
        """Initialize a PublicCertificateActionValidateManualDNS object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PublicCertificateActionValidateManualDNS JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateActionValidateManualDNS object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateActionValidateManualDNS object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateActionValidateManualDNS') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateActionValidateManualDNS') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PublicCertificateActionValidateManualDNSPrototype(SecretActionPrototype):
    """
    The request body to specify the properties of the action to validate manual DNS
    challenges for the public certificate.

    :attr str action_type: The type of secret action.
    """

    def __init__(
        self,
        action_type: str,
    ) -> None:
        """
        Initialize a PublicCertificateActionValidateManualDNSPrototype object.

        :param str action_type: The type of secret action.
        """
        # pylint: disable=super-init-not-called
        self.action_type = action_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateActionValidateManualDNSPrototype':
        """Initialize a PublicCertificateActionValidateManualDNSPrototype object from a json dictionary."""
        args = {}
        if 'action_type' in _dict:
            args['action_type'] = _dict.get('action_type')
        else:
            raise ValueError('Required property \'action_type\' not present in PublicCertificateActionValidateManualDNSPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateActionValidateManualDNSPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_type') and self.action_type is not None:
            _dict['action_type'] = self.action_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateActionValidateManualDNSPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateActionValidateManualDNSPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateActionValidateManualDNSPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ActionTypeEnum(str, Enum):
        """
        The type of secret action.
        """

        PUBLIC_CERT_ACTION_VALIDATE_DNS_CHALLENGE = 'public_cert_action_validate_dns_challenge'
        PRIVATE_CERT_ACTION_REVOKE_CERTIFICATE = 'private_cert_action_revoke_certificate'



class PublicCertificateConfigurationCALetsEncrypt(Configuration):
    """
    Properties that describe a Let's Encrypt CA configuration.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :attr str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    :attr str lets_encrypt_private_key: The PEM-encoded private key of your Let's
          Encrypt account. The data must be formatted on a single line with embedded
          newline characters.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        lets_encrypt_environment: str,
        lets_encrypt_private_key: str,
        *,
        lets_encrypt_preferred_chain: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncrypt object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_private_key: The PEM-encoded private key of your
               Let's Encrypt account. The data must be formatted on a single line with
               embedded newline characters.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain
        self.lets_encrypt_private_key = lets_encrypt_private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncrypt':
        """Initialize a PublicCertificateConfigurationCALetsEncrypt object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        if 'lets_encrypt_private_key' in _dict:
            args['lets_encrypt_private_key'] = _dict.get('lets_encrypt_private_key')
        else:
            raise ValueError('Required property \'lets_encrypt_private_key\' not present in PublicCertificateConfigurationCALetsEncrypt JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncrypt object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        if hasattr(self, 'lets_encrypt_private_key') and self.lets_encrypt_private_key is not None:
            _dict['lets_encrypt_private_key'] = self.lets_encrypt_private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncrypt object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncrypt') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncrypt') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationCALetsEncryptMetadata(ConfigurationMetadata):
    """
    Your Let's Encrypt CA metadata properties.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :attr str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        lets_encrypt_environment: str,
        *,
        lets_encrypt_preferred_chain: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncryptMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncryptMetadata':
        """Initialize a PublicCertificateConfigurationCALetsEncryptMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncryptMetadata JSON')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncryptMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncryptMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncryptMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncryptMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationCALetsEncryptPatch(ConfigurationPatch):
    """
    The configuration update of the Let's Encrypt Certificate Authority.

    :attr str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :attr str lets_encrypt_private_key: (optional) The PEM-encoded private key of
          your Let's Encrypt account. The data must be formatted on a single line with
          embedded newline characters.
    :attr str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    """

    def __init__(
        self,
        lets_encrypt_environment: str,
        *,
        lets_encrypt_private_key: str = None,
        lets_encrypt_preferred_chain: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncryptPatch object.

        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_private_key: (optional) The PEM-encoded private key
               of your Let's Encrypt account. The data must be formatted on a single line
               with embedded newline characters.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_private_key = lets_encrypt_private_key
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncryptPatch':
        """Initialize a PublicCertificateConfigurationCALetsEncryptPatch object from a json dictionary."""
        args = {}
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncryptPatch JSON')
        if 'lets_encrypt_private_key' in _dict:
            args['lets_encrypt_private_key'] = _dict.get('lets_encrypt_private_key')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncryptPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_private_key') and self.lets_encrypt_private_key is not None:
            _dict['lets_encrypt_private_key'] = self.lets_encrypt_private_key
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncryptPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncryptPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncryptPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationCALetsEncryptPrototype(ConfigurationPrototype):
    """
    The properties of the Let's Encrypt CA configuration.

    :attr str config_type: The configuration type.
    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str lets_encrypt_environment: The configuration of the Let's Encrypt CA
          environment.
    :attr str lets_encrypt_private_key: The PEM-encoded private key of your Let's
          Encrypt account. The data must be formatted on a single line with embedded
          newline characters.
    :attr str lets_encrypt_preferred_chain: (optional) If the CA offers multiple
          certificate chains, prefer the chain with an issuer matching this Subject Common
          Name. If no match, the default offered chain will be used.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        lets_encrypt_environment: str,
        lets_encrypt_private_key: str,
        *,
        lets_encrypt_preferred_chain: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationCALetsEncryptPrototype object.

        :param str config_type: The configuration type.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str lets_encrypt_environment: The configuration of the Let's Encrypt
               CA environment.
        :param str lets_encrypt_private_key: The PEM-encoded private key of your
               Let's Encrypt account. The data must be formatted on a single line with
               embedded newline characters.
        :param str lets_encrypt_preferred_chain: (optional) If the CA offers
               multiple certificate chains, prefer the chain with an issuer matching this
               Subject Common Name. If no match, the default offered chain will be used.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.lets_encrypt_environment = lets_encrypt_environment
        self.lets_encrypt_private_key = lets_encrypt_private_key
        self.lets_encrypt_preferred_chain = lets_encrypt_preferred_chain

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationCALetsEncryptPrototype':
        """Initialize a PublicCertificateConfigurationCALetsEncryptPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'lets_encrypt_environment' in _dict:
            args['lets_encrypt_environment'] = _dict.get('lets_encrypt_environment')
        else:
            raise ValueError('Required property \'lets_encrypt_environment\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'lets_encrypt_private_key' in _dict:
            args['lets_encrypt_private_key'] = _dict.get('lets_encrypt_private_key')
        else:
            raise ValueError('Required property \'lets_encrypt_private_key\' not present in PublicCertificateConfigurationCALetsEncryptPrototype JSON')
        if 'lets_encrypt_preferred_chain' in _dict:
            args['lets_encrypt_preferred_chain'] = _dict.get('lets_encrypt_preferred_chain')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationCALetsEncryptPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'lets_encrypt_environment') and self.lets_encrypt_environment is not None:
            _dict['lets_encrypt_environment'] = self.lets_encrypt_environment
        if hasattr(self, 'lets_encrypt_private_key') and self.lets_encrypt_private_key is not None:
            _dict['lets_encrypt_private_key'] = self.lets_encrypt_private_key
        if hasattr(self, 'lets_encrypt_preferred_chain') and self.lets_encrypt_preferred_chain is not None:
            _dict['lets_encrypt_preferred_chain'] = self.lets_encrypt_preferred_chain
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationCALetsEncryptPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationCALetsEncryptPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationCALetsEncryptPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class LetsEncryptEnvironmentEnum(str, Enum):
        """
        The configuration of the Let's Encrypt CA environment.
        """

        PRODUCTION = 'production'
        STAGING = 'staging'



class PublicCertificateConfigurationDNSClassicInfrastructure(Configuration):
    """
    Properties that describe a Classic Infrastructure DNS configuration.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str classic_infrastructure_username: The username that is associated with
          your classic infrastructure account.
          In most cases, your classic infrastructure username is your
          `<account_id>_<email_address>`. For more information, see the
          [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    :attr str classic_infrastructure_password: Your classic infrastructure API key.
          For information about viewing and accessing your classic infrastructure API key,
          see the [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        classic_infrastructure_username: str,
        classic_infrastructure_password: str,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructure object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str classic_infrastructure_username: The username that is associated
               with your classic infrastructure account.
               In most cases, your classic infrastructure username is your
               `<account_id>_<email_address>`. For more information, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        :param str classic_infrastructure_password: Your classic infrastructure API
               key.
               For information about viewing and accessing your classic infrastructure API
               key, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.classic_infrastructure_username = classic_infrastructure_username
        self.classic_infrastructure_password = classic_infrastructure_password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructure':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructure object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'classic_infrastructure_username' in _dict:
            args['classic_infrastructure_username'] = _dict.get('classic_infrastructure_username')
        else:
            raise ValueError('Required property \'classic_infrastructure_username\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        if 'classic_infrastructure_password' in _dict:
            args['classic_infrastructure_password'] = _dict.get('classic_infrastructure_password')
        else:
            raise ValueError('Required property \'classic_infrastructure_password\' not present in PublicCertificateConfigurationDNSClassicInfrastructure JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructure object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'classic_infrastructure_username') and self.classic_infrastructure_username is not None:
            _dict['classic_infrastructure_username'] = self.classic_infrastructure_username
        if hasattr(self, 'classic_infrastructure_password') and self.classic_infrastructure_password is not None:
            _dict['classic_infrastructure_password'] = self.classic_infrastructure_password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructure object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructure') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructure') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class PublicCertificateConfigurationDNSClassicInfrastructureMetadata(ConfigurationMetadata):
    """
    Your Classic Infrastructure DNS metadata properties.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructureMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructureMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSClassicInfrastructureMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructureMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructureMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructureMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class PublicCertificateConfigurationDNSClassicInfrastructurePatch(ConfigurationPatch):
    """
    Properties that describe the configuration update of an IBM Cloud classic
    infrastructure (SoftLayer).

    :attr str classic_infrastructure_username: (optional) The username that is
          associated with your classic infrastructure account.
          In most cases, your classic infrastructure username is your
          `<account_id>_<email_address>`. For more information, see the
          [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    :attr str classic_infrastructure_password: (optional) Your classic
          infrastructure API key.
          For information about viewing and accessing your classic infrastructure API key,
          see the [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    """

    def __init__(
        self,
        *,
        classic_infrastructure_username: str = None,
        classic_infrastructure_password: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePatch object.

        :param str classic_infrastructure_username: (optional) The username that is
               associated with your classic infrastructure account.
               In most cases, your classic infrastructure username is your
               `<account_id>_<email_address>`. For more information, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        :param str classic_infrastructure_password: (optional) Your classic
               infrastructure API key.
               For information about viewing and accessing your classic infrastructure API
               key, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        """
        # pylint: disable=super-init-not-called
        self.classic_infrastructure_username = classic_infrastructure_username
        self.classic_infrastructure_password = classic_infrastructure_password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructurePatch':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePatch object from a json dictionary."""
        args = {}
        if 'classic_infrastructure_username' in _dict:
            args['classic_infrastructure_username'] = _dict.get('classic_infrastructure_username')
        if 'classic_infrastructure_password' in _dict:
            args['classic_infrastructure_password'] = _dict.get('classic_infrastructure_password')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'classic_infrastructure_username') and self.classic_infrastructure_username is not None:
            _dict['classic_infrastructure_username'] = self.classic_infrastructure_username
        if hasattr(self, 'classic_infrastructure_password') and self.classic_infrastructure_password is not None:
            _dict['classic_infrastructure_password'] = self.classic_infrastructure_password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructurePatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificateConfigurationDNSClassicInfrastructurePrototype(ConfigurationPrototype):
    """
    PublicCertificateConfigurationDNSClassicInfrastructurePrototype.

    :attr str config_type: The configuration type.
    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str classic_infrastructure_username: The username that is associated with
          your classic infrastructure account.
          In most cases, your classic infrastructure username is your
          `<account_id>_<email_address>`. For more information, see the
          [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    :attr str classic_infrastructure_password: Your classic infrastructure API key.
          For information about viewing and accessing your classic infrastructure API key,
          see the [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        classic_infrastructure_username: str,
        classic_infrastructure_password: str,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePrototype object.

        :param str config_type: The configuration type.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str classic_infrastructure_username: The username that is associated
               with your classic infrastructure account.
               In most cases, your classic infrastructure username is your
               `<account_id>_<email_address>`. For more information, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        :param str classic_infrastructure_password: Your classic infrastructure API
               key.
               For information about viewing and accessing your classic infrastructure API
               key, see the
               [docs](https://cloud.ibm.com/docs/account?topic=account-classic_keys).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.classic_infrastructure_username = classic_infrastructure_username
        self.classic_infrastructure_password = classic_infrastructure_password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype':
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        if 'classic_infrastructure_username' in _dict:
            args['classic_infrastructure_username'] = _dict.get('classic_infrastructure_username')
        else:
            raise ValueError('Required property \'classic_infrastructure_username\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        if 'classic_infrastructure_password' in _dict:
            args['classic_infrastructure_password'] = _dict.get('classic_infrastructure_password')
        else:
            raise ValueError('Required property \'classic_infrastructure_password\' not present in PublicCertificateConfigurationDNSClassicInfrastructurePrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSClassicInfrastructurePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'classic_infrastructure_username') and self.classic_infrastructure_username is not None:
            _dict['classic_infrastructure_username'] = self.classic_infrastructure_username
        if hasattr(self, 'classic_infrastructure_password') and self.classic_infrastructure_password is not None:
            _dict['classic_infrastructure_password'] = self.classic_infrastructure_password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSClassicInfrastructurePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSClassicInfrastructurePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'



class PublicCertificateConfigurationDNSCloudInternetServices(Configuration):
    """
    Properties that describe a Cloud Internet Services DNS configuration.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr str cloud_internet_services_apikey: (optional) An IBM Cloud API key that
          can to list domains in your Cloud Internet Services instance.
          To grant Secrets Manager the ability to view the Cloud Internet Services
          instance and all of its domains, the API key must be assigned the Reader service
          role on Internet Services (`internet-svcs`).
          If you need to manage specific domains, you can assign the Manager role. For
          production environments, it is recommended that you assign the Reader access
          role, and then use the
          [IAM Policy Management
          API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
          control specific domains. For more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
    :attr str cloud_internet_services_crn: A CRN that uniquely identifies an IBM
          Cloud resource.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
        cloud_internet_services_crn: str,
        *,
        cloud_internet_services_apikey: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServices object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param str cloud_internet_services_crn: A CRN that uniquely identifies an
               IBM Cloud resource.
        :param str cloud_internet_services_apikey: (optional) An IBM Cloud API key
               that can to list domains in your Cloud Internet Services instance.
               To grant Secrets Manager the ability to view the Cloud Internet Services
               instance and all of its domains, the API key must be assigned the Reader
               service role on Internet Services (`internet-svcs`).
               If you need to manage specific domains, you can assign the Manager role.
               For production environments, it is recommended that you assign the Reader
               access role, and then use the
               [IAM Policy Management
               API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
               control specific domains. For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at
        self.cloud_internet_services_apikey = cloud_internet_services_apikey
        self.cloud_internet_services_crn = cloud_internet_services_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServices':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServices object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        if 'cloud_internet_services_apikey' in _dict:
            args['cloud_internet_services_apikey'] = _dict.get('cloud_internet_services_apikey')
        if 'cloud_internet_services_crn' in _dict:
            args['cloud_internet_services_crn'] = _dict.get('cloud_internet_services_crn')
        else:
            raise ValueError('Required property \'cloud_internet_services_crn\' not present in PublicCertificateConfigurationDNSCloudInternetServices JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServices object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'cloud_internet_services_apikey') and self.cloud_internet_services_apikey is not None:
            _dict['cloud_internet_services_apikey'] = self.cloud_internet_services_apikey
        if hasattr(self, 'cloud_internet_services_crn') and self.cloud_internet_services_crn is not None:
            _dict['cloud_internet_services_crn'] = self.cloud_internet_services_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServices object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServices') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServices') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class PublicCertificateConfigurationDNSCloudInternetServicesMetadata(ConfigurationMetadata):
    """
    Your Cloud Internet Services DNS metadata properties.

    :attr str config_type: The configuration type.
    :attr str name: The unique name of your configuration.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        secret_type: str,
        created_by: str,
        created_at: datetime,
        updated_at: datetime,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServicesMetadata object.

        :param str config_type: The configuration type.
        :param str name: The unique name of your configuration.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.secret_type = secret_type
        self.created_by = created_by
        self.created_at = created_at
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesMetadata object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateConfigurationDNSCloudInternetServicesMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServicesMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'


    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class PublicCertificateConfigurationDNSCloudInternetServicesPatch(ConfigurationPatch):
    """
    The configuration update of the Cloud Internet Services DNS.

    :attr str cloud_internet_services_apikey: An IBM Cloud API key that can to list
          domains in your Cloud Internet Services instance.
          To grant Secrets Manager the ability to view the Cloud Internet Services
          instance and all of its domains, the API key must be assigned the Reader service
          role on Internet Services (`internet-svcs`).
          If you need to manage specific domains, you can assign the Manager role. For
          production environments, it is recommended that you assign the Reader access
          role, and then use the
          [IAM Policy Management
          API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
          control specific domains. For more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
    :attr str cloud_internet_services_crn: (optional) A CRN that uniquely identifies
          an IBM Cloud resource.
    """

    def __init__(
        self,
        cloud_internet_services_apikey: str,
        *,
        cloud_internet_services_crn: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPatch object.

        :param str cloud_internet_services_apikey: An IBM Cloud API key that can to
               list domains in your Cloud Internet Services instance.
               To grant Secrets Manager the ability to view the Cloud Internet Services
               instance and all of its domains, the API key must be assigned the Reader
               service role on Internet Services (`internet-svcs`).
               If you need to manage specific domains, you can assign the Manager role.
               For production environments, it is recommended that you assign the Reader
               access role, and then use the
               [IAM Policy Management
               API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
               control specific domains. For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
        :param str cloud_internet_services_crn: (optional) A CRN that uniquely
               identifies an IBM Cloud resource.
        """
        # pylint: disable=super-init-not-called
        self.cloud_internet_services_apikey = cloud_internet_services_apikey
        self.cloud_internet_services_crn = cloud_internet_services_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServicesPatch':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPatch object from a json dictionary."""
        args = {}
        if 'cloud_internet_services_apikey' in _dict:
            args['cloud_internet_services_apikey'] = _dict.get('cloud_internet_services_apikey')
        else:
            raise ValueError('Required property \'cloud_internet_services_apikey\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPatch JSON')
        if 'cloud_internet_services_crn' in _dict:
            args['cloud_internet_services_crn'] = _dict.get('cloud_internet_services_crn')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'cloud_internet_services_apikey') and self.cloud_internet_services_apikey is not None:
            _dict['cloud_internet_services_apikey'] = self.cloud_internet_services_apikey
        if hasattr(self, 'cloud_internet_services_crn') and self.cloud_internet_services_crn is not None:
            _dict['cloud_internet_services_crn'] = self.cloud_internet_services_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServicesPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificateConfigurationDNSCloudInternetServicesPrototype(ConfigurationPrototype):
    """
    Specify the properties for Cloud Internet Services DNS configuration.

    :attr str config_type: The configuration type.
    :attr str name: A human-readable unique name to assign to your configuration.
          To protect your privacy, do not use personal data, such as your name or
          location, as an name for your secret.
    :attr str cloud_internet_services_apikey: (optional) An IBM Cloud API key that
          can to list domains in your Cloud Internet Services instance.
          To grant Secrets Manager the ability to view the Cloud Internet Services
          instance and all of its domains, the API key must be assigned the Reader service
          role on Internet Services (`internet-svcs`).
          If you need to manage specific domains, you can assign the Manager role. For
          production environments, it is recommended that you assign the Reader access
          role, and then use the
          [IAM Policy Management
          API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
          control specific domains. For more information, see the
          [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
    :attr str cloud_internet_services_crn: A CRN that uniquely identifies an IBM
          Cloud resource.
    """

    def __init__(
        self,
        config_type: str,
        name: str,
        cloud_internet_services_crn: str,
        *,
        cloud_internet_services_apikey: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPrototype object.

        :param str config_type: The configuration type.
        :param str name: A human-readable unique name to assign to your
               configuration.
               To protect your privacy, do not use personal data, such as your name or
               location, as an name for your secret.
        :param str cloud_internet_services_crn: A CRN that uniquely identifies an
               IBM Cloud resource.
        :param str cloud_internet_services_apikey: (optional) An IBM Cloud API key
               that can to list domains in your Cloud Internet Services instance.
               To grant Secrets Manager the ability to view the Cloud Internet Services
               instance and all of its domains, the API key must be assigned the Reader
               service role on Internet Services (`internet-svcs`).
               If you need to manage specific domains, you can assign the Manager role.
               For production environments, it is recommended that you assign the Reader
               access role, and then use the
               [IAM Policy Management
               API](https://cloud.ibm.com/apidocs/iam-policy-management#create-policy) to
               control specific domains. For more information, see the
               [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-prepare-order-certificates#authorize-specific-domains).
        """
        # pylint: disable=super-init-not-called
        self.config_type = config_type
        self.name = name
        self.cloud_internet_services_apikey = cloud_internet_services_apikey
        self.cloud_internet_services_crn = cloud_internet_services_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype':
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPrototype object from a json dictionary."""
        args = {}
        if 'config_type' in _dict:
            args['config_type'] = _dict.get('config_type')
        else:
            raise ValueError('Required property \'config_type\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPrototype JSON')
        if 'cloud_internet_services_apikey' in _dict:
            args['cloud_internet_services_apikey'] = _dict.get('cloud_internet_services_apikey')
        if 'cloud_internet_services_crn' in _dict:
            args['cloud_internet_services_crn'] = _dict.get('cloud_internet_services_crn')
        else:
            raise ValueError('Required property \'cloud_internet_services_crn\' not present in PublicCertificateConfigurationDNSCloudInternetServicesPrototype JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateConfigurationDNSCloudInternetServicesPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'config_type') and self.config_type is not None:
            _dict['config_type'] = self.config_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'cloud_internet_services_apikey') and self.cloud_internet_services_apikey is not None:
            _dict['cloud_internet_services_apikey'] = self.cloud_internet_services_apikey
        if hasattr(self, 'cloud_internet_services_crn') and self.cloud_internet_services_crn is not None:
            _dict['cloud_internet_services_crn'] = self.cloud_internet_services_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateConfigurationDNSCloudInternetServicesPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateConfigurationDNSCloudInternetServicesPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ConfigTypeEnum(str, Enum):
        """
        The configuration type.
        """

        PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT = 'public_cert_configuration_ca_lets_encrypt'
        PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE = 'public_cert_configuration_dns_classic_infrastructure'
        PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES = 'public_cert_configuration_dns_cloud_internet_services'
        IAM_CREDENTIALS_CONFIGURATION = 'iam_credentials_configuration'
        PRIVATE_CERT_CONFIGURATION_ROOT_CA = 'private_cert_configuration_root_ca'
        PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA = 'private_cert_configuration_intermediate_ca'
        PRIVATE_CERT_CONFIGURATION_TEMPLATE = 'private_cert_configuration_template'



class PublicCertificateMetadata(SecretMetadata):
    """
    Properties of the metadata of your public certificate.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr str signing_algorithm: (optional) The identifier for the cryptographic
          algorithm that is used by the issuing certificate authority to sign a
          certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str common_name: The Common Name (CN) represents the server name protected
          by the SSL certificate.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr CertificateIssuanceInfo issuance_info: (optional) Issuance information
          that is associated with your certificate.
    :attr str issuer: (optional) The distinguished name that identifies the entity
          that signed and issued the certificate.
    :attr str key_algorithm: The identifier for the cryptographic algorithm that is
          used to generate the public key that is associated with the certificate.
          The algorithm that you select determines the encryption algorithm (`RSA` or
          `ECDSA`) and key size to be used to generate keys and sign certificates. For
          longer living certificates, it is recommended to use longer keys to provide more
          encryption protection. Allowed values:  `RSA2048`, `RSA4096`, `ECDSA256`, and
          `ECDSA384`.
    :attr str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :attr CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    :attr RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :attr bool bundle_certs: (optional) Indicates whether the issued certificate is
          bundled with intermediate certificates.
    :attr str ca: (optional) The name of the certificate authority configuration.
    :attr str dns: (optional) The name of the DNS provider configuration.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        common_name: str,
        key_algorithm: str,
        rotation: 'RotationPolicy',
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        signing_algorithm: str = None,
        alt_names: List[str] = None,
        expiration_date: datetime = None,
        issuance_info: 'CertificateIssuanceInfo' = None,
        issuer: str = None,
        serial_number: str = None,
        validity: 'CertificateValidity' = None,
        bundle_certs: bool = None,
        ca: str = None,
        dns: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param str common_name: The Common Name (CN) represents the server name
               protected by the SSL certificate.
        :param str key_algorithm: The identifier for the cryptographic algorithm
               that is used to generate the public key that is associated with the
               certificate.
               The algorithm that you select determines the encryption algorithm (`RSA` or
               `ECDSA`) and key size to be used to generate keys and sign certificates.
               For longer living certificates, it is recommended to use longer keys to
               provide more encryption protection. Allowed values:  `RSA2048`, `RSA4096`,
               `ECDSA256`, and `ECDSA384`.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param str signing_algorithm: (optional) The identifier for the
               cryptographic algorithm that is used by the issuing certificate authority
               to sign a certificate.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str issuer: (optional) The distinguished name that identifies the
               entity that signed and issued the certificate.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.signing_algorithm = signing_algorithm
        self.alt_names = alt_names
        self.common_name = common_name
        self.expiration_date = expiration_date
        self.issuance_info = issuance_info
        self.issuer = issuer
        self.key_algorithm = key_algorithm
        self.serial_number = serial_number
        self.validity = validity
        self.rotation = rotation
        self.bundle_certs = bundle_certs
        self.ca = ca
        self.dns = dns

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateMetadata':
        """Initialize a PublicCertificateMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in PublicCertificateMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificateMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificateMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in PublicCertificateMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in PublicCertificateMetadata JSON')
        if 'signing_algorithm' in _dict:
            args['signing_algorithm'] = _dict.get('signing_algorithm')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PublicCertificateMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'issuance_info' in _dict:
            args['issuance_info'] = CertificateIssuanceInfo.from_dict(_dict.get('issuance_info'))
        if 'issuer' in _dict:
            args['issuer'] = _dict.get('issuer')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        else:
            raise ValueError('Required property \'key_algorithm\' not present in PublicCertificateMetadata JSON')
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in PublicCertificateMetadata JSON')
        if 'bundle_certs' in _dict:
            args['bundle_certs'] = _dict.get('bundle_certs')
        if 'ca' in _dict:
            args['ca'] = _dict.get('ca')
        if 'dns' in _dict:
            args['dns'] = _dict.get('dns')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'signing_algorithm') and self.signing_algorithm is not None:
            _dict['signing_algorithm'] = self.signing_algorithm
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'issuance_info') and getattr(self, 'issuance_info') is not None:
            if isinstance(getattr(self, 'issuance_info'), dict):
                _dict['issuance_info'] = getattr(self, 'issuance_info')
            else:
                _dict['issuance_info'] = getattr(self, 'issuance_info').to_dict()
        if hasattr(self, 'issuer') and self.issuer is not None:
            _dict['issuer'] = self.issuer
        if hasattr(self, 'key_algorithm') and self.key_algorithm is not None:
            _dict['key_algorithm'] = self.key_algorithm
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'bundle_certs') and getattr(self, 'bundle_certs') is not None:
            _dict['bundle_certs'] = getattr(self, 'bundle_certs')
        if hasattr(self, 'ca') and getattr(self, 'ca') is not None:
            _dict['ca'] = getattr(self, 'ca')
        if hasattr(self, 'dns') and getattr(self, 'dns') is not None:
            _dict['dns'] = getattr(self, 'dns')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class PublicCertificateMetadataPatch(SecretMetadataPatch):
    """
    PublicCertificateMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
        rotation: 'RotationPolicy' = None,
    ) -> None:
        """
        Initialize a PublicCertificateMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateMetadataPatch':
        """Initialize a PublicCertificateMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificatePrototype(SecretPrototype):
    """
    PublicCertificatePrototype.

    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr str common_name: The Common Name (CN) represents the server name protected
          by the SSL certificate.
    :attr List[str] alt_names: (optional) With the Subject Alternative Name field,
          you can specify additional hostnames to be protected by a single SSL
          certificate.
    :attr str key_algorithm: (optional) The identifier for the cryptographic
          algorithm that is used to generate the public key that is associated with the
          certificate.
          The algorithm that you select determines the encryption algorithm (`RSA` or
          `ECDSA`) and key size to be used to generate keys and sign certificates. For
          longer living certificates, it is recommended to use longer keys to provide more
          encryption protection. Allowed values:  `RSA2048`, `RSA4096`, `ECDSA256`, and
          `ECDSA384`.
    :attr str ca: The name of the certificate authority configuration.
    :attr str dns: The name of the DNS provider configuration.
    :attr bool bundle_certs: (optional) This field indicates whether your issued
          certificate is bundled with intermediate certificates. Set to `false` for the
          certificate file to contain only the issued certificate.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        common_name: str,
        ca: str,
        dns: str,
        *,
        description: str = None,
        secret_group_id: str = None,
        labels: List[str] = None,
        alt_names: List[str] = None,
        key_algorithm: str = None,
        bundle_certs: bool = None,
        rotation: 'RotationPolicy' = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a PublicCertificatePrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str common_name: The Common Name (CN) represents the server name
               protected by the SSL certificate.
        :param str ca: The name of the certificate authority configuration.
        :param str dns: The name of the DNS provider configuration.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param List[str] alt_names: (optional) With the Subject Alternative Name
               field, you can specify additional hostnames to be protected by a single SSL
               certificate.
        :param str key_algorithm: (optional) The identifier for the cryptographic
               algorithm that is used to generate the public key that is associated with
               the certificate.
               The algorithm that you select determines the encryption algorithm (`RSA` or
               `ECDSA`) and key size to be used to generate keys and sign certificates.
               For longer living certificates, it is recommended to use longer keys to
               provide more encryption protection. Allowed values:  `RSA2048`, `RSA4096`,
               `ECDSA256`, and `ECDSA384`.
        :param bool bundle_certs: (optional) This field indicates whether your
               issued certificate is bundled with intermediate certificates. Set to
               `false` for the certificate file to contain only the issued certificate.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.common_name = common_name
        self.alt_names = alt_names
        self.key_algorithm = key_algorithm
        self.ca = ca
        self.dns = dns
        self.bundle_certs = bundle_certs
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificatePrototype':
        """Initialize a PublicCertificatePrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificatePrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in PublicCertificatePrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'common_name' in _dict:
            args['common_name'] = _dict.get('common_name')
        else:
            raise ValueError('Required property \'common_name\' not present in PublicCertificatePrototype JSON')
        if 'alt_names' in _dict:
            args['alt_names'] = _dict.get('alt_names')
        if 'key_algorithm' in _dict:
            args['key_algorithm'] = _dict.get('key_algorithm')
        if 'ca' in _dict:
            args['ca'] = _dict.get('ca')
        else:
            raise ValueError('Required property \'ca\' not present in PublicCertificatePrototype JSON')
        if 'dns' in _dict:
            args['dns'] = _dict.get('dns')
        else:
            raise ValueError('Required property \'dns\' not present in PublicCertificatePrototype JSON')
        if 'bundle_certs' in _dict:
            args['bundle_certs'] = _dict.get('bundle_certs')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificatePrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'common_name') and self.common_name is not None:
            _dict['common_name'] = self.common_name
        if hasattr(self, 'alt_names') and self.alt_names is not None:
            _dict['alt_names'] = self.alt_names
        if hasattr(self, 'key_algorithm') and self.key_algorithm is not None:
            _dict['key_algorithm'] = self.key_algorithm
        if hasattr(self, 'ca') and self.ca is not None:
            _dict['ca'] = self.ca
        if hasattr(self, 'dns') and self.dns is not None:
            _dict['dns'] = self.dns
        if hasattr(self, 'bundle_certs') and self.bundle_certs is not None:
            _dict['bundle_certs'] = self.bundle_certs
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificatePrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificatePrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificatePrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class PublicCertificateRotationPolicy(RotationPolicy):
    """
    This field indicates whether Secrets Manager rotates your secrets automatically.
    For public certificates, if `auto_rotate` is set to `true`, the service reorders your
    certificate for 31 days, before it expires.

    :attr bool auto_rotate: This field indicates whether Secrets Manager rotates
          your secret automatically.
          The default is `false`. If `auto_rotate` is set to `true` the service rotates
          your secret based on the defined interval.
    :attr bool rotate_keys: This field indicates whether Secrets Manager rotates the
          private key for your public certificate automatically.
          The default is `false`. If it is set to `true`, the service generates and stores
          a new private key for your rotated certificate.
    """

    def __init__(
        self,
        auto_rotate: bool,
        rotate_keys: bool,
    ) -> None:
        """
        Initialize a PublicCertificateRotationPolicy object.

        :param bool auto_rotate: This field indicates whether Secrets Manager
               rotates your secret automatically.
               The default is `false`. If `auto_rotate` is set to `true` the service
               rotates your secret based on the defined interval.
        :param bool rotate_keys: This field indicates whether Secrets Manager
               rotates the private key for your public certificate automatically.
               The default is `false`. If it is set to `true`, the service generates and
               stores a new private key for your rotated certificate.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotate = auto_rotate
        self.rotate_keys = rotate_keys

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateRotationPolicy':
        """Initialize a PublicCertificateRotationPolicy object from a json dictionary."""
        args = {}
        if 'auto_rotate' in _dict:
            args['auto_rotate'] = _dict.get('auto_rotate')
        else:
            raise ValueError('Required property \'auto_rotate\' not present in PublicCertificateRotationPolicy JSON')
        if 'rotate_keys' in _dict:
            args['rotate_keys'] = _dict.get('rotate_keys')
        else:
            raise ValueError('Required property \'rotate_keys\' not present in PublicCertificateRotationPolicy JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateRotationPolicy object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotate') and self.auto_rotate is not None:
            _dict['auto_rotate'] = self.auto_rotate
        if hasattr(self, 'rotate_keys') and self.rotate_keys is not None:
            _dict['rotate_keys'] = self.rotate_keys
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateRotationPolicy object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateRotationPolicy') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateRotationPolicy') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PublicCertificateVersion(SecretVersion):
    """
    Versions of your public certificate.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :attr CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    :attr str certificate: (optional) Your PEM-encoded certificate. The data must be
          formatted on a single line with embedded newline characters.
    :attr str intermediate: (optional) The PEM-encoded intermediate certificate that
          is associated with the root certificate. The data must be formatted on a single
          line with embedded newline characters.
    :attr str private_key: (optional) The PEM-encoded private key that is associated
          with the certificate. The data must be formatted on a single line with embedded
          newline characters.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        expiration_date: datetime = None,
        serial_number: str = None,
        validity: 'CertificateValidity' = None,
        certificate: str = None,
        intermediate: str = None,
        private_key: str = None,
    ) -> None:
        """
        Initialize a PublicCertificateVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        :param str certificate: (optional) Your PEM-encoded certificate. The data
               must be formatted on a single line with embedded newline characters.
        :param str intermediate: (optional) The PEM-encoded intermediate
               certificate that is associated with the root certificate. The data must be
               formatted on a single line with embedded newline characters.
        :param str private_key: (optional) The PEM-encoded private key that is
               associated with the certificate. The data must be formatted on a single
               line with embedded newline characters.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity
        self.certificate = certificate
        self.intermediate = intermediate
        self.private_key = private_key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateVersion':
        """Initialize a PublicCertificateVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificateVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificateVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PublicCertificateVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PublicCertificateVersion JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        if 'certificate' in _dict:
            args['certificate'] = _dict.get('certificate')
        if 'intermediate' in _dict:
            args['intermediate'] = _dict.get('intermediate')
        if 'private_key' in _dict:
            args['private_key'] = _dict.get('private_key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        if hasattr(self, 'certificate') and self.certificate is not None:
            _dict['certificate'] = self.certificate
        if hasattr(self, 'intermediate') and self.intermediate is not None:
            _dict['intermediate'] = self.intermediate
        if hasattr(self, 'private_key') and self.private_key is not None:
            _dict['private_key'] = self.private_key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PublicCertificateVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your public certificate.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr str serial_number: (optional) The unique serial number that was assigned
          to a certificate by the issuing certificate authority.
    :attr CertificateValidity validity: (optional) The date and time that the
          certificate validity period begins and ends.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
        expiration_date: datetime = None,
        serial_number: str = None,
        validity: 'CertificateValidity' = None,
    ) -> None:
        """
        Initialize a PublicCertificateVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param str serial_number: (optional) The unique serial number that was
               assigned to a certificate by the issuing certificate authority.
        :param CertificateValidity validity: (optional) The date and time that the
               certificate validity period begins and ends.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.expiration_date = expiration_date
        self.serial_number = serial_number
        self.validity = validity

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateVersionMetadata':
        """Initialize a PublicCertificateVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in PublicCertificateVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in PublicCertificateVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in PublicCertificateVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in PublicCertificateVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in PublicCertificateVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in PublicCertificateVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in PublicCertificateVersionMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'serial_number' in _dict:
            args['serial_number'] = _dict.get('serial_number')
        if 'validity' in _dict:
            args['validity'] = CertificateValidity.from_dict(_dict.get('validity'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'serial_number') and self.serial_number is not None:
            _dict['serial_number'] = self.serial_number
        if hasattr(self, 'validity') and self.validity is not None:
            if isinstance(self.validity, dict):
                _dict['validity'] = self.validity
            else:
                _dict['validity'] = self.validity.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class PublicCertificateVersionPrototype(SecretVersionPrototype):
    """
    PublicCertificateVersionPrototype.

    :attr PublicCertificateRotationObject rotation: Defines the rotation object that
          is used to manually rotate public certificates.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        rotation: 'PublicCertificateRotationObject',
        *,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a PublicCertificateVersionPrototype object.

        :param PublicCertificateRotationObject rotation: Defines the rotation
               object that is used to manually rotate public certificates.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.rotation = rotation
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PublicCertificateVersionPrototype':
        """Initialize a PublicCertificateVersionPrototype object from a json dictionary."""
        args = {}
        if 'rotation' in _dict:
            args['rotation'] = PublicCertificateRotationObject.from_dict(_dict.get('rotation'))
        else:
            raise ValueError('Required property \'rotation\' not present in PublicCertificateVersionPrototype JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PublicCertificateVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PublicCertificateVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PublicCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PublicCertificateVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class UsernamePasswordSecret(Secret):
    """
    Your user credentials secret.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    :attr str username: The username that is assigned to an `username_password`
          secret.
    :attr str password: The password that is assigned to an `username_password`
          secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        rotation: 'RotationPolicy',
        username: str,
        password: str,
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        expiration_date: datetime = None,
        next_rotation_date: datetime = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecret object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param str username: The username that is assigned to an
               `username_password` secret.
        :param str password: The password that is assigned to an
               `username_password` secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.rotation = rotation
        self.expiration_date = expiration_date
        self.next_rotation_date = next_rotation_date
        self.username = username
        self.password = password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecret':
        """Initialize a UsernamePasswordSecret object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecret JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecret JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in UsernamePasswordSecret JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecret JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecret JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecret JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in UsernamePasswordSecret JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in UsernamePasswordSecret JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in UsernamePasswordSecret JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        else:
            raise ValueError('Required property \'username\' not present in UsernamePasswordSecret JSON')
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        else:
            raise ValueError('Required property \'password\' not present in UsernamePasswordSecret JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecret object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecret object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecret') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecret') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class UsernamePasswordSecretMetadata(SecretMetadata):
    """
    Properties of the metadata of your user credentials secret.

    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr str crn: A CRN that uniquely identifies an IBM Cloud resource.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr int locks_total: (optional) The number of locks of the secret.
    :attr str name: (optional) The human-readable name of your secret.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr int state: (optional) The secret state that is based on `NIST SP 800-57`.
          States are integers and correspond to the `Pre-activation = 0`, `Active = 1`,
          `Suspended = 2`, `Deactivated = 3`, and `Destroyed = 5` values.
    :attr str state_description: (optional) A text representation of the secret
          state.
    :attr datetime updated_at: The date when a resource was modified. The date
          format follows `RFC 3339`.
    :attr int versions_total: The number of versions of your secret.
    :attr RotationPolicy rotation: This field indicates whether Secrets Manager
          rotates your secrets automatically. Supported secret types: username_password,
          private_cert, public_cert, iam_credentials.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr datetime next_rotation_date: (optional) The date that the secret is
          scheduled for automatic rotation.
          The service automatically creates a new version of the secret on its next
          rotation date. This field exists only for secrets that can be auto-rotated and
          an existing rotation policy.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        crn: str,
        id: str,
        secret_group_id: str,
        secret_type: str,
        updated_at: datetime,
        versions_total: int,
        rotation: 'RotationPolicy',
        *,
        custom_metadata: dict = None,
        description: str = None,
        downloaded: bool = None,
        labels: List[str] = None,
        locks_total: int = None,
        name: str = None,
        state: int = None,
        state_description: str = None,
        expiration_date: datetime = None,
        next_rotation_date: datetime = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str crn: A CRN that uniquely identifies an IBM Cloud resource.
        :param str id: A v4 UUID identifier.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param datetime updated_at: The date when a resource was modified. The date
               format follows `RFC 3339`.
        :param int versions_total: The number of versions of your secret.
        :param RotationPolicy rotation: This field indicates whether Secrets
               Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.created_by = created_by
        self.created_at = created_at
        self.crn = crn
        self.custom_metadata = custom_metadata
        self.description = description
        self.downloaded = downloaded
        self.id = id
        self.labels = labels
        self.locks_total = locks_total
        self.name = name
        self.secret_group_id = secret_group_id
        self.secret_type = secret_type
        self.state = state
        self.state_description = state_description
        self.updated_at = updated_at
        self.versions_total = versions_total
        self.rotation = rotation
        self.expiration_date = expiration_date
        self.next_rotation_date = next_rotation_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretMetadata':
        """Initialize a UsernamePasswordSecretMetadata object from a json dictionary."""
        args = {}
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecretMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecretMetadata JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        else:
            raise ValueError('Required property \'crn\' not present in UsernamePasswordSecretMetadata JSON')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecretMetadata JSON')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'locks_total' in _dict:
            args['locks_total'] = _dict.get('locks_total')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecretMetadata JSON')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretMetadata JSON')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'state_description' in _dict:
            args['state_description'] = _dict.get('state_description')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        else:
            raise ValueError('Required property \'updated_at\' not present in UsernamePasswordSecretMetadata JSON')
        if 'versions_total' in _dict:
            args['versions_total'] = _dict.get('versions_total')
        else:
            raise ValueError('Required property \'versions_total\' not present in UsernamePasswordSecretMetadata JSON')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        else:
            raise ValueError('Required property \'rotation\' not present in UsernamePasswordSecretMetadata JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'next_rotation_date' in _dict:
            args['next_rotation_date'] = string_to_datetime(_dict.get('next_rotation_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'locks_total') and getattr(self, 'locks_total') is not None:
            _dict['locks_total'] = getattr(self, 'locks_total')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            _dict['state'] = getattr(self, 'state')
        if hasattr(self, 'state_description') and getattr(self, 'state_description') is not None:
            _dict['state_description'] = getattr(self, 'state_description')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'versions_total') and self.versions_total is not None:
            _dict['versions_total'] = self.versions_total
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'next_rotation_date') and getattr(self, 'next_rotation_date') is not None:
            _dict['next_rotation_date'] = datetime_to_string(getattr(self, 'next_rotation_date'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class StateDescriptionEnum(str, Enum):
        """
        A text representation of the secret state.
        """

        PRE_ACTIVATION = 'pre_activation'
        ACTIVE = 'active'
        SUSPENDED = 'suspended'
        DEACTIVATED = 'deactivated'
        DESTROYED = 'destroyed'



class UsernamePasswordSecretMetadataPatch(SecretMetadataPatch):
    """
    UsernamePasswordSecretMetadataPatch.

    :attr str name: (optional) A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    """

    def __init__(
        self,
        *,
        name: str = None,
        description: str = None,
        labels: List[str] = None,
        custom_metadata: dict = None,
        rotation: 'RotationPolicy' = None,
        expiration_date: datetime = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretMetadataPatch object.

        :param str name: (optional) A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        """
        # pylint: disable=super-init-not-called
        self.name = name
        self.description = description
        self.labels = labels
        self.custom_metadata = custom_metadata
        self.rotation = rotation
        self.expiration_date = expiration_date

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretMetadataPatch':
        """Initialize a UsernamePasswordSecretMetadataPatch object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretMetadataPatch object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretMetadataPatch object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretMetadataPatch') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretMetadataPatch') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class UsernamePasswordSecretPrototype(SecretPrototype):
    """
    UsernamePasswordSecretPrototype.

    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str name: A human-readable name to assign to your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a name for your secret.
    :attr str description: (optional) An extended description of your secret.
          To protect your privacy, do not use personal data, such as your name or
          location, as a description for your secret group.
    :attr str secret_group_id: (optional) A v4 UUID identifier, or `default` secret
          group.
    :attr List[str] labels: (optional) Labels that you can use to search secrets in
          your instance. Only 30 labels can be created.
          Label can be between 2-30 characters, including spaces.
          To protect your privacy, do not use personal data, such as your name or
          location, as a label for your secret.
    :attr str username: The username that is assigned to an `username_password`
          secret.
    :attr str password: The password that is assigned to an `username_password`
          secret.
    :attr datetime expiration_date: (optional) The date when the secret material
          expires. The date format follows the `RFC 3339` format. Supported secret types:
          Arbitrary, username_password.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr RotationPolicy rotation: (optional) This field indicates whether Secrets
          Manager rotates your secrets automatically. Supported secret types:
          username_password, private_cert, public_cert, iam_credentials.
    """

    def __init__(
        self,
        secret_type: str,
        name: str,
        username: str,
        password: str,
        *,
        description: str = None,
        secret_group_id: str = None,
        labels: List[str] = None,
        expiration_date: datetime = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
        rotation: 'RotationPolicy' = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretPrototype object.

        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str name: A human-readable name to assign to your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a name for your secret.
        :param str username: The username that is assigned to an
               `username_password` secret.
        :param str password: The password that is assigned to an
               `username_password` secret.
        :param str description: (optional) An extended description of your secret.
               To protect your privacy, do not use personal data, such as your name or
               location, as a description for your secret group.
        :param str secret_group_id: (optional) A v4 UUID identifier, or `default`
               secret group.
        :param List[str] labels: (optional) Labels that you can use to search
               secrets in your instance. Only 30 labels can be created.
               Label can be between 2-30 characters, including spaces.
               To protect your privacy, do not use personal data, such as your name or
               location, as a label for your secret.
        :param datetime expiration_date: (optional) The date when the secret
               material expires. The date format follows the `RFC 3339` format. Supported
               secret types: Arbitrary, username_password.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        :param RotationPolicy rotation: (optional) This field indicates whether
               Secrets Manager rotates your secrets automatically. Supported secret types:
               username_password, private_cert, public_cert, iam_credentials.
        """
        # pylint: disable=super-init-not-called
        self.secret_type = secret_type
        self.name = name
        self.description = description
        self.secret_group_id = secret_group_id
        self.labels = labels
        self.username = username
        self.password = password
        self.expiration_date = expiration_date
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata
        self.rotation = rotation

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretPrototype':
        """Initialize a UsernamePasswordSecretPrototype object from a json dictionary."""
        args = {}
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretPrototype JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in UsernamePasswordSecretPrototype JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        if 'labels' in _dict:
            args['labels'] = _dict.get('labels')
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        else:
            raise ValueError('Required property \'username\' not present in UsernamePasswordSecretPrototype JSON')
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        else:
            raise ValueError('Required property \'password\' not present in UsernamePasswordSecretPrototype JSON')
        if 'expiration_date' in _dict:
            args['expiration_date'] = string_to_datetime(_dict.get('expiration_date'))
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'rotation' in _dict:
            args['rotation'] = _dict.get('rotation')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'labels') and self.labels is not None:
            _dict['labels'] = self.labels
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        if hasattr(self, 'expiration_date') and self.expiration_date is not None:
            _dict['expiration_date'] = datetime_to_string(self.expiration_date)
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'rotation') and self.rotation is not None:
            if isinstance(self.rotation, dict):
                _dict['rotation'] = self.rotation
            else:
                _dict['rotation'] = self.rotation.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'



class UsernamePasswordSecretVersion(SecretVersion):
    """
    Your user credentials secret version.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    :attr str username: The username that is assigned to an `username_password`
          secret.
    :attr str password: The password that is assigned to an `username_password`
          secret.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        username: str,
        password: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretVersion object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param str username: The username that is assigned to an
               `username_password` secret.
        :param str password: The password that is assigned to an
               `username_password` secret.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id
        self.username = username
        self.password = password

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretVersion':
        """Initialize a UsernamePasswordSecretVersion object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecretVersion JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecretVersion JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecretVersion JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretVersion JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecretVersion JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in UsernamePasswordSecretVersion JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in UsernamePasswordSecretVersion JSON')
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        else:
            raise ValueError('Required property \'username\' not present in UsernamePasswordSecretVersion JSON')
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        else:
            raise ValueError('Required property \'password\' not present in UsernamePasswordSecretVersion JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class UsernamePasswordSecretVersionMetadata(SecretVersionMetadata):
    """
    Properties of the version metadata of your user credentials secret.

    :attr bool auto_rotated: (optional) Indicates whether the version of the secret
          was created by automatic rotation.
    :attr str created_by: The unique identifier that is associated with the entity
          that created the secret.
    :attr datetime created_at: The date when the resource was created. The date
          format follows `RFC 3339`.
    :attr bool downloaded: (optional) This field indicates whether the secret data
          that is associated with a secret version was retrieved in a call to the service
          API.
    :attr str id: A v4 UUID identifier.
    :attr str secret_name: (optional) The human-readable name of your secret.
    :attr str secret_type: The secret type. Supported types are arbitrary,
          certificates (imported, public, and private), IAM credentials, key-value, and
          user credentials.
    :attr str secret_group_id: A v4 UUID identifier, or `default` secret group.
    :attr bool payload_available: Indicates whether the secret payload is available
          in this secret version.
    :attr str alias: (optional) A human-readable alias that describes the secret
          version. 'Current' is used for version `n` and 'previous' is used for version
          `n-1`.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    :attr str secret_id: A v4 UUID identifier.
    """

    def __init__(
        self,
        created_by: str,
        created_at: datetime,
        id: str,
        secret_type: str,
        secret_group_id: str,
        payload_available: bool,
        secret_id: str,
        *,
        auto_rotated: bool = None,
        downloaded: bool = None,
        secret_name: str = None,
        alias: str = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretVersionMetadata object.

        :param str created_by: The unique identifier that is associated with the
               entity that created the secret.
        :param datetime created_at: The date when the resource was created. The
               date format follows `RFC 3339`.
        :param str id: A v4 UUID identifier.
        :param str secret_type: The secret type. Supported types are arbitrary,
               certificates (imported, public, and private), IAM credentials, key-value,
               and user credentials.
        :param str secret_group_id: A v4 UUID identifier, or `default` secret
               group.
        :param bool payload_available: Indicates whether the secret payload is
               available in this secret version.
        :param str secret_id: A v4 UUID identifier.
        :param bool auto_rotated: (optional) Indicates whether the version of the
               secret was created by automatic rotation.
        :param str alias: (optional) A human-readable alias that describes the
               secret version. 'Current' is used for version `n` and 'previous' is used
               for version `n-1`.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.auto_rotated = auto_rotated
        self.created_by = created_by
        self.created_at = created_at
        self.downloaded = downloaded
        self.id = id
        self.secret_name = secret_name
        self.secret_type = secret_type
        self.secret_group_id = secret_group_id
        self.payload_available = payload_available
        self.alias = alias
        self.version_custom_metadata = version_custom_metadata
        self.secret_id = secret_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretVersionMetadata':
        """Initialize a UsernamePasswordSecretVersionMetadata object from a json dictionary."""
        args = {}
        if 'auto_rotated' in _dict:
            args['auto_rotated'] = _dict.get('auto_rotated')
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        else:
            raise ValueError('Required property \'created_by\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        else:
            raise ValueError('Required property \'created_at\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'downloaded' in _dict:
            args['downloaded'] = _dict.get('downloaded')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'secret_name' in _dict:
            args['secret_name'] = _dict.get('secret_name')
        if 'secret_type' in _dict:
            args['secret_type'] = _dict.get('secret_type')
        else:
            raise ValueError('Required property \'secret_type\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'secret_group_id' in _dict:
            args['secret_group_id'] = _dict.get('secret_group_id')
        else:
            raise ValueError('Required property \'secret_group_id\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'payload_available' in _dict:
            args['payload_available'] = _dict.get('payload_available')
        else:
            raise ValueError('Required property \'payload_available\' not present in UsernamePasswordSecretVersionMetadata JSON')
        if 'alias' in _dict:
            args['alias'] = _dict.get('alias')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        if 'secret_id' in _dict:
            args['secret_id'] = _dict.get('secret_id')
        else:
            raise ValueError('Required property \'secret_id\' not present in UsernamePasswordSecretVersionMetadata JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretVersionMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'auto_rotated') and self.auto_rotated is not None:
            _dict['auto_rotated'] = self.auto_rotated
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'downloaded') and getattr(self, 'downloaded') is not None:
            _dict['downloaded'] = getattr(self, 'downloaded')
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'secret_name') and getattr(self, 'secret_name') is not None:
            _dict['secret_name'] = getattr(self, 'secret_name')
        if hasattr(self, 'secret_type') and self.secret_type is not None:
            _dict['secret_type'] = self.secret_type
        if hasattr(self, 'secret_group_id') and self.secret_group_id is not None:
            _dict['secret_group_id'] = self.secret_group_id
        if hasattr(self, 'payload_available') and self.payload_available is not None:
            _dict['payload_available'] = self.payload_available
        if hasattr(self, 'alias') and self.alias is not None:
            _dict['alias'] = self.alias
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        if hasattr(self, 'secret_id') and self.secret_id is not None:
            _dict['secret_id'] = self.secret_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretVersionMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretVersionMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretVersionMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SecretTypeEnum(str, Enum):
        """
        The secret type. Supported types are arbitrary, certificates (imported, public,
        and private), IAM credentials, key-value, and user credentials.
        """

        ARBITRARY = 'arbitrary'
        IMPORTED_CERT = 'imported_cert'
        PUBLIC_CERT = 'public_cert'
        IAM_CREDENTIALS = 'iam_credentials'
        KV = 'kv'
        USERNAME_PASSWORD = 'username_password'
        PRIVATE_CERT = 'private_cert'


    class AliasEnum(str, Enum):
        """
        A human-readable alias that describes the secret version. 'Current' is used for
        version `n` and 'previous' is used for version `n-1`.
        """

        CURRENT = 'current'
        PREVIOUS = 'previous'



class UsernamePasswordSecretVersionPrototype(SecretVersionPrototype):
    """
    UsernamePasswordSecretVersionPrototype.

    :attr str password: (optional) The password that is assigned to an
          `username_password` secret.
    :attr dict custom_metadata: (optional) The secret metadata that a user can
          customize.
    :attr dict version_custom_metadata: (optional) The secret version metadata that
          a user can customize.
    """

    def __init__(
        self,
        *,
        password: str = None,
        custom_metadata: dict = None,
        version_custom_metadata: dict = None,
    ) -> None:
        """
        Initialize a UsernamePasswordSecretVersionPrototype object.

        :param str password: (optional) The password that is assigned to an
               `username_password` secret.
        :param dict custom_metadata: (optional) The secret metadata that a user can
               customize.
        :param dict version_custom_metadata: (optional) The secret version metadata
               that a user can customize.
        """
        # pylint: disable=super-init-not-called
        self.password = password
        self.custom_metadata = custom_metadata
        self.version_custom_metadata = version_custom_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UsernamePasswordSecretVersionPrototype':
        """Initialize a UsernamePasswordSecretVersionPrototype object from a json dictionary."""
        args = {}
        if 'password' in _dict:
            args['password'] = _dict.get('password')
        if 'custom_metadata' in _dict:
            args['custom_metadata'] = _dict.get('custom_metadata')
        if 'version_custom_metadata' in _dict:
            args['version_custom_metadata'] = _dict.get('version_custom_metadata')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UsernamePasswordSecretVersionPrototype object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'password') and self.password is not None:
            _dict['password'] = self.password
        if hasattr(self, 'custom_metadata') and self.custom_metadata is not None:
            _dict['custom_metadata'] = self.custom_metadata
        if hasattr(self, 'version_custom_metadata') and self.version_custom_metadata is not None:
            _dict['version_custom_metadata'] = self.version_custom_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UsernamePasswordSecretVersionPrototype object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UsernamePasswordSecretVersionPrototype') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UsernamePasswordSecretVersionPrototype') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

##############################################################################
# Pagers
##############################################################################


class SecretsPager:
    """
    SecretsPager can be used to simplify the use of the "list_secrets" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        limit: int = None,
        sort: str = None,
        search: str = None,
        groups: List[str] = None,
    ) -> None:
        """
        Initialize a SecretsPager object.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of secrets by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** id | created_at | updated_at | expiration_date |
               secret_type | name
               **Usage:** To sort a list of secrets by their creation date, use
               `../secrets?sort=created_at`.
        :param str search: (optional) Obtain a collection of secrets that contain
               the specified string in one or more of the fields: `id`, `name`,
               `description`,
               `labels`, `secret_type`.
               **Usage:** If you want to list only the secrets that contain the string
               `text`, use
               `../secrets?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._limit = limit
        self._sort = sort
        self._search = search
        self._groups = groups

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretMetadata.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secrets(
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            groups=self._groups,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('secrets')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretMetadata.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class SecretsLocksPager:
    """
    SecretsLocksPager can be used to simplify the use of the "list_secrets_locks" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        limit: int = None,
        search: str = None,
        groups: List[str] = None,
    ) -> None:
        """
        Initialize a SecretsLocksPager object.
        :param int limit: (optional) The number of secrets to retrieve. By default,
               list operations return the first 200 items. To retrieve a different set of
               items, use `limit` with `offset` to page through your available resources.
               Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 secrets in your
               instance, use
               `..?limit=25`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        :param List[str] groups: (optional) Filter secrets by groups.
               You can apply multiple filters by using a comma-separated list of secret
               group IDs. If you need to filter secrets that are in the default secret
               group, use the `default` keyword.
               **Usage:** To retrieve a list of secrets that are associated with an
               existing secret group or the default group, use
               `..?groups={secret_group_ID},default`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._limit = limit
        self._search = search
        self._groups = groups

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLocks.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secrets_locks(
            limit=self._limit,
            search=self._search,
            groups=self._groups,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('secrets_locks')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLocks.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class SecretLocksPager:
    """
    SecretLocksPager can be used to simplify the use of the "list_secret_locks" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        id: str,
        limit: int = None,
        sort: str = None,
        search: str = None,
    ) -> None:
        """
        Initialize a SecretLocksPager object.
        :param str id: The v4 UUID that uniquely identifies your secret.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._id = id
        self._limit = limit
        self._sort = sort
        self._search = search

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secret_locks(
            id=self._id,
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('locks')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class SecretVersionLocksPager:
    """
    SecretVersionLocksPager can be used to simplify the use of the "list_secret_version_locks" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        secret_id: str,
        id: str,
        limit: int = None,
        sort: str = None,
        search: str = None,
    ) -> None:
        """
        Initialize a SecretVersionLocksPager object.
        :param str secret_id: The v4 UUID that uniquely identifies your secret.
        :param str id: The v4 UUID that uniquely identifies your secret version.
               You can use the `current` or `previous` aliases to refer to the current or
               previous secret version.
        :param int limit: (optional) The number of locks with associated secret to
               retrieve. By default, list operations return the first 25 items. To
               retrieve a different set of items, use `limit` with `offset` to page
               through your available resources.
               **Usage:** If you have 20 secrets in your instance, and you want to
               retrieve only the first 5, use
               `..?limit=5`.
        :param str sort: (optional) Sort a collection of locks by the specified
               field in ascending order. To sort in descending order use the `-` character
               **Available values:** created_at | updated_at | name
               **Usage:** To sort a list of locks by their creation date, use
               `../locks?sort=created_at`.
        :param str search: (optional) Filter locks that contain the specified
               string in the field "name".
               **Usage:** If you want to list only the locks that contain the string
               "text" in the field "name", use
               `..?search=text`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._secret_id = secret_id
        self._id = id
        self._limit = limit
        self._sort = sort
        self._search = search

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_secret_version_locks(
            secret_id=self._secret_id,
            id=self._id,
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('locks')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of SecretLock.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results


class ConfigurationsPager:
    """
    ConfigurationsPager can be used to simplify the use of the "list_configurations" method.
    """

    def __init__(
        self,
        *,
        client: SecretsManagerV2,
        limit: int = None,
        sort: str = None,
        search: str = None,
    ) -> None:
        """
        Initialize a ConfigurationsPager object.
        :param int limit: (optional) The number of configurations to retrieve. By
               default, list operations return the first 200 items. To retrieve a
               different set of items, use `limit` with `offset` to page through your
               available resources. Maximum limit allowed is 1000 secrets.
               **Usage:** If you want to retrieve only the first 25 configurations in your
               instance, use
               `..?limit=25`.
        :param str sort: (optional) Sort a collection of configurations by the
               specified field in ascending order. To sort in descending order use the `-`
               character
               **Available values:**  config_type | secret_type | name
               **Usage:** To sort a list of configurations by their creation date, use
               `../configurations?sort=config_type`.
        :param str search: (optional) Obtain a collection of configurations that
               contain the specified string in one or more of the fields: `name`,
               `config_type`, `secret_type`.
               **Usage:** If you want to list only the configurations that contain the
               string `text`, use
               `../configurations?search=text`.
        """
        self._has_next = True
        self._client = client
        self._page_context = {'next': None}
        self._limit = limit
        self._sort = sort
        self._search = search

    def has_next(self) -> bool:
        """
        Returns true if there are potentially more results to be retrieved.
        """
        return self._has_next

    def get_next(self) -> List[dict]:
        """
        Returns the next page of results.
        :return: A List[dict], where each element is a dict that represents an instance of ConfigurationMetadata.
        :rtype: List[dict]
        """
        if not self.has_next():
            raise StopIteration(message='No more results available')

        result = self._client.list_configurations(
            limit=self._limit,
            sort=self._sort,
            search=self._search,
            offset=self._page_context.get('next'),
        ).get_result()

        next = None
        next_page_link = result.get('next')
        if next_page_link is not None:
            next = get_query_param(next_page_link.get('href'), 'offset')
        self._page_context['next'] = next
        if next is None:
            self._has_next = False

        return result.get('configurations')

    def get_all(self) -> List[dict]:
        """
        Returns all results by invoking get_next() repeatedly
        until all pages of results have been retrieved.
        :return: A List[dict], where each element is a dict that represents an instance of ConfigurationMetadata.
        :rtype: List[dict]
        """
        results = []
        while self.has_next():
            next_page = self.get_next()
            results.extend(next_page)
        return results
